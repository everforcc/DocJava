<span style="font-family:Simsun,serif; font-size:17px;">

[TOC]

- [参考地址](https://zhuanlan.zhihu.com/p/567047691)

### 1. redis理解

#### 读写性能优异

- 读的速度是110000次/s,写的速度是81000次/s

#### 数据类型丰富

- 支持Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。

#### 原子性

- 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

#### 丰富的特性

- 支持简易订阅通知（Pub/Sub） ，按key设置过期时间，过期后将会自动删除。

#### 持久化

- 支持RDB, AOF等持久化方式

### 2. 为什么Redis 是单线程的以及为什么这么快

#### 单线程的原因

- Redis的瓶颈不是CPU，而是网络和内存。
- 多线程就会存在死锁、线程上下⽂切换等问题，甚⾄会影响性能。
- 单线程编程容易并且更容易维护。

#### 为什么这么快

- redis完全基于内存：绝大部分请求是纯粹的内存操作，非常快速。
- 数据结构简单：redis中的数据结构是专门进行设计的。
- 采用单线程模型，避免了不必要的上下文切换和竞争条件：也不存在多线程或者多线程切换而消耗CPU, 不用考虑各种锁的问题, 不存在加锁, 释放锁的操作, 没有因为可能出现死锁而导致性能消耗
- 使用了多路IO复用模型：非阻塞IO

### 3. 使用场景

#### 热点数据的缓存

- 缓存是Redis最常见的应用场景，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。

#### 限时业务的运用

- redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

#### 计数器相关问题

- redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

#### 分布式锁

- 这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 。因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先
  通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。
  当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。

### 3. 数据类型

- String（字符串）
- list（双向列表）
- Hash（哈希）
- set（集合）
- zset（有序集合）

### 4. 持久化机制

#### RDB（snapshotting）

- 是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。

##### 手动触发

- save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间阻塞，线上环境不建议使用
- bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子 进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。

##### 自动触发

- redis.conf中配置save m n，即在m秒内有n次修改时，自动触发bgsave生成rdb文件；
- 主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点；
- 执行debug reload命令重新加载redis时也会触发bgsave操作；
- 默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作；

##### 优点

- 只有一个文件 dump.rdb，方便持久化。
- 容灾性好，一个文件可以保存到安全的磁盘。
- 性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。
- 相对于数据集大时，比 AOF 的启动效率更高。

##### 缺点

- 数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

#### AOF（append-only-file）：

- 将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。AOF日志是一种写后日志，“写后”的意思是Redis是先执行命令，把数据写入内存，然后才记录日志

##### 为什么采用写后日志？

- 避免额外的检查开销：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。
- 不会阻塞当前的写操作
- 但这种方式存在潜在风险：
    - 如果命令执行完成，写日志之前宕机了，会丢失数据。
    - 主线程写磁盘压力大，导致写盘慢，阻塞后续操作。

##### AOF的实现：

- AOF日志记录Redis的每个写命令，步骤分为：命令追加、文件的写入和同步。
- 命令追加：当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。
- 文件写入和同步： 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：
    - always
    - everysec
    - no

##### AOF的重写

- Redis通过创建一个新的AOF文件来替换现有的AOF，新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。

##### AOF重写会阻塞吗？

-
AOF重写过程是由后台进程bgrewriteaof来完成的。主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。
- 所以aof在重写时，在fork进程时是会阻塞住主线程的。

##### AOF日志何时会重写？

- 有两个配置项控制AOF重写的触发：
- auto-aof-rewrite-min-size：表示运行AOF重写时文件的最小大小，默认为64MB。
-
auto-aof-rewrite-percentage：这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。

##### 优点

- 安全，所有写入的数据都不会丢失。
- AOF文件易读，可修改。

##### 缺点

- AOF 文件比 RDB 文件大。
- 恢复速度慢。
- 性能消耗高。

### 6. 过期Key的删除策略 - todo

### 7. 内存淘汰策略 - todo

### 8. 事务 - todo

```
gantt
    title A Gantt Diagram
    dateFormat  YYYY-MM-DD
    section Section
    A task           :a1, 2014-01-01, 30d
    Another task     :after a1  , 20d
    section Another
    Task in sec      :2014-01-12  , 12d
    another task      : 24d
```

</span>