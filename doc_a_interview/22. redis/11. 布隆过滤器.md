<span style="font-family:Simsun,serif; font-size:17px;">

[TOC]

### 布隆过滤器

- 有一种叫作散列表（又叫哈希表，Hash table）的数据结构。
- 它可以通过一个Hash函数将一个元素映射成一个位阵列（Bit array）中的一个点。
- 这样一来，我们只要看看这个点是不是1就可以知道集合中有没有它了。这就是布隆过滤器的基本思想。

### 冲突

- Hash面临的问题就是冲突。
- 假设Hash函数是良好的，如果我们的位阵列长度为m个点，那么如果我们想将冲突率降低到例如 1%, 这个散列表就只能容纳m / 100个元素。
- 显然这就不叫空间效率了（Space-efficient）了。
- 解决方法也简单，就是使用多个Hash，如果它们有一个说元素不在集合中，那肯定就不在。
- 如果它们都说在，虽然也有一定可能性它们在说谎，不过直觉上判断这种事情的概率是比较低的。

### 优点

- 相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。
- 布隆过滤器存储空间和插入/查询时间都是常数。
- 另外, Hash函数相互之间没有关系，方便由硬件并行实现。
- 布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。
- 布隆过滤器可以表示全集，其它任何数据结构都不能。

### 缺点

- 但是布隆过滤器的缺点和优点一样明显。
- 误算率是其中之一。随着存入的元素数量增加，误算率随之增加。
- 常见的补救办法是建立一个小的白名单，存储那些可能被误判的元素。
- 但是如果元素数量太少，则使用散列表足矣。
- 另外，一般情况下不能从布隆过滤器中删除元素。
- 我们很容易想到把位列阵变成整数数组，每插入一个元素相应的计数器加1,
  这样删除元素时将计数器减掉就可以了。然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面.
  这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。
- 在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。

### 应用

- 网页URL的去重
- 垃圾邮件的判别
- 集合重复元素的判别
- 查询加速（比如基于key-value的存储系统）
- 数据库防止查询击穿
- 使用BloomFilter来减少不存在的行或列的磁盘查找。

### 客户端

~~~
RBloomFilter<String> stringRBloomFilter = redissonClient.getBloomFilter("test_bloom_key");
stringRBloomFilter.tryInit(1000, 0.03);
~~~

</span>