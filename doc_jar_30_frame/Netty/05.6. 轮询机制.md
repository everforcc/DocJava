<span  style="font-family: Simsun,serif; font-size: 17px; ">

- 轮询机制的实现原理

[TOC]

### 5.9.1 轮询机制的实现原理

- DefaultEventExecutorChooserFactory的源码：
~~~
// 如果是2的n次方，返回true
private static boolean isPowerOfTwo(int val) {
    return (val & -val) == val;
}

// 根据线程数，判断用哪个实现
@Override
public EventExecutorChooser newChooser(EventExecutor[] executors) {
    if (isPowerOfTwo(executors.length)) {
        return new PowerOfTwoEventExecutorChooser(executors);
    } else {
        return new GenericEventExecutorChooser(executors);
    }
}
~~~

~~~
//
private static final class PowerOfTwoEventExecutorChooser implements EventExecutorChooser {
    private final AtomicInteger idx = new AtomicInteger();
    private final EventExecutor[] executors;

    PowerOfTwoEventExecutorChooser(EventExecutor[] executors) {
        this.executors = executors;
    }

    // 2的n次方，对长度位运算
    @Override
    public EventExecutor next() {
        return executors[idx.getAndIncrement() & executors.length - 1];
    }
}
//
private static final class GenericEventExecutorChooser implements EventExecutorChooser {
    private final AtomicInteger idx = new AtomicInteger();
    private final EventExecutor[] executors;

    GenericEventExecutorChooser(EventExecutor[] executors) {
        this.executors = executors;
    }

    // 取模算法
    @Override
    public EventExecutor next() {
        return executors[Math.abs(idx.getAndIncrement() % executors.length)];
    }
}
~~~

</span>