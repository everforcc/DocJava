<span  style="font-family: Simsun,serif; font-size: 17px; ">

## Git 仓库误提交大文件（.jar）与推送被拒的处理记录

背景：本地项目同时连了 GitHub 和 Gitee。误把若干 .jar 包提交进仓库历史，导致 GitHub 因 100MB 限制拒绝推送；同时在清理历史后向 Gitee 推送又遇到 non fast-forward
提示。这里记录完整可复现的处理流程（Windows PowerShell 环境）。

---

### 一、先在工作区停止跟踪并忽略 .jar

1) 在 `.gitignore` 添加忽略规则（防止再次提交）：

```gitignore
doc_java_project_znkj/**/jar/*.jar
```

2) 从 Git 索引中移除已跟踪的 JAR（不删除磁盘文件）：

```bash
git rm -r --cached "doc_java_project_znkj"
git add .
git commit -m "chore: stop tracking jar artifacts"
```

说明：路径包含空格/中文时使用双引号。

---

### 二、从完整历史中移除大文件（推荐 git filter-repo）

git 官方推荐使用 `git filter-repo`（替代 BFG，速度更快、结果更稳）。未安装时：

```bash
pip install git-filter-repo
```

在仓库根目录执行，删除历史里所有匹配的 JAR：

```bash
git filter-repo --invert-paths --path-glob "doc_java_project_znkj/**/jar/*.jar"
```

如果还有其它大文件路径，可追加多个 `--path-glob`。

清理历史残留引用并瘦身：

```bash
git for-each-ref --format="delete %(refname)" refs/original | git update-ref --stdin
git reflog expire --expire=now --all
git gc --prune=now --aggressive
```

---

### 三、推送至远端（Gitee、GitHub）

先确认远端：

```bash
git remote -v
```

拉取最新引用并清理已删除远端分支引用：

```bash
git fetch --all --prune
```

如果你的目标是“用已清理的历史覆盖远端”（通常需要覆盖），建议使用带保护的强推 `--force-with-lease`：

仅覆盖当前分支（例如 `v_1`）：

```bash
git push gitee v_1 --force-with-lease
```

或覆盖所有分支与标签：

```bash
git push gitee --force-with-lease --all
git push gitee --force-with-lease --tags
```

注意：若 Gitee 启用了保护分支，需要在仓库设置中临时关闭保护（允许强推），推送完成后再重新开启。

随后推送到 GitHub（清理后将不再触发 100MB 限制）：

```bash
git push origin --all
git push origin --tags
```

---

### 四、处理非 fast-forward（推送被拒）

报错提示（示例）：“hint: not have locally… You may want to first integrate the remote changes… Note about
fast-forwards”。这表示远端分支存在本地没有的提交。

- 如果要覆盖远端（历史已重写，通常选这个） → 强推：

```bash
git fetch --all --prune
git push <remote> <branch> --force-with-lease
```

- 如果不想覆盖远端，而是合入远端变更：
    - 线性历史（rebase）：
      ```bash
      git fetch <remote>
      git rebase <remote>/<branch>
      # 解决冲突 -> git add <files> ->
      git rebase --continue
      git push <remote> <branch>
      ```
    - 普通合并：
      ```bash
      git pull <remote> <branch>
      git push <remote> <branch>
      ```

---

### 五、可选：今后用 Git LFS 跟踪二进制产物

避免再次把大文件写入 Git 历史：

```bash
git lfs install
git lfs track "*.jar"
git add .gitattributes
git add .
git commit -m "chore: track jars with Git LFS"
```

注意：LFS 仅对未来提交生效；历史中的大文件仍需用上面的“历史重写”来清理。

---

### 六、常见坑位

- 路径含空格/中文：Windows 下参数务必用双引号包裹（上文命令已如此）。
- 保护分支：Gitee/GitHub 的保护分支会拒绝强推，需临时关闭保护。
- 多人协作：仓库历史重写后，协作者需重新获取新历史：
  ```bash
  git fetch --all --prune
  # 若需要强制对齐：
  git checkout v_1
  git reset --hard origin/v_1
  ```
- GitHub 100MB 限制：历史里一旦含有超限文件，即使当前提交已删除，也会被拒；必须“重写历史”彻底移除。

---

### 七、最小可执行命令清单（按需替换远端与分支名）

```bash
# 0) 可选：查看远端与当前分支
git remote -v
git branch --show-current

# 1) 忽略并停止跟踪 jar
echo 'doc_java_project_znkj/**/jar/*.jar' >> .gitignore
git rm -r --cached "doc_java_project_znkj"
git add .
git commit -m "chore: stop tracking jar artifacts"

# 2) 安装并执行历史清理
pip install git-filter-repo
git filter-repo --invert-paths --path-glob "doc_java_project_znkj/**/jar/*.jar"
git for-each-ref --format="delete %(refname)" refs/original | git update-ref --stdin
git reflog expire --expire=now --all
git gc --prune=now --aggressive

# 3) 强推到 Gitee（如有保护分支先临时关闭）
git fetch --all --prune
git push gitee v_1 --force-with-lease

# 4) 推送到 GitHub
git push origin --all
git push origin --tags

# 5) 可选：启用 LFS 以跟踪未来的 jar
git lfs install
git lfs track "*.jar"
git add .gitattributes
git add .
git commit -m "chore: track jars with Git LFS"
```

---

记录人：@everforcc  
更新时间：2025-11-10


</span>