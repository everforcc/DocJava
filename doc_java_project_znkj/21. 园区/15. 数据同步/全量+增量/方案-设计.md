<span  style="font-family: Simsun,serif; font-size: 17px; ">

[TOC]

### 1. 边缘设备与云端数据库备份恢复技术方案

#### 1.1. 架构说明

- 本地端：Java (SpringBoot) + MySQL (Docker)，通过 UUID 作为主键，包含 create_time 和 update_time。
- 云端：作为汇总库，表结构多出一个 sn 字段（设备序列号）。
- 核心逻辑：
    - 全量恢复：使用 0 点备份的 SQL 文件直接还原。
    - 增量恢复：提取云端增量记录，过滤 sn 字段，利用 ON DUPLICATE KEY UPDATE 实现幂等合并。

#### 1.2. Docker 环境准备 (Dockerfile)

- 为了让 Java 容器能够直接调用备份指令而无需映射宿主机，需在镜像中预装客户端工具。
- 或者映射下目录用以下命令

~~~Dockerfile
FROM openjdk:17-jdk-slim
# 安装 mysql 客户端以便 Java 调用 mysqldump 和 mysql 命令
RUN apt-get update && apt-get install -y default-mysql-client && rm -rf /var/lib/apt/lists/*
COPY target/app.jar /app.jar
ENTRYPOINT ["java", "-jar", "/app.jar"]
~~~

- 如果用下面的方案，必须有这个配置文件

~~~
-v /var/run/docker.sock:/var/run/docker.sock。
~~~

~~~shell
docker exec mysqlCotainer /bin/bash -c 'mysqldump -h localhost -P 3306 -u root -pccdevback --databases smartparklocal' > $FILE
docker exec mysqlCotainer /bin/bash -c 'mysqldump -h localhost -P 3306 -u root -pccdevback --databases smartparklocal | gzip' > $FILE.gz
docker exec mysqlCotainer /bin/bash -c 'mysqldump -h localhost -u root -pccdevback --databases db1 db2 db3 | gzip' > $FILE.sql.gz

# 精简版导出（省略了 -h 和 -P）
docker exec mysqlCotainer /bin/bash -c 'mysqldump -u root -pccdevback --databases oneforall | gzip' > $FILE.sql.gz
~~~

### 2. 数据备份

#### 2.1. 全量备份与状态监控 (Java)

- 通过 ProcessBuilder 调用脚本，并通过退出码判断是否完成。

~~~java
import lombok.extern.slf4j.Slf4j;

import java.io.*;

@Slf4j
public class BackupExecutor {

    public boolean runFullBackup(String host, String user, String password, String dbName, String targetPath) {
        // 直接在 Java 容器内调用已安装的 mysqldump，连接到同网络的 mysql 容器
        String command = String.format("mysqldump -h %s -u %s -p'%s' %s > %s",
                host, user, password, dbName, targetPath);
        try {
            ProcessBuilder pb = new ProcessBuilder("sh", "-c", command);
            Process process = pb.start();

            // 异步读取错误流，防止进程阻塞
            new Thread(() -> {
                try (BufferedReader err = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
                    String line;
                    while ((line = err.readLine()) != null) log.error("Dump Error: {}", line);
                } catch (IOException ignored) {
                }
            }).start();

            int exitCode = process.waitFor();
            return exitCode == 0; // 返回 0 说明备份脚本执行成功完成
        } catch (Exception e) {
            log.error("备份进程执行异常", e);
            return false;
        }
    }
}
~~~

~~~java
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import java.io.*;

@Slf4j
@Service
public class BackupService {

    /**
     * 执行全量备份并监控完成状态
     * @param containerName MySQL 容器名 (mysqlCotainer)
     * @param database 数据库名 (oneforall)
     * @param targetPath 备份文件在 Java 容器内的保存路径
     */
    public boolean executeFullBackup(String containerName, String database, String targetPath) {
        // 基于您提供的脚本构建命令
        // 注意：去掉了可能导致程序挂起的交互式参数，保留了 /bin/bash -c 结构
        // docker exec mysqlCotainer  /bin/bash -c 'mysqldump -h localhost -P 3306 -u root -pccdevback --databases oneforall' > $FILE
        String command = String.format(
            "docker exec %s /bin/bash -c 'mysqldump -h localhost -P 3306 -u root -pccdevback --databases %s' > %s",
            containerName, database, targetPath
        );

        try {
            ProcessBuilder pb = new ProcessBuilder("sh", "-c", command);
            Process process = pb.start();

            // 1. 监控错误流 (mysqldump 的报错信息会输出在这里)
            new Thread(() -> {
                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        log.error("备份警告/错误: {}", line);
                    }
                } catch (IOException ignored) {}
            }).start();

            // 2. 等待备份进程结束并获取状态
            int exitCode = process.waitFor();
            
            if (exitCode == 0) {
                log.info("✅ 备份完成！文件路径: {}，文件大小: {} bytes", 
                         targetPath, new File(targetPath).length());
                return true;
            } else {
                log.error("❌ 备份失败，进程退出码: {}", exitCode);
            }
        } catch (Exception e) {
            log.error("执行备份脚本时发生异常", e);
        }
        return false;
    }
}
~~~

#### 2.2. 增量数据处理逻辑 (Java)

- 从云端获取 List<Map> 数据后，将其拼装为适配本地表结构的“插入或更新”脚本。

~~~java
import java.util.*;
import java.util.stream.Collectors;

public class IncrementalRecover {

    /**
     * @param cloudDataList 从云端查出的数据列表（包含 sn 字段）
     * @param tableName 本地表名
     */
    public String buildUpsertSql(List<Map<String, Object>> cloudDataList, String tableName) {
        if (cloudDataList == null || cloudDataList.isEmpty()) return "-- No incremental data";

        // 1. 定义本地表字段（排除云端特有的 sn 字段）
        List<String> localFields = Arrays.asList("id", "content", "create_time", "update_time");
        String columns = String.join(", ", localFields);

        StringBuilder sql = new StringBuilder();
        sql.append("INSERT INTO ").append(tableName).append(" (").append(columns).append(") VALUES \n");

        // 2. 迭代数据行
        for (int i = 0; i < cloudDataList.size(); i++) {
            Map<String, Object> row = cloudDataList.get(i);
            sql.append("(");
            String values = localFields.stream().map(field -> {
                Object val = row.get(field);
                if (val == null) return "NULL";
                return "'" + val.toString().replace("'", "''") + "'";
            }).collect(Collectors.joining(", "));

            sql.append(values).append(")").append(i == cloudDataList.size() - 1 ? "" : ",\n");
        }

        // 3. 核心冲突处理逻辑：最后写入者胜
        sql.append("\nON DUPLICATE KEY UPDATE \n")
                .append("content = IF(VALUES(update_time) > update_time, VALUES(content), content),\n")
                .append("update_time = IF(VALUES(update_time) > update_time, VALUES(update_time), update_time);");

        return sql.toString();
    }
}
~~~

### 3. 数据恢复 SOP (标准作业程序)

#### 3.1. 第一步：全量回滚

~~~shell
mysql -h mysql-container -u root -p'password' db_name < /path/to/full_backup.sql

# 注意：一定要带 -i 参数，表示接受标准输入流
gunzip < /path/to/backup.sql.gz | docker exec -i mysql-container mysql -u root -pznkj123456
~~~

#### 3.2. 第二步：增量同步

- req
~~~json
{
  "sn": "",
  "now": ""
}
~~~
- res
~~~sql
-- 查询出 创建时间 大于最后一次备份时间且小于现在的数据
select * from zn_dzg_member 
where create_time >= '2025-12-18 00:00:00' and create_time < now();
-- 查询出 创建时间 小于最后一次备份时间且 更新时间大于 最后一次备份时间且小于现在的数据
select * from zn_dzg_member 
where create_time < '2025-12-18 00:00:00'
      and (update_time >= '2025-12-18 00:00:00' and update_time < now());
~~~
~~~json
{
  "update": [
    {
      "table1": [
        {
          "id": "",
          "createTime": ""
        },
        {
          "id": "",
          "createTime": ""
        }
      ]
    }
  ],
  "insert": [
    {
      "table1": [
        {
          "id": "",
          "createTime": ""
        },
        {
          "id": "",
          "createTime": ""
        }
      ]
    }
  ]
}
~~~


1. 云端查询：根据本地设备的 sn 和 update_time > '2025-12-17 00:00:00' 提取记录。
2. 生成脚本：通过上述 Java 方法 buildUpsertSql 生成 SQL。
3. 执行合并：在本地数据库执行生成的 SQL 脚本。

#### 3.3. 第三步：校验

~~~sql
-- 检查是否有最新的记录进入
SELECT MAX(update_time) FROM your_table;
~~~

### 4. 可能问题

- Q: 增量恢复会覆盖已有的新数据吗？
    - A: 不会。SQL 中的 IF(VALUES(update_time) > update_time...) 确保了只有当增量包里的数据比数据库当前数据更新时，才会执行覆盖。

- Q: 为什么不用 REPLACE INTO？
    - A: REPLACE INTO 会先删除再插入，这会导致 create_time 丢失或触发不必要的索引重建，且无法进行时间戳比对。

- Q: 如何处理删除的数据？
    - A: 当前结构不支持物理删除还原。建议在表中增加 is_deleted 字段实现逻辑删除，这样删除操作也会作为一条“更新”记录被同步和恢复。

- Q: 时间必须正确

</span>