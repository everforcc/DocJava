<span  style="font-family: Simsun,serif; font-size: 17px; ">

# 方案5.1-binlog-connector-map版

## 1. 目标
- 在没有消息队列（Rabbit/Kafka）的前提下，先使用内存 `Map` 作为临时消息通道，快速验证 `mysql-binlog-connector-java` 的解析流程。
- 技术栈：Spring Boot、mysql-binlog-connector-java、MyBatis（org.mybatis.spring.boot:2.3.1）、Jackson JSON。
- 功能覆盖：Binlog 捕获、SQL 构建、消息暂存（Map）、持久化记录、后续恢复/重放。

## 2. 架构概览（Map 版）

```
┌──────────────────────────┐
│ BinlogConnectorListener  │
└────────────┬─────────────┘
             │ Event(DML/DDL)
             ▼
┌──────────────────────────┐
│ BinlogEventProcessor     │
└────────────┬─────────────┘
             │ BinlogMessage
             ▼
┌──────────────────────────┐
│ BinlogMessageBuffer(Map) │ ← 内存 Map：Key=设备/表，Value=消息队列List
└────────────┬─────────────┘
             │
             ▼
┌──────────────────────────┐
│ MessageStorageService    │ ← MyBatis + MySQL 持久化
└────────────┬─────────────┘
             │
┌──────────────────────────┐
│ SQL 重放/恢复服务        │
└──────────────────────────┘
```

## 3. 技术栈说明
- **Spring Boot**：容器、配置、生命周期管理。
- **mysql-binlog-connector-java**：原生 Binlog 监听。
- **MyBatis Spring Boot Starter 2.3.1**：持久化 `BinlogMessage`、恢复日志。
- **Jackson**：消息 JSON 序列化/反序列化。
- **Map 缓存**：用于替代 MQ，将消息暂存在内存，便于本地演示与单机测试。

## 4. 关键组件设计

### 4.1 BinlogConnectorListener

```java
@Component
public class BinlogConnectorListener {

    private final BinaryLogClient client;
    private final BinlogEventProcessor eventProcessor;

    public BinlogConnectorListener(MySQLConnectorProperties properties,
                                   BinlogEventProcessor eventProcessor) {
        this.eventProcessor = eventProcessor;
        this.client = new BinaryLogClient(
                properties.getHost(),
                properties.getPort(),
                properties.getUsername(),
                properties.getPassword());
        client.setServerId(properties.getServerId());
        client.setBinlogFilename(properties.getBinlogFilename());
        client.setBinlogPosition(properties.getBinlogPosition());
    }

    @PostConstruct
    public void start() {
        client.registerEventListener(event -> eventProcessor.process(event));
        CompletableFuture.runAsync(() -> {
            try {
                client.connect();
            } catch (IOException e) {
                log.error("Binlog connect failed", e);
            }
        });
    }
}
```

### 4.2 BinlogEventProcessor
（与 connector 方案类似，省略已展示的代码，可直接复用 `TableMetadataCache`、`SQLBuilderService` 等）

### 4.3 内存 Map 缓存

```java
@Component
public class BinlogMessageBuffer {

    private final Map<String, Deque<BinlogMessage>> buffer = new ConcurrentHashMap<>();
    private final int maxSizePerKey = 1000; // 单个 key 的最大缓存数量

    public void putMessage(String key, BinlogMessage message) {
        Deque<BinlogMessage> queue = buffer.computeIfAbsent(key, k -> new LinkedList<>());
        synchronized (queue) {
            queue.addLast(message);
            if (queue.size() > maxSizePerKey) {
                queue.removeFirst(); // 简单淘汰策略
            }
        }
    }

    public List<BinlogMessage> drainMessages(String key) {
        Deque<BinlogMessage> queue = buffer.get(key);
        if (queue == null) {
            return Collections.emptyList();
        }
        synchronized (queue) {
            List<BinlogMessage> list = new ArrayList<>(queue);
            queue.clear();
            return list;
        }
    }
}
```

### 4.4 消息发送器（Map 版）

```java
@Service
public class BinlogMessageSender {

    private final BinlogMessageBuffer buffer;
    private final MessageStorageService messageStorageService;

    public BinlogMessageSender(BinlogMessageBuffer buffer,
                               MessageStorageService messageStorageService) {
        this.buffer = buffer;
        this.messageStorageService = messageStorageService;
    }

    public void send(BinlogMessage message) {
        String key = message.getDatabase() + "." + message.getTable();
        buffer.putMessage(key, message);
        messageStorageService.store(message);
    }
}
```

### 4.5 MyBatis 持久化

#### 4.5.1 实体类

```java
@Data
public class BinlogMessageEntity {
    private Long id;
    private String database;
    private String table;
    private String sqlType;
    private String sqlListJson;
    private String binlogFile;
    private Long binlogPos;
    private Long timestamp;
    private LocalDateTime createdAt;
}
```

#### 4.5.2 Mapper (XML)

```xml
<mapper namespace="com.example.mapper.BinlogMessageMapper">
    <insert id="insert">
        INSERT INTO binlog_message (
            database_name,
            table_name,
            sql_type,
            sql_list_json,
            binlog_file,
            binlog_pos,
            event_time,
            created_at
        ) VALUES (
            #{database},
            #{table},
            #{sqlType},
            #{sqlListJson},
            #{binlogFile},
            #{binlogPos},
            #{timestamp},
            NOW()
        )
    </insert>

    <select id="selectByTimeRange" resultType="com.example.entity.BinlogMessageEntity">
        SELECT *
        FROM binlog_message
        WHERE database_name = #{database}
          AND table_name = #{table}
          AND event_time BETWEEN #{startTime} AND #{endTime}
        ORDER BY event_time ASC
    </select>
</mapper>
```

### 4.6 MessageStorageService

```java
@Service
public class MessageStorageService {

    private final BinlogMessageMapper mapper;
    private final ObjectMapper objectMapper;

    public void store(BinlogMessage message) {
        BinlogMessageEntity entity = new BinlogMessageEntity();
        entity.setDatabase(message.getDatabase());
        entity.setTable(message.getTable());
        entity.setSqlType(message.getSqlType());
        try {
            entity.setSqlListJson(objectMapper.writeValueAsString(message.getSqlList()));
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Serialize SQL list failed", e);
        }
        entity.setBinlogFile(message.getBinlogFile());
        entity.setBinlogPos(message.getBinlogPos());
        entity.setTimestamp(message.getTimestamp());
        mapper.insert(entity);
    }

    public List<BinlogMessage> loadMessages(String database, String table,
                                            long startTime, long endTime) {
        List<BinlogMessageEntity> entities =
                mapper.selectByTimeRange(database, table, startTime, endTime);

        return entities.stream().map(entity -> {
            BinlogMessage message = new BinlogMessage();
            message.setDatabase(entity.getDatabase());
            message.setTable(entity.getTable());
            message.setSqlType(entity.getSqlType());
            try {
                message.setSqlList(objectMapper.readValue(
                        entity.getSqlListJson(), new TypeReference<List<String>>() {}));
            } catch (JsonProcessingException e) {
                throw new RuntimeException("Deserialize SQL list failed", e);
            }
            message.setBinlogFile(entity.getBinlogFile());
            message.setBinlogPos(entity.getBinlogPos());
            message.setTimestamp(entity.getTimestamp());
            return message;
        }).collect(Collectors.toList());
    }
}
```

## 5. 数据恢复（Map 版）
- 通过 `BinlogMessageBuffer.drainMessages(key)` 获取最近消息；或从 `MessageStorageService` 查询历史消息。
- 恢复流程与 SQL 重放同 Canal 原方案一致：按时间/位点顺序执行 `sqlList`，支持全量+增量。
- 可先在本地/测试环境通过 Map 验证流程，再替换成消息队列。

## 6. POM 关键依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>

    <dependency>
        <groupId>com.github.shyiko</groupId>
        <artifactId>mysql-binlog-connector-java</artifactId>
        <version>0.28.6</version>
    </dependency>

    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.3.1</version>
    </dependency>

    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <version>8.3.0</version>
    </dependency>

    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.16.1</version>
    </dependency>
</dependencies>
```

## 7. 优点与后续演进
- **优点**：无需搭建 MQ 即可完成 Binlog → SQL → 存储 → 恢复 的闭环，便于本地调试、PoC 验证。
- **局限**：Map 通道仅适合单机/测试，无法跨节点、易丢失；应尽快替换为 MQ。
- **演进**：当流程验证完成后，只需将 `BinlogMessageSender` 改成 MQ 实现，`BinlogMessageBuffer` 改成 MQ 消费端即可。

</span>

