<span  style="font-family: Simsun,serif; font-size: 17px; ">

# 方案5.1-binlog-connector方案

## 1. 目标
- 在不依赖 Canal 的前提下，使用 `mysql-binlog-connector-java` 原生解析器实现 Binlog 捕获、SQL 重放与数据恢复。
- 覆盖 DML/DDL 事件解析、完整 SQL 构建、消息队列传输、持久化与恢复流程。

## 2. 技术栈
- `mysql-binlog-connector-java`：直接监听 MySQL Binlog
- Spring Boot / Spring Cloud（可选）
- RabbitMQ / Kafka（消息队列）
- MySQL / TiDB / 分布式存储
- JSON (Jackson/Fastjson) 持久化消息

## 3. 架构概览

```
┌──────────────────────────┐
│ BinlogConnectorListener  │  ← mysql-binlog-connector-java
└────────────┬─────────────┘
             │ Event(DML/DDL)
             ▼
┌──────────────────────────┐
│ BinlogEventProcessor     │  ← 构建 SQL、封装 BinlogMessage
└────────────┬─────────────┘
             │ BinlogMessage
             ▼
┌──────────────────────────┐
│ BinlogMessageSender      │  ← RabbitMQ/Kafka
└────────────┬─────────────┘
             │ 消息持久化
             ▼
┌──────────────────────────┐
│ MessageStorageService    │  ← DB/ES/对象存储
└────────────┬─────────────┘
             │
┌──────────────────────────┐ ┌──────────────────────────┐
│ SQL 重放/恢复服务        │ │ 数据一致性校验/闭环      │
└──────────────────────────┘ └──────────────────────────┘
```

## 4. Binlog 监听实现

```java
@Component
public class BinlogConnectorListener {

    private final BinaryLogClient client;
    private final BinlogEventProcessor eventProcessor;

    public BinlogConnectorListener(
            MySQLConnectorProperties properties,
            BinlogEventProcessor eventProcessor) {
        this.eventProcessor = eventProcessor;
        this.client = new BinaryLogClient(
                properties.getHost(),
                properties.getPort(),
                properties.getUsername(),
                properties.getPassword());

        // 指定监听的 serverId
        client.setServerId(properties.getServerId());
        // 设置要监听的数据库/表
        client.setBinlogFilename(properties.getBinlogFilename());
        client.setBinlogPosition(properties.getBinlogPosition());
    }

    @PostConstruct
    public void start() {
        // 监听连接事件
        client.registerEventListener(event -> eventProcessor.process(event));
        Executors.newSingleThreadExecutor().submit(() -> {
            try {
                client.connect();
            } catch (IOException e) {
                log.error("Failed to connect binlog", e);
            }
        });
    }
}
```

### 4.1 支持的事件类型
- `UpdateRowsEventData`
- `WriteRowsEventData`
- `DeleteRowsEventData`
- `TableMapEventData`
- `QueryEventData`（DDL、事务控制）
- `RotateEventData`（binlog 文件轮转）

## 5. 事件处理与 SQL 构建

```java
@Component
public class BinlogEventProcessor {

    private final SQLBuilderService sqlBuilderService;
    private final BinlogMessageSender messageSender;
    private final TableMetadataCache metadataCache;

    public void process(Event event) {
        EventData data = event.getData();

        if (data instanceof TableMapEventData) {
            metadataCache.update((TableMapEventData) data);
            return;
        }

        if (data instanceof WriteRowsEventData) {
            handleWrite(event, (WriteRowsEventData) data);
        } else if (data instanceof UpdateRowsEventData) {
            handleUpdate(event, (UpdateRowsEventData) data);
        } else if (data instanceof DeleteRowsEventData) {
            handleDelete(event, (DeleteRowsEventData) data);
        } else if (data instanceof QueryEventData) {
            handleQuery(event, (QueryEventData) data);
        }
    }

    private void handleWrite(Event event, WriteRowsEventData data) {
        TableInfo table = metadataCache.getTableInfo(data.getTableId());
        List<String> sqlList = sqlBuilderService.buildInsertSQL(table, data);
        sendMessage(event, table, "INSERT", sqlList);
    }

    private void handleUpdate(Event event, UpdateRowsEventData data) {
        TableInfo table = metadataCache.getTableInfo(data.getTableId());
        List<String> sqlList = sqlBuilderService.buildUpdateSQL(table, data);
        sendMessage(event, table, "UPDATE", sqlList);
    }

    private void handleDelete(Event event, DeleteRowsEventData data) {
        TableInfo table = metadataCache.getTableInfo(data.getTableId());
        List<String> sqlList = sqlBuilderService.buildDeleteSQL(table, data);
        sendMessage(event, table, "DELETE", sqlList);
    }

    private void handleQuery(Event event, QueryEventData data) {
        if ("BEGIN".equalsIgnoreCase(data.getSql())
                || "COMMIT".equalsIgnoreCase(data.getSql())) {
            return;
        }
        TableInfo table = new TableInfo();
        table.setDatabase(data.getDatabase());
        // QueryEventData 的 SQL 已经是完整 DDL/DML
        sendMessage(event, table, "QUERY", Collections.singletonList(data.getSql()));
    }

    private void sendMessage(Event event, TableInfo table, String type, List<String> sqlList) {
        BinlogMessage message = new BinlogMessage();
        message.setDatabase(table.getDatabase());
        message.setTable(table.getTableName());
        message.setSqlType(type);
        message.setSqlList(sqlList);

        EventHeaderV4 header = (EventHeaderV4) event.getHeader();
        message.setBinlogFile(metadataCache.getCurrentBinlogFile());
        message.setBinlogPos(header.getNextPosition());
        message.setTimestamp(header.getTimestamp());

        messageSender.send(message);
    }
}
```

### 5.1 表元数据缓存

```java
@Component
public class TableMetadataCache {

    private final Map<Long, TableInfo> tableIdMap = new ConcurrentHashMap<>();
    private final Map<String, List<String>> primaryKeyCache = new ConcurrentHashMap<>();
    private volatile String currentBinlogFile;

    public void update(TableMapEventData data) {
        TableInfo tableInfo = new TableInfo();
        tableInfo.setTableId(data.getTableId());
        tableInfo.setDatabase(data.getDatabase());
        tableInfo.setTableName(data.getTable());
        tableInfo.setColumnTypes(data.getColumnTypes());
        tableInfo.setColumnMetadata(data.getColumnMetadata());
        tableInfo.setNullBitmap(data.getColumnNullability());
        tableIdMap.put(data.getTableId(), tableInfo);
    }

    public TableInfo getTableInfo(long tableId) {
        return tableIdMap.get(tableId);
    }

    public List<String> getPrimaryKeys(String database, String table) {
        return primaryKeyCache.computeIfAbsent(database + "." + table,
                key -> fetchPrimaryKeysFromInformationSchema(database, table));
    }

    private List<String> fetchPrimaryKeysFromInformationSchema(String database, String table) {
        // 连接主库或只读实例，查询 information_schema
        String sql = "SELECT COLUMN_NAME FROM information_schema.COLUMNS "
                   + "WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ? AND COLUMN_KEY = 'PRI'";
        return jdbcTemplate.query(sql, new Object[]{database, table},
            (rs, rowNum) -> rs.getString("COLUMN_NAME"));
    }

    public void setCurrentBinlogFile(String binlogFile) {
        this.currentBinlogFile = binlogFile;
    }

    public String getCurrentBinlogFile() {
        return currentBinlogFile;
    }
}
```

## 6. SQLBuilderService（适配 Binlog Connector）

```java
@Service
public class SQLBuilderService {

    public List<String> buildInsertSQL(TableInfo table, WriteRowsEventData data) {
        List<String> sqlList = new ArrayList<>();
        for (Serializable[] row : data.getRows()) {
            sqlList.add(buildInsert(table, row));
        }
        return sqlList;
    }

    private String buildInsert(TableInfo table, Serializable[] row) {
        List<String> columns = new ArrayList<>();
        List<String> values = new ArrayList<>();

        for (int i = 0; i < table.getColumnTypes().length; i++) {
            columns.add(escapeColumn(table.getColumnName(i)));
            values.add(formatValue(row[i], table.getColumnTypes()[i]));
        }

        return String.format("INSERT INTO `%s`.`%s` (%s) VALUES (%s);",
                table.getDatabase(),
                table.getTableName(),
                String.join(", ", columns),
                String.join(", ", values));
    }

    public List<String> buildUpdateSQL(TableInfo table, UpdateRowsEventData data) {
        List<String> sqlList = new ArrayList<>();
        List<String> primaryKeys = table.getPrimaryKeys();

        for (Map.Entry<Serializable[], Serializable[]> row : data.getRows()) {
            sqlList.add(buildUpdate(table, row.getKey(), row.getValue(), primaryKeys));
        }
        return sqlList;
    }

    private String buildUpdate(TableInfo table, Serializable[] before, Serializable[] after, List<String> primaryKeys) {
        List<String> setClauses = new ArrayList<>();
        List<String> whereClauses = new ArrayList<>();

        for (int i = 0; i < table.getColumnTypes().length; i++) {
            String columnName = table.getColumnName(i);
            if (!Objects.equals(before[i], after[i])) {
                setClauses.add(String.format("%s = %s",
                        escapeColumn(columnName),
                        formatValue(after[i], table.getColumnTypes()[i])));
            }

            if (primaryKeys.contains(columnName)) {
                whereClauses.add(String.format("%s = %s",
                        escapeColumn(columnName),
                        formatValue(before[i], table.getColumnTypes()[i])));
            }
        }

        if (whereClauses.isEmpty()) {
            for (int i = 0; i < table.getColumnTypes().length; i++) {
                whereClauses.add(String.format("%s = %s",
                        escapeColumn(table.getColumnName(i)),
                        formatValue(before[i], table.getColumnTypes()[i])));
            }
        }

        return String.format("UPDATE `%s`.`%s` SET %s WHERE %s;",
                table.getDatabase(),
                table.getTableName(),
                String.join(", ", setClauses),
                String.join(" AND ", whereClauses));
    }

    public List<String> buildDeleteSQL(TableInfo table, DeleteRowsEventData data) {
        List<String> sqlList = new ArrayList<>();
        List<String> primaryKeys = table.getPrimaryKeys();

        for (Serializable[] row : data.getRows()) {
            sqlList.add(buildDelete(table, row, primaryKeys));
        }
        return sqlList;
    }

    private String buildDelete(TableInfo table, Serializable[] row, List<String> primaryKeys) {
        List<String> whereClauses = new ArrayList<>();

        for (int i = 0; i < table.getColumnTypes().length; i++) {
            String columnName = table.getColumnName(i);
            if (primaryKeys.contains(columnName)) {
                whereClauses.add(String.format("%s = %s",
                        escapeColumn(columnName),
                        formatValue(row[i], table.getColumnTypes()[i])));
            }
        }

        if (whereClauses.isEmpty()) {
            for (int i = 0; i < table.getColumnTypes().length; i++) {
                whereClauses.add(String.format("%s = %s",
                        escapeColumn(table.getColumnName(i)),
                        formatValue(row[i], table.getColumnTypes()[i])));
            }
        }

        return String.format("DELETE FROM `%s`.`%s` WHERE %s;",
                table.getDatabase(),
                table.getTableName(),
                String.join(" AND ", whereClauses));
    }

    private String escapeColumn(String columnName) {
        return "`" + columnName + "`";
    }

    private String formatValue(Serializable value, int columnType) {
        // 根据 mysql-binlog-connector 的 ColumnType 枚举格式化
        // 可参考 com.github.shyiko.mysql.binarylog.io.ColumnType
        if (value == null) {
            return "NULL";
        }
        switch (ColumnType.byCode(columnType)) {
            case MYSQL_TYPE_VARCHAR:
            case MYSQL_TYPE_VAR_STRING:
            case MYSQL_TYPE_STRING:
            case MYSQL_TYPE_BLOB:
            case MYSQL_TYPE_LONG_BLOB:
            case MYSQL_TYPE_MEDIUM_BLOB:
            case MYSQL_TYPE_TINY_BLOB:
                return "'" + escapeString(value.toString()) + "'";
            case MYSQL_TYPE_DATE:
            case MYSQL_TYPE_DATETIME:
            case MYSQL_TYPE_TIMESTAMP:
                return "'" + value.toString() + "'";
            default:
                return value.toString();
        }
    }

    private String escapeString(String value) {
        return value.replace("\\", "\\\\")
                   .replace("'", "\\'")
                   .replace("\"", "\\\"")
                   .replace("\n", "\\n")
                   .replace("\r", "\\r")
                   .replace("\t", "\\t");
    }
}
```

## 7. BinlogMessage 结构
```java
@Data
public class BinlogMessage implements Serializable {
    private String database;
    private String table;
    private String sqlType;              // INSERT / UPDATE / DELETE / QUERY
    private List<String> sqlList;
    private String binlogFile;
    private Long binlogPos;
    private Long timestamp;
    private String schemaVersion;        // 可选：表结构版本
    private Map<String, Object> extra;   // 业务扩展字段
}
```

## 8. 消息发送与持久化

```java
@Service
public class BinlogMessageSender {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private MessageStorageService messageStorageService;

    public void send(BinlogMessage message) {
        String routingKey = "binlog." + message.getDatabase() + "." + message.getTable();
        rabbitTemplate.convertAndSend("binlog.exchange", routingKey, message);
        messageStorageService.store(message);
    }
}
```

## 9. 数据恢复流程（同 Canal 方案）
- 恢复到指定时间点/事务/位点
- 全量 + 增量重放
- 消息持久化查询
- SQL 批量执行（事务控制）

## 10. 优势与注意事项
### 优势
- 直接监听 Binlog，无需 Canal，减少依赖
- 支持较新的 Binlog 功能，控制更灵活
- 可针对多实例、多表精细控制

### 注意事项
- 需要维护表结构缓存（TableMapEventData + information_schema）
- Binlog 事件格式随 MySQL 版本变化，需要兼容
- 对于大事务、批量操作，需要考虑内存和吞吐

## 11. 集群与容错
- 多实例监听：每个实例使用不同 serverId，监听相同 Binlog
- 断点续传：记录 binlogFile/binlogPos，异常重连时恢复
- 容灾：Binlog Connector 支持 rotate 事件，需及时更新文件名

</span>

