<span  style="font-family: Simsun,serif; font-size: 17px; ">

## 方案3：物理设备无固定IP但需要写入的备份方案

### 环境特点
- 云服务器：有固定公网IP，可稳定访问
- 物理设备：无固定IP（动态IP或内网IP），可能频繁变化
- **关键需求**：物理设备上的程序需要写入物理设备的MySQL
- 挑战：物理设备必须作为主库，但云服务器无法主动连接物理设备

### 架构设计

#### 核心思路
- **物理设备作为主库**：处理业务写入
- **云服务器作为从库**：通过反向连接或代理方式接收binlog
- **动态IP处理**：使用反向隧道、动态DNS或中间代理

### 方案3.1：反向SSH隧道 + 主从复制（推荐）

#### 架构拓扑
```
物理设备 (Master) ──SSH隧道──> 云服务器 (Slave)
     ↑                              ↓
  业务写入                      数据备份
```

#### 1. 建立SSH反向隧道

**在物理设备上配置**：
```bash
#!/bin/bash
# 建立SSH反向隧道脚本 ssh_tunnel.sh

CLOUD_IP="云服务器固定IP"
CLOUD_USER="ssh_user"
SSH_KEY="/path/to/ssh_key"
LOCAL_MYSQL_PORT=3306
REMOTE_MYSQL_PORT=13306  # 云服务器上的转发端口

# 建立反向隧道（将云服务器的13306端口转发到物理设备的3306）
ssh -i $SSH_KEY \
  -N -f \
  -R ${REMOTE_MYSQL_PORT}:localhost:${LOCAL_MYSQL_PORT} \
  -o ServerAliveInterval=60 \
  -o ServerAliveCountMax=3 \
  -o ExitOnForwardFailure=yes \
  $CLOUD_USER@$CLOUD_IP

echo "SSH tunnel established"
```

**配置为系统服务**：
```ini
# /etc/systemd/system/mysql-tunnel.service
[Unit]
Description=MySQL SSH Reverse Tunnel
After=network.target mysql.service

[Service]
Type=simple
ExecStart=/path/to/ssh_tunnel.sh
Restart=always
RestartSec=10
User=root

[Install]
WantedBy=multi-user.target
```

**启动服务**：
```bash
systemctl enable mysql-tunnel
systemctl start mysql-tunnel
```

#### 2. 云服务器配置（从库）

**MySQL 配置**：
```ini
# /etc/my.cnf
[mysqld]
server-id = 2
relay-log = mysql-relay-bin
read-only = 1
replicate-do-db = your_database
```

**建立主从关系（连接本地转发端口）**：
```sql
-- 云服务器连接本地13306端口（通过SSH隧道转发到物理设备）
CHANGE MASTER TO
  MASTER_HOST='127.0.0.1',  -- 本地转发端口
  MASTER_PORT=13306,
  MASTER_USER='repl',
  MASTER_PASSWORD='repl_password',
  MASTER_LOG_FILE='mysql-bin.000001',
  MASTER_LOG_POS=154;

START SLAVE;

-- 查看从库状态
SHOW SLAVE STATUS\G
```

#### 3. 物理设备配置（主库）

**MySQL 配置**：
```ini
# /etc/my.cnf
[mysqld]
server-id = 1  # 每台设备唯一ID
log-bin = mysql-bin
binlog-format = ROW
binlog-do-db = your_database
expire_logs_days = 7
max_binlog_size = 100M
```

**创建复制用户**：
```sql
-- 允许从127.0.0.1连接（通过SSH隧道）
CREATE USER 'repl'@'127.0.0.1' IDENTIFIED BY 'repl_password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'127.0.0.1';
FLUSH PRIVILEGES;

-- 查看主库状态
SHOW MASTER STATUS;
```

#### 4. 自动重连脚本

```bash
#!/bin/bash
# SSH隧道自动重连脚本 tunnel_reconnect.sh

CLOUD_IP="云服务器固定IP"
CLOUD_USER="ssh_user"
SSH_KEY="/path/to/ssh_key"
REMOTE_PORT=13306

check_tunnel() {
  # 检查SSH隧道是否存活
  ssh -i $SSH_KEY -O check $CLOUD_USER@$CLOUD_IP 2>&1 | grep -q "Master running"
  return $?
}

establish_tunnel() {
  ssh -i $SSH_KEY \
    -N -f \
    -R ${REMOTE_PORT}:localhost:3306 \
    -o ServerAliveInterval=60 \
    -o ServerAliveCountMax=3 \
    -o ExitOnForwardFailure=yes \
    -o StrictHostKeyChecking=no \
    $CLOUD_USER@$CLOUD_IP
}

# 主循环
while true; do
  if ! check_tunnel; then
    echo "$(date): Tunnel broken, reconnecting..."
    # 清理旧连接
    ssh -i $SSH_KEY -O exit $CLOUD_USER@$CLOUD_IP 2>/dev/null
    sleep 5
    # 建立新连接
    establish_tunnel
    sleep 10
  else
    echo "$(date): Tunnel is alive"
  fi
  sleep 60
done
```

### 方案3.2：动态DNS + 主从复制

#### 1. 配置动态DNS

**使用DDNS服务（如DuckDNS、No-IP）**：

```bash
#!/bin/bash
# 动态DNS更新脚本 update_ddns.sh

DDNS_DOMAIN="your-device.duckdns.org"
DDNS_TOKEN="your_token"

# 获取当前公网IP
CURRENT_IP=$(curl -s https://api.ipify.org)

# 更新DDNS
curl -s "https://www.duckdns.org/update?domains=$DDNS_DOMAIN&token=$DDNS_TOKEN&ip=$CURRENT_IP"

echo "DDNS updated: $DDNS_DOMAIN -> $CURRENT_IP"
```

**定时更新**：
```bash
# crontab -e
# 每5分钟更新一次
*/5 * * * * /path/to/update_ddns.sh >> /var/log/ddns.log 2>&1
```

#### 2. 云服务器配置从库

```sql
-- 使用动态域名连接物理设备
CHANGE MASTER TO
  MASTER_HOST='your-device.duckdns.org',  -- 动态域名
  MASTER_PORT=3306,
  MASTER_USER='repl',
  MASTER_PASSWORD='repl_password',
  MASTER_LOG_FILE='mysql-bin.000001',
  MASTER_LOG_POS=154,
  MASTER_CONNECT_RETRY=10,
  MASTER_RETRY_COUNT=60;

START SLAVE;
```

#### 3. 自动重连脚本（云服务器端）

```bash
#!/bin/bash
# 从库自动重连脚本 slave_reconnect.sh

DDNS_DOMAIN="your-device.duckdns.org"
MYSQL_USER="root"
MYSQL_PASS="password"

check_slave() {
  STATUS=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -e "SHOW SLAVE STATUS\G" 2>/dev/null | \
    grep -E "Slave_IO_Running|Slave_SQL_Running" | awk '{print $2}')
  
  IO_RUNNING=$(echo $STATUS | awk '{print $1}')
  SQL_RUNNING=$(echo $STATUS | awk '{print $2}')
  
  if [ "$IO_RUNNING" != "Yes" ] || [ "$SQL_RUNNING" != "Yes" ]; then
    return 1
  fi
  return 0
}

reconnect_slave() {
  # 获取主库最新binlog位置（通过其他方式，如API或文件）
  # 这里简化处理，实际需要从物理设备获取
  mysql -u$MYSQL_USER -p$MYSQL_PASS <<EOF
  STOP SLAVE;
  CHANGE MASTER TO
    MASTER_HOST='$DDNS_DOMAIN',
    MASTER_PORT=3306,
    MASTER_USER='repl',
    MASTER_PASSWORD='repl_password',
    MASTER_LOG_FILE='最新binlog文件',
    MASTER_LOG_POS=最新binlog位置;
  START SLAVE;
EOF
}

# 主循环
while true; do
  if ! check_slave; then
    echo "$(date): Slave not running, reconnecting..."
    reconnect_slave
  fi
  sleep 60
done
```

### 方案3.3：中间代理服务器方案

#### 架构拓扑
```
物理设备 (Master) ──> 云服务器代理 ──> 云服务器从库
     ↑                      ↓
  业务写入              数据备份
```

#### 1. 在云服务器上部署代理

**使用 MySQL Proxy 或 ProxySQL**：

```bash
# 安装 ProxySQL
# 配置代理，监听3307端口，转发到物理设备
```

**ProxySQL 配置示例**：
```sql
-- 添加物理设备作为后端（通过动态域名或SSH隧道）
INSERT INTO mysql_servers(hostgroup_id, hostname, port, weight) 
VALUES (0, 'your-device.duckdns.org', 3306, 1000);

-- 配置查询规则
INSERT INTO mysql_query_rules(rule_id, active, match_pattern, destination_hostgroup) 
VALUES (1, 1, '^SELECT', 0);

-- 加载配置
LOAD MYSQL SERVERS TO RUNTIME;
SAVE MYSQL SERVERS TO DISK;
```

#### 2. 云服务器从库连接代理

```sql
-- 从库连接本地代理
CHANGE MASTER TO
  MASTER_HOST='127.0.0.1',
  MASTER_PORT=3307,  -- 代理端口
  MASTER_USER='repl',
  MASTER_PASSWORD='repl_password',
  MASTER_LOG_FILE='mysql-bin.000001',
  MASTER_LOG_POS=154;

START SLAVE;
```

### 方案3.4：定时同步 + 双写模式（备选）

如果主从复制不可行，使用定时同步 + 应用层双写：

#### 1. 应用层双写

```java
// Java示例：双写模式
@Service
public class DataSyncService {
    
    @Autowired
    private PhysicalDeviceMapper physicalMapper;
    
    @Autowired
    private CloudServerMapper cloudMapper;
    
    @Transactional
    public void saveData(DataEntity entity) {
        // 先写物理设备（主库）
        physicalMapper.insert(entity);
        
        // 异步写云服务器（备份）
        CompletableFuture.runAsync(() -> {
            try {
                cloudMapper.insert(entity);
            } catch (Exception e) {
                // 记录失败，后续补偿
                log.error("Cloud write failed", e);
            }
        });
    }
}
```

#### 2. 定时全量同步

```bash
#!/bin/bash
# 定时全量同步脚本 full_sync.sh

CLOUD_IP="云服务器固定IP"
DB_NAME="your_database"
MYSQL_USER="backup_user"
MYSQL_PASS="backup_password"

# 物理设备导出
mysqldump -u$MYSQL_USER -p$MYSQL_PASS \
  --single-transaction \
  --routines \
  --triggers \
  --events \
  $DB_NAME | gzip > /tmp/backup_$(date +%Y%m%d_%H%M%S).sql.gz

# 上传到云服务器
scp /tmp/backup_*.sql.gz user@$CLOUD_IP:/backup/mysql/

# 云服务器导入（在云服务器上执行）
# gunzip -c backup_*.sql.gz | mysql -u root -p $DB_NAME
```

### 方案3.5：GTID + 半同步复制（高级）

使用MySQL GTID和半同步复制提高可靠性：

#### 1. 物理设备配置（主库）

```ini
# /etc/my.cnf
[mysqld]
server-id = 1
log-bin = mysql-bin
binlog-format = ROW
gtid-mode = ON
enforce-gtid-consistency = ON
# 半同步复制
plugin-load = "rpl_semi_sync_master=semisync_master.so"
rpl_semi_sync_master_enabled = 1
rpl_semi_sync_master_timeout = 1000
```

#### 2. 云服务器配置（从库）

```ini
# /etc/my.cnf
[mysqld]
server-id = 2
relay-log = mysql-relay-bin
read-only = 1
gtid-mode = ON
enforce-gtid-consistency = ON
# 半同步复制
plugin-load = "rpl_semi_sync_slave=semisync_slave.so"
rpl_semi_sync_slave_enabled = 1
```

#### 3. 建立GTID主从

```sql
-- 在从库执行
CHANGE MASTER TO
  MASTER_HOST='通过SSH隧道或动态DNS',
  MASTER_USER='repl',
  MASTER_PASSWORD='repl_password',
  MASTER_AUTO_POSITION=1;  -- 使用GTID自动定位

START SLAVE;
```

### 监控与告警

#### 1. SSH隧道监控

```bash
#!/bin/bash
# 监控SSH隧道状态

CLOUD_IP="云服务器固定IP"
CLOUD_USER="ssh_user"

if ! ssh -O check $CLOUD_USER@$CLOUD_IP 2>&1 | grep -q "Master running"; then
  echo "ALERT: SSH tunnel is down!"
  # 发送告警
  # 自动重连
  /path/to/tunnel_reconnect.sh
fi
```

#### 2. 主从同步监控

```bash
#!/bin/bash
# 监控主从同步状态（云服务器端）

MYSQL_USER="monitor"
MYSQL_PASS="monitor_pass"
ALERT_LAG=300

LAG=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -e "SHOW SLAVE STATUS\G" | \
  grep "Seconds_Behind_Master" | awk '{print $2}')

if [ "$LAG" = "NULL" ] || [ -z "$LAG" ]; then
  echo "ERROR: Replication is broken!"
elif [ "$LAG" -gt "$ALERT_LAG" ]; then
  echo "WARNING: Replication lag is $LAG seconds"
fi
```

### 恢复方案

#### 物理设备故障恢复

```bash
#!/bin/bash
# 从云服务器恢复数据到物理设备

CLOUD_IP="云服务器固定IP"
BACKUP_DATE=$1
DB_NAME="your_database"
MYSQL_USER="root"
MYSQL_PASS="password"

# 从云服务器下载最新备份
scp user@$CLOUD_IP:/backup/mysql/$BACKUP_DATE/full_backup_$BACKUP_DATE.sql.gz /tmp/

# 恢复数据
gunzip -c /tmp/full_backup_$BACKUP_DATE.sql.gz | \
  mysql -u$MYSQL_USER -p$MYSQL_PASS $DB_NAME

# 重新建立SSH隧道和主从关系
systemctl restart mysql-tunnel
sleep 10

# 重新配置主从
mysql -u$MYSQL_USER -p$MYSQL_PASS <<EOF
STOP SLAVE;
RESET SLAVE ALL;
-- 从云服务器获取最新binlog位置并配置
CHANGE MASTER TO ...;
START SLAVE;
EOF
```

### 方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 3.1 SSH隧道 | 稳定、安全、不依赖外部服务 | 需要SSH访问权限 | **推荐**，有SSH权限 |
| 3.2 动态DNS | 简单、无需SSH | 依赖DDNS服务、可能有延迟 | 无SSH权限，可配置DDNS |
| 3.3 中间代理 | 灵活、可扩展 | 配置复杂、需要额外资源 | 多设备、需要统一管理 |
| 3.4 定时同步 | 不依赖网络连接 | 有延迟、可能丢失数据 | 网络极不稳定 |
| 3.5 GTID+半同步 | 高可靠性、自动恢复 | 配置复杂、性能略低 | 对数据一致性要求极高 |

### 推荐方案

**首选**：方案3.1（SSH反向隧道 + 主从复制）
- 物理设备主动建立SSH隧道
- 云服务器通过隧道连接物理设备MySQL
- 稳定可靠，不依赖外部服务
- 配置自动重连机制应对网络波动

**实施步骤**：
1. 在物理设备配置SSH密钥认证
2. 建立SSH反向隧道服务
3. 配置MySQL主从复制（通过隧道）
4. 部署监控和自动重连脚本
5. 测试故障恢复流程

### 注意事项

1. **SSH安全**：
   - 使用密钥认证，禁用密码登录
   - 限制SSH用户权限
   - 定期更换密钥

2. **网络稳定性**：
   - 配置自动重连机制
   - 监控隧道状态
   - 设置合理的超时时间

3. **数据一致性**：
   - 使用GTID确保数据一致性
   - 定期检查主从数据一致性
   - 配置半同步复制（可选）

4. **性能考虑**：
   - SSH隧道会有一定性能开销
   - 监控网络延迟
   - 考虑压缩传输（SSH -C）

5. **故障处理**：
   - 物理设备故障时，云服务器数据完整
   - 物理设备恢复后，从云服务器同步最新数据
   - 建立完整的恢复流程文档

</span>

