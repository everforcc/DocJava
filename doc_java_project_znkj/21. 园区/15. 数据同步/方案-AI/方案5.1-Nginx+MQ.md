<span  style="font-family: Simsun,serif; font-size: 17px; ">

# 方案5.1-Nginx+消息队列接入（独立版）

## 1. 场景概述
- 适用于超大规模设备场景（1000+），设备无固定 IP，需要将本地 MySQL Binlog 实时推送到云端。
- 设备通过 HTTP/HTTPS 报文推送 Binlog 片段或实时变更事件。
- 云端通过 `Nginx`（7 层网关）接入，统一鉴权、限流、灰度，后端使用 `Sync Agent` 写入消息队列（RabbitMQ/Kafka）。
- 下游数据同步服务从 MQ 消费后写入 MySQL 分片集群。

## 2. 流程说明
```
物理设备 → HTTPS 请求 → Nginx 网关 → Sync Agent → MQ（RabbitMQ/Kafka）
                                     ↘  本地补偿日志
MQ → 数据同步服务 → MySQL 分片/对象存储
```

## 3. Nginx 网关配置

```nginx
upstream sync_agent_pool {
    server sync-agent-1:9090 weight=5 max_fails=3 fail_timeout=30s;
    server sync-agent-2:9090 weight=5 max_fails=3 fail_timeout=30s;
}

server {
    listen 443 ssl;
    server_name sync-gateway.example.com;

    ssl_certificate     /etc/nginx/certs/server.crt;
    ssl_certificate_key /etc/nginx/certs/server.key;

    # 设备级限流
    limit_req_zone $binary_remote_addr zone=per_device:10m rate=100r/s;

    location /binlog/push {
        limit_req zone=per_device burst=50 nodelay;
        proxy_set_header X-Device-Id $http_x_device_id;
        proxy_set_header X-Real-IP   $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://sync_agent_pool;
    }
}
```

## 4. Sync Agent 职责
1. **接入校验**
   - 校验请求签名、版本号、时间戳，防止重放。
   - 校验设备状态、路由策略（可灰度控制）。
2. **Binlog 处理**
   - 支持多种编码（JSON/Protobuf/GZIP）。
   - 将 Binlog 流切片为固定大小 chunk（如 512KB），附带 `deviceId`、`transactionId`、`binlogFile`、`binlogPos` 等元数据。
3. **异步写入 MQ**
   - 使用异步队列写 MQ，失败时写本地补偿日志，定时重试。
4. **监控与告警**
   - 统计每台设备的推送速率、延迟。
   - 超过阈值时触发回调或告警。

## 5. 消息体示例
```json
{
  "deviceId": "DEVICE_01025",
  "binlogFile": "mysql-bin.000123",
  "binlogPos": 456789123,
  "transactionId": "TX_20250312_102030",
  "payload": "BASE64_ENCODED_BINLOG_CHUNK",
  "checksum": "18f0b1e2f9c7...",
  "timestamp": 1741867200000
}
```

## 6. Java Binlog 捕获实现（Canal 客户端示例）

### 6.1 部署建议
1. 在物理设备或边缘节点部署轻量 Canal Server，连接本地 MySQL。
2. 也可集中部署 Canal Server，通过 SSH 隧道/Proxy 访问主库。

### 6.2 客户端核心流程
```java
public class CanalBinlogClient {

    private final CanalConnector connector;
    private final RabbitTemplate rabbitTemplate;

    public CanalBinlogClient(String host, int port, String destination,
                             RabbitTemplate rabbitTemplate) {
        this.connector = CanalConnectors.newSingleConnector(
                new InetSocketAddress(host, port),
                destination,
                "",
                "");
        this.rabbitTemplate = rabbitTemplate;
    }

    public void start() {
        connector.connect();
        connector.subscribe("your_database\\..*");
        connector.rollback();
        while (true) {
            Message message = connector.getWithoutAck(1024);
            long batchId = message.getId();
            if (batchId == -1 || message.getEntries().isEmpty()) {
                sleepQuietly(500);
                continue;
            }
            try {
                processEntries(message.getEntries());
                connector.ack(batchId);
            } catch (Exception e) {
                connector.rollback(batchId);
            }
        }
    }

    private void processEntries(List<Entry> entries) throws Exception {
        for (Entry entry : entries) {
            if (entry.getEntryType() != EntryType.ROWDATA) {
                continue;
            }
            RowChange rowChange = RowChange.parseFrom(entry.getStoreValue());
            DataChangeEvent event = toEvent(entry.getHeader(), rowChange);
            rabbitTemplate.convertAndSend(
                    "device.data.changes",
                    "device." + event.getDeviceId(),
                    event);
        }
    }

    private DataChangeEvent toEvent(Header header, RowChange rowChange) {
        DataChangeEvent event = new DataChangeEvent();
        event.setDeviceId(header.getServerName()); // 可改为设备 ID
        event.setDatabase(header.getSchemaName());
        event.setTable(header.getTableName());
        event.setEventType(rowChange.getEventType().name());
        event.setExecuteTime(header.getExecuteTime());
        event.setRows(rowChange.getRowDatasList());
        return event;
    }

    private void sleepQuietly(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException ignored) {
            Thread.currentThread().interrupt();
        }
    }
}
```

### 6.3 关键点
- **可靠性**：`ack/rollback` 控制，有异常时回退重试，确保不丢不重。
- **批量处理**：`getWithoutAck(1024)` 批量拉取，减小网络开销。
- **幂等性**：下游根据 `binlogFile + binlogPos + deviceId` 去重。
- **安全性**：建议通过 TLS/SSH 隧道与 Canal Server 通信。

## 7. 与原方案的关系
- 原 `方案5-超大规模.md` 中的 “方案5.1” 主体仍保持不变。
- 本文档提供 Nginx+MQ 接入及 Canal Java 实现的独立说明，可作为补充材料引用。

</span>


