<span  style="font-family: Simsun,serif; font-size: 17px; ">

### 原型

- 树结构，每个节点包含子集节点，每个子级节点有且仅有一个父级节点，
- 每个节点包含几个信息，id，父级节点id，节点名称，全路径
- 树做多有10层
- 现在有个功能，可以将树的某个节点，移动到某个节点的子级节点中，所有下级节点都要移动
- 移动后，需要获取新的全路径
- 给设计一个可用的方案，用java实现

### 方案设计（Materialized Path 物化路径法）

- **核心字段**：
  - `id`：主键
  - `parent_id`：父节点 id（根节点为 `NULL` 或 `0`）
  - `name`：节点名称
  - `path`：物化路径（例如 `/root/a/b/`，以分隔符开头并以分隔符结尾，便于前缀匹配）
  - `depth`：层级深度（根为 0）

- **移动思路**：
  1) 校验：禁止把节点移动到其自身或其任一子孙节点下；禁止超过最大层级 10；禁止产生重复同名冲突（如需）；禁止形成环。
  2) 计算移动前后路径前缀：`oldPrefix = 源节点.path`，`newPrefix = 新父节点.path + 源节点.name + "/"`。
  3) 批量更新源节点及其所有后代的 `path` 前缀（以 `REPLACE(path, oldPrefix, newPrefix)` 或 `CONCAT`+`SUBSTRING` 方式）。
  4) 同步更新 `parent_id`（仅源节点），以及所有受影响节点的 `depth`（差值增量 `delta = newDepth - oldDepth`）。
  5) 全过程开启事务，必要时加行级锁避免并发写冲突。

### 数据表结构示例（MySQL）

```sql
CREATE TABLE dept (
  id        BIGINT PRIMARY KEY,
  parent_id BIGINT NULL,
  name      VARCHAR(128) NOT NULL,
  path      VARCHAR(1024) NOT NULL,   -- 以 / 开头与结尾，如 /root/a/b/
  depth     INT NOT NULL,             -- 根为 0
  CONSTRAINT uk_path UNIQUE (path),
  INDEX idx_parent (parent_id),
  INDEX idx_path (path)               -- 前缀查询需要
);
```

### 批量更新要点（SQL）

- 获取所有需要更新的节点：`SELECT * FROM dept WHERE path LIKE CONCAT(?, '%')`（`?` 为 `oldPrefix`）。
- 批量更新路径：

```sql
UPDATE dept
SET path = REPLACE(path, :oldPrefix, :newPrefix)
WHERE path LIKE CONCAT(:oldPrefix, '%');
```

- 批量更新层级（以差值增量方式）：

```sql
UPDATE dept
SET depth = depth + :delta
WHERE path LIKE CONCAT(:newPrefix, '%'); -- 或使用 oldPrefix，视执行顺序而定
```

- 更新源节点父引用：

```sql
UPDATE dept SET parent_id = :newParentId WHERE id = :sourceId;
```

建议把上述操作放在同一事务中，顺序一般为：锁定关键行 → 读校验 → 计算新前缀与层级差 → 更新 `parent_id` → 批量更新 `path` → 批量更新 `depth` → 提交。

### 关键校验

- 自身及子孙校验：`newParent.path` 不能以 `oldPrefix` 开头。
- 最大层级限制：`newDepth = newParent.depth + 1`，以及后代最大深度加上 `delta` 后不得超过 10。
- 同名策略：若同父下 `name` 需唯一，则在移动前检查 `EXISTS(SELECT 1 FROM dept WHERE parent_id=:newParentId AND name=:sourceName)`。

### Java 示例（JDBC，事务内）

```java
import java.sql.*;
import java.util.Objects;

public class DeptService {
    private final DataSource dataSource;

    public DeptService(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public void moveNode(long sourceId, long newParentId) throws SQLException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            try {
                // 1) 读取源与新父，使用 FOR UPDATE 锁行，避免并发修改
                Dept source = getDeptForUpdate(conn, sourceId);
                Dept newParent = getDeptForUpdate(conn, newParentId);

                if (source == null || newParent == null) {
                    throw new IllegalArgumentException("源或目标父节点不存在");
                }
                // 自环/自子孙校验
                if (newParent.path.startsWith(source.path)) {
                    throw new IllegalStateException("不能将节点移动到其自身或其子孙节点下");
                }
                // 计算新前缀与层级差
                String oldPrefix = source.path;
                String newPrefix = normalizePath(newParent.path + getLastNameFromPath(source.path));
                int delta = (newParent.depth + 1) - source.depth;

                // 最大层级校验：查询子树最大深度（可选优化：维护冗余或用 depth + delta 判断）
                int maxDepthInSubtree = getMaxDepthUnderPrefix(conn, oldPrefix);
                if (maxDepthInSubtree + delta > 10) {
                    throw new IllegalStateException("移动后超过最大层级 10");
                }

                // 可选：同名校验（若有约束）
                // if (existsSameNameUnderParent(conn, newParentId, getNodeName(source))) { ... }

                // 2) 先更新源节点的 parent_id
                try (PreparedStatement ps = conn.prepareStatement(
                        "UPDATE dept SET parent_id=? WHERE id=?")) {
                    ps.setLong(1, newParentId);
                    ps.setLong(2, sourceId);
                    ps.executeUpdate();
                }

                // 3) 批量更新 path（使用 REPLACE 前缀替换）
                try (PreparedStatement ps = conn.prepareStatement(
                        "UPDATE dept SET path = REPLACE(path, ?, ?) WHERE path LIKE CONCAT(?, '%')")) {
                    ps.setString(1, oldPrefix);
                    ps.setString(2, newPrefix);
                    ps.setString(3, oldPrefix);
                    ps.executeUpdate();
                }

                // 4) 批量更新 depth（差值增量）
                try (PreparedStatement ps = conn.prepareStatement(
                        "UPDATE dept SET depth = depth + ? WHERE path LIKE CONCAT(?, '%')")) {
                    ps.setInt(1, delta);
                    ps.setString(2, newPrefix);
                    ps.executeUpdate();
                }

                conn.commit();
            } catch (Exception ex) {
                conn.rollback();
                throw ex;
            } finally {
                conn.setAutoCommit(true);
            }
        }
    }

    private Dept getDeptForUpdate(Connection conn, long id) throws SQLException {
        try (PreparedStatement ps = conn.prepareStatement(
                "SELECT id, parent_id, name, path, depth FROM dept WHERE id = ? FOR UPDATE")) {
            ps.setLong(1, id);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    Dept d = new Dept();
                    d.id = rs.getLong("id");
                    d.parentId = rs.getLong("parent_id");
                    if (rs.wasNull()) d.parentId = null;
                    d.name = rs.getString("name");
                    d.path = rs.getString("path");
                    d.depth = rs.getInt("depth");
                    return d;
                }
            }
        }
        return null;
    }

    private int getMaxDepthUnderPrefix(Connection conn, String prefix) throws SQLException {
        try (PreparedStatement ps = conn.prepareStatement(
                "SELECT MAX(depth) AS md FROM dept WHERE path LIKE CONCAT(?, '%')")) {
            ps.setString(1, prefix);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return rs.getInt("md");
                }
            }
        }
        return 0;
    }

    private static String normalizePath(String path) {
        String p = path;
        if (!p.startsWith("/")) p = "/" + p;
        if (!p.endsWith("/")) p = p + "/";
        return p.replaceAll("/{2,}", "/");
    }

    private static String getLastNameFromPath(String path) {
        // 假设 path 形如 /a/b/c/，则返回 "c"
        String[] parts = path.split("/");
        for (int i = parts.length - 1; i >= 0; i--) {
            if (!parts[i].isEmpty()) return parts[i];
        }
        return "";
    }

    static class Dept {
        Long id;
        Long parentId;
        String name;
        String path;
        int depth;
    }
}
```

### 复杂度与适用性

- 路径更新为一次批量 SQL，时间复杂度近似为受影响节点数的线性；对大子树移动较高效。
- 需为 `path` 建立合适索引（如前缀索引）以保证 `LIKE 'prefix%'` 性能。
- 与“邻接表”纯遍历更新相比，物化路径在移动整棵子树时更简单、易维护。

</span>