<span  style="font-family: Simsun,serif; font-size: 17px; ">

### 方案设计

- 背景：原导入导出依赖 `@ExcelProperty` 注解，字段写死；现需“动态模板”，运行期根据模板配置决定导入导出字段、顺序、标题、转换与校验。
- 思路对比：
  - 方案A（推荐）：配置驱动 + 物化模板（JSON/DB 存储字段配置）→ 运行期组装 EasyExcel 动态表头与数据映射；不依赖注解。
  - 方案B：运行期字节码生成带注解的类（如 ByteBuddy/Javassist）→ 复杂度高、维护成本大，不推荐。

### 选型与要点

- 使用 `EasyExcel 3.x` 的动态表头能力：
  - 导出：`head` 使用 `List<List<String>>` 构建表头，数据使用 `List<List<Object>>` 或 `List<? extends Map>`；无需注解。
  - 导入：使用 `AnalysisEventListener<Map<Integer, String>>` 或 `AnalysisEventListener<Map<String, String>>`（配合 `@HeadRowNumber` 或自定义 head 解析）读取头与行。
- 模板配置建议（可存 DB 或 JSON）：
  - `TemplateDefinition`：模板编码、名称、字段列表、版本、校验规则等
  - `TemplateField`：展示标题、字段编码、数据类型、是否必填、顺序、字典/枚举、正则、默认值、转换器等

### 模板配置示例（JSON）

```json
{
  "code": "user_import_v1",
  "name": "用户导入模板V1",
  "fields": [
    { "title": "管理员", "field": "username", "type": "string", "required": true, "order": 1 },
    { "title": "手机号", "field": "phone",    "type": "string", "required": true, "order": 2, "regex": "^1\\d{10}$" }
  ]
}
```

### 导出：动态表头 + 动态数据

```java
import com.alibaba.excel.EasyExcel;
import com.alibaba.excel.write.metadata.WriteSheet;

import java.io.OutputStream;
import java.util.*;
import java.util.stream.Collectors;

public class DynamicExportService {

    public void export(OutputStream out, TemplateDefinition template, List<Map<String, Object>> rows) {
        // 1) 构建表头：List<List<String>>（支持多级表头，这里用一级标题）
        List<TemplateField> sorted = template.getFields().stream()
                .sorted(Comparator.comparingInt(TemplateField::getOrder))
                .collect(Collectors.toList());
        List<List<String>> head = sorted.stream()
                .map(f -> Collections.singletonList(f.getTitle()))
                .collect(Collectors.toList());

        // 2) 构建数据：与表头列顺序严格一致
        List<List<Object>> data = new ArrayList<>(rows.size());
        for (Map<String, Object> row : rows) {
            List<Object> line = new ArrayList<>(sorted.size());
            for (TemplateField f : sorted) {
                Object v = row.get(f.getField());
                // 可在此处应用字典转换/格式化
                line.add(v);
            }
            data.add(line);
        }

        // 3) 写出
        WriteSheet sheet = EasyExcel.writerSheet("导出").head(head).build();
        EasyExcel.write(out).sheet().head(head).doWrite(data);
    }
}
```

说明：
- 若需要复杂单元格样式/宽度/格式，可使用 `WriteHandler`（如 `LongestMatchColumnWidthStyleStrategy`、自定义样式）。
- 日期/数值格式可在数据阶段完成转换，或通过自定义 `Converter` 配合对象写出（但对象写出就回到注解/HeadMapping，建议仍用动态 head）。

### 导入：读取表头并按模板映射

```java
import com.alibaba.excel.EasyExcel;
import com.alibaba.excel.context.AnalysisContext;
import com.alibaba.excel.event.AnalysisEventListener;

import java.io.InputStream;
import java.util.*;

public class DynamicImportService {

    public List<RowResult> importData(InputStream in, TemplateDefinition template) {
        List<RowResult> results = new ArrayList<>();
        Map<Integer, String> indexToTitle = new HashMap<>();
        List<TemplateField> fields = new ArrayList<>(template.getFields());
        fields.sort(Comparator.comparingInt(TemplateField::getOrder));

        AnalysisEventListener<Map<Integer, String>> listener = new AnalysisEventListener<Map<Integer, String>>() {
            private boolean headerParsed = false;

            @Override
            public void invokeHeadMap(Map<Integer, String> headMap, AnalysisContext context) {
                // 读取第一行表头
                indexToTitle.clear();
                indexToTitle.putAll(headMap);
                headerParsed = true;
                // 可做表头一致性校验（标题、数量、顺序等）
            }

            @Override
            public void invoke(Map<Integer, String> data, AnalysisContext context) {
                // 逐行读取数据
                RowResult rr = new RowResult();
                rr.rowIndex = context.readRowHolder().getRowIndex() + 1;

                Map<String, Object> mapped = new LinkedHashMap<>();
                List<String> errors = new ArrayList<>();

                for (Map.Entry<Integer, String> e : data.entrySet()) {
                    Integer colIndex = e.getKey();
                    String raw = e.getValue();
                    String title = indexToTitle.get(colIndex);
                    if (title == null) { continue; }

                    // 根据标题找到模板字段
                    TemplateField field = fields.stream()
                            .filter(f -> Objects.equals(f.getTitle(), title))
                            .findFirst().orElse(null);
                    if (field == null) { continue; }

                    // 基础转换与校验
                    Object value = convert(raw, field.getType());
                    List<String> err = validate(value, field);
                    if (!err.isEmpty()) { errors.addAll(err); }
                    mapped.put(field.getField(), value);
                }

                // 必填校验（模板中 required=true 的字段）
                for (TemplateField f : fields) {
                    if (Boolean.TRUE.equals(f.getRequired())) {
                        Object v = mapped.get(f.getField());
                        if (v == null || String.valueOf(v).isBlank()) {
                            errors.add("必填字段缺失：" + f.getTitle());
                        }
                    }
                }

                rr.ok = errors.isEmpty();
                rr.errors = errors;
                rr.data = mapped;
                results.add(rr);
            }

            @Override
            public void doAfterAllAnalysed(AnalysisContext context) {
            }
        };

        EasyExcel.read(in, listener).headRowNumber(1).sheet().doRead();
        return results;
    }

    private Object convert(String raw, String type) {
        if (raw == null) return null;
        switch (type) {
            case "string": return raw.trim();
            case "int":
            case "integer": return raw.isBlank() ? null : Integer.valueOf(raw);
            case "long": return raw.isBlank() ? null : Long.valueOf(raw);
            case "bool":
            case "boolean": return "是".equals(raw) || "true".equalsIgnoreCase(raw);
            case "date": // 简化：按 yyyy-MM-dd，可扩展多格式
                try { return java.time.LocalDate.parse(raw); } catch (Exception ignore) { return raw; }
            default: return raw;
        }
    }

    private List<String> validate(Object v, TemplateField f) {
        List<String> errs = new ArrayList<>();
        if (v == null) return errs;
        if (f.getRegex() != null && v instanceof String) {
            if (!((String) v).matches(f.getRegex())) {
                errs.add("格式不正确：" + f.getTitle());
            }
        }
        // 可扩展：长度、范围、枚举、字典、跨字段校验等
        return errs;
    }

    public static class RowResult {
        public int rowIndex;
        public boolean ok;
        public Map<String, Object> data;
        public List<String> errors;
    }
}
```

### 模型定义（示例）

```java
import lombok.Data;
import java.util.List;

@Data
public class TemplateDefinition {
    private String code;
    private String name;
    private List<TemplateField> fields;
}

@Data
public class TemplateField {
    private String title;     // 展示标题，如“管理员”
    private String field;     // 字段编码，如“username”
    private String type;      // string/int/long/bool/date/...
    private Boolean required; // 是否必填
    private Integer order;    // 列顺序，越小越靠前
    private String regex;     // 正则校验，如手机号
    // 可扩展：dictCode、enumClass、dateFormat、defaultValue、converterBeanName 等
}
```

### 与注解方式的关系

- 注解适合固定模型；动态模板更适合“配置变更频繁/多租户差异/字段可裁剪”的场景。
- 若项目中仍保留部分注解模型，可双轨：固定模型继续注解；动态模型使用本方案（动态 head + Map 数据）。

### 并发与大文件建议

- 导入：使用分页流式读取、分批校验与入库；错误行单独导出错误报告（行号 + 错误信息）。
- 导出：大数据量使用多批次写入或临时文件，必要时使用异步任务与文件存储。

### 与现有示例对应

- 旧版注解模型（如 `ZnUserInfoImportVo`）中的“管理员/手机号”两列，可在模板中分别定义为 `title="管理员", field="username"` 与 `title="手机号", field="phone"`；导出时构建同名表头；导入时通过标题映射回字段完成解析与校验。

### 导入导出测试代码

~~~java
// 构造模板（与《方案与示例.md》中一致）
TemplateDefinition tpl = new TemplateDefinition();
tpl.setCode("user_import_v1");
tpl.setName("用户导入模板V1");

TemplateField f1 = new TemplateField();
f1.setTitle("管理员");
f1.setField("username");
f1.setType("string");
f1.setRequired(true);
f1.setOrder(1);

TemplateField f2 = new TemplateField();
f2.setTitle("手机号");
f2.setField("phone");
f2.setType("string");
f2.setRequired(true);
f2.setOrder(2);
f2.setRegex("^1\\d{10}$");

tpl.setFields(java.util.Arrays.asList(f1, f2));

// ========== 导出测试 ==========
java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream();
DynamicExportService exportService = new DynamicExportService();

java.util.List<java.util.Map<String, Object>> rows = new java.util.ArrayList<>();
java.util.Map<String, Object> r1 = new java.util.HashMap<>();
r1.put("username", "admin");
r1.put("phone", "13800138000");
rows.add(r1);

java.util.Map<String, Object> r2 = new java.util.HashMap<>();
r2.put("username", "tom");
r2.put("phone", "13900139000");
rows.add(r2);

exportService.export(out, tpl, rows);
byte[] excelBytes = out.toByteArray();
// 将 excelBytes 保存为文件以便查看
try (java.io.FileOutputStream fos = new java.io.FileOutputStream("动态模板导出示例.xlsx")) {
    fos.write(excelBytes);
}

// ========== 导入测试 ==========
// 这里直接使用上一步导出的字节进行读取；实际项目中可来自上传文件 InputStream
DynamicImportService importService = new DynamicImportService();
try (java.io.ByteArrayInputStream in = new java.io.ByteArrayInputStream(excelBytes)) {
    java.util.List<DynamicImportService.RowResult> results = importService.importData(in, tpl);
    for (DynamicImportService.RowResult rr : results) {
        System.out.println("Row=" + rr.rowIndex + ", ok=" + rr.ok + ", data=" + rr.data + ", errors=" + rr.errors);
    }
}
~~~

</span>

