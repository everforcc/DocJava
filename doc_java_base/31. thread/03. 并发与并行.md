<span  style="font-family: Simsun,serif; font-size: 17px; ">

- **并发**：是指同一个时间段内多个任务同时都在执行，并且都没有执行结束。并发任务强调在一个时间段内同时执行，而一个时间段由多个单位时间累积而成，所以说并发的多个任务在单位时间内不一定同时在执行 。

- **并行**：是说在单位时间内多个任务同时在执行 。

在多线程编程实践中，线程的个数往往多于CPU的个数，所以一般都称多线程并发编程而不是多线程并行编程。

### 并发过程中常见的问题：

1. 线程安全问题：

- 多个线程同时操作共享变量1时，会出现线程1更新共享变量1的值，但是其他线程获取到的是共享变量没有被更新之前的值。就会导致数据不准确问题。

2. 共享内存不可见性问题

~~~
线程A          线程B
私有内存       私有内存
共享副本变量   共享副本变量
    
               主内存
共享变量1      共享变量2      共享变量3
~~~

- Java 内存模型规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内存里面的变量==复制==到自己的工作空间或者叫作工作内存，线程读写变量时操作的是自己工作内存中的变量 。（如上图所示）

~~~
线程A                        线程B
一级缓存                     一级缓存
               
               二级缓存
               
               主内存
               
共享变量1      共享变量2      共享变量3  

     （实际工作的java内存模型）
     
~~~

- 上图中所示是一个双核 CPU 系统架构，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。CPU的每个核都有自己的一级缓存，在有些架构里面还有一个所有CPU都共享的二级缓存。 那么Java内存模型里面的工作内存，就对应这里的 Ll或者 L2 缓存或者 CPU 的寄存器

1. 线程A首先获取共享变量X的值，由于两级Cache都没有命中，所以加载主内存中X的值，假如为0。然后把X=0的值缓存到两级缓存，线程A修改X的值为1,然后将其写入两级Cache，并且刷新到主内存。线程A操作完毕后，线程A所在的CPU的两级Cache内和主内存里面的X的值都是l。
2. 线程B获取X的值，首先一级缓存没有命中，然后看二级缓存，二级缓存命中了，所以返回X=1；到这里一切都是正常的，因为这时候主内存中也是X=l。然后线程B修改X的值为2，并将其存放到线程2所在的一级Cache和共享二级Cache中，最后更新主内存中X的值为2，到这里一切都是好的。
3. 线程A这次又需要修改X的值，获取时一级缓存命中，并且X=l这里问题就出现了，明明线程B已经把X的值修改为2，为何线程A获取的还是l呢？这就是共享变量的内存不可见问题，也就是线程B写入的值对线程A不可见。


</span>