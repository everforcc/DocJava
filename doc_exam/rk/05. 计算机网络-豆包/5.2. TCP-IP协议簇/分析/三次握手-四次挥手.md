<span  style="font-family: Simsun,serif; font-size: 17px; ">

# TCP 三次握手与四次挥手（软件设计师核心笔记）

## 一、核心概念

- **三次握手**：TCP 建立可靠连接的过程，确保通信双方收发能力正常，协商初始序列号（ISN）。
    - 控制位字段 大写 ACK
    - 序号字段 小写 ack
- **四次挥手**：TCP 释放全双工连接的过程，确保双方数据传输完毕，避免数据丢失。
- **核心标志位**：`SYN`（同步）、`ACK`（确认）、`FIN`（结束）
- ESTABLISHED 正常数据传输状态 establish

---

## 二、三次握手（建立连接）

### 1. 握手流程

| 握手次数 | 发起方 | 报文类型    | 核心字段                                           | 状态变化                                                             | 说明                              | 字段/状态单词含义补充                                                                                                                       |
|------|-----|---------|------------------------------------------------|------------------------------------------------------------------|---------------------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| 第1次  | 客户端 | SYN     | `SYN=1`，`seq=x`（客户端初始序列号，随机生成）                 | 客户端：`CLOSED` → `SYN-SENT`                                        | 客户端主动发起连接请求，同步自身初始序列号           | SYN：Synchronize（同步），请求同步序列号；seq：sequence number（序列号），标识报文数据的起始编号；CLOSED：关闭状态，连接未建立；SYN-SENT：同步报文已发送状态，等待服务器响应                     |
| 第2次  | 服务器 | SYN+ACK | `SYN=1`，`seq=y`（服务器初始序列号）<br>`ACK=1`，`ack=x+1` | 服务器：`LISTEN` → `SYN-RCVD`                                        | 服务器确认收到客户端SYN，同时同步自身序列号         | ACK：Acknowledgment（确认），确认标志位；ack：acknowledgment number（确认号），期望接收的下一字节序列号；LISTEN：监听状态，服务器等待客户端连接请求；SYN-RCVD：同步报文已接收状态，已收到客户端SYN并回复 |
| 第3次  | 客户端 | ACK     | `ACK=1`，`ack=y+1`<br>`seq=x+1`                 | 客户端：`SYN-SENT` → `ESTABLISHED`<br>服务器：`SYN-RCVD` → `ESTABLISHED` | 客户端确认收到服务器响应，**连接正式建立**，双方可传输数据 | ESTABLISHED：已建立状态，连接成功，可双向传输数据                                                                                                    |

### 2. 关键问题：为什么需要三次握手？

- 防止**失效的连接请求报文**（因网络延迟滞留）突然到达服务器，导致服务器建立无效连接，浪费资源。
- 两次握手无法验证服务器的接收能力，三次握手可确保双方收发能力均正常。

---

## 三、四次挥手（释放连接）

### 1. 挥手流程

| 挥手次数 | 发起方 | 报文类型    | 核心字段                                               | 状态变化                                                                   | 说明                                         | 字段/状态单词含义补充                                                                                                                           |
|------|-----|---------|----------------------------------------------------|------------------------------------------------------------------------|--------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|
| 第1次  | 客户端 | FIN     | `FIN=1`，`seq=u`（客户端当前序列号）                          | 客户端：`ESTABLISHED` → `FIN-WAIT-1`                                       | 客户端请求关闭**自身发送通道**，不再发送数据，但可接收数据            | FIN：Finish（结束），关闭连接的请求标志；seq：sequence number（序列号），当前发送数据的起始编号；ESTABLISHED：已建立连接状态；FIN-WAIT-1：结束等待1状态，等待服务器的ACK响应                      |
| 第2次  | 服务器 | ACK     | `ACK=1`，`ack=u+1`<br>`seq=v`（服务器当前序列号）             | 客户端：`FIN-WAIT-1` → `FIN-WAIT-2`<br>服务器：`ESTABLISHED` → `CLOSE-WAIT`    | 服务器确认收到客户端FIN，此时服务器仍可向客户端发送数据              | ACK：Acknowledgment（确认），确认标志位；ack：acknowledgment number（确认号），期望接收的下一字节序列号；FIN-WAIT-2：结束等待2状态，等待服务器的FIN报文；CLOSE-WAIT：关闭等待状态，服务器准备关闭自身通道 |
| 第3次  | 服务器 | FIN+ACK | `FIN=1`，`seq=w`（服务器发完数据后的序列号）<br>`ACK=1`，`ack=u+1` | 服务器：`CLOSE-WAIT` → `LAST-ACK`                                          | 服务器发送完所有数据，请求关闭**自身发送通道**                  | LAST-ACK：最后确认状态，服务器等待客户端的最终ACK响应                                                                                                      |
| 第4次  | 客户端 | ACK     | `ACK=1`，`ack=w+1`<br>`seq=u+1`                     | 客户端：`FIN-WAIT-2` → `TIME-WAIT` → `CLOSED`<br>服务器：`LAST-ACK` → `CLOSED` | 客户端确认收到服务器FIN，等待 **2MSL（最长报文段寿命）** 后彻底关闭连接 | TIME-WAIT：时间等待状态，客户端等待2MSL确保连接完全关闭；CLOSED：关闭状态，连接彻底释放；2MSL：Maximum Segment Lifetime（最长报文段寿命），报文在网络中的最大存活时间                            |

- 第3次，服务端发送完所有数据后，等待客户端的ACK，如果超时会等待重传
- 第4次，客户端还是需要回复一个ACK，客户端不靠服务器回复确认
    - 而是靠 2MSL 等待时间 “兜底”—— 没收到重发的 FIN，就等于服务器收到了 ACK

### 2. 关键问题解析

| 问题             | 核心答案                                                                                 |
|----------------|--------------------------------------------------------------------------------------|
| 为什么需要四次挥手？     | TCP 是全双工通信，收发通道独立。客户端发FIN仅关闭自己的发送通道，服务器需先回复ACK确认，待数据发送完毕后再发FIN关闭自身发送通道，因此需四次交互       |
| 客户端为什么要等待2MSL？ | 1. 确保最后一个ACK报文能到达服务器（若丢失，服务器会重发FIN，客户端可在2MSL内重发ACK）；<br>2. 让本次连接的所有报文段从网络中消失，避免影响新连接 |

---

## 四、三次握手 vs 四次挥手 对比

| 对比维度   | 三次握手                     | 四次挥手                                  |
|--------|--------------------------|---------------------------------------|
| 核心目的   | 建立可靠连接                   | 释放全双工连接                               |
| 交互次数   | 3次                       | 4次                                    |
| 核心标志位  | `SYN`、`ACK`              | `FIN`、`ACK`                           |
| 关键中间状态 | `SYN-SENT`、`SYN-RCVD`    | `FIN-WAIT-2`、`CLOSE-WAIT`、`TIME-WAIT` |
| 最终状态   | 双方进入 `ESTABLISHED`（连接状态） | 双方进入 `CLOSED`（关闭状态）                   |

---

## 五、软件设计师考试高频考点

1. 三次握手的报文顺序：`SYN` → `SYN+ACK` → `ACK`
2. 四次挥手的 `TIME-WAIT` 状态及 2MSL 的作用
3. 状态转换触发条件（如服务器 `LISTEN` → `SYN-RCVD`：收到客户端SYN报文）
4. 三次握手/四次挥手的核心目的（建立连接/释放连接，确保可靠性）

</span>