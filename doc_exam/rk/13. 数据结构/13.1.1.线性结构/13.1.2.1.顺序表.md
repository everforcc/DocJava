<span  style="font-family: Simsun,serif; font-size: 17px; ">

[TOC]

### 1. 线性结构

- 顺序表
- 链表

### 2. 顺序表

|   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |

#### 2.1 读操作

~~~
读 a[4]
时间复杂度 O(1)
~~~

- 查询操作
    - $(1+n)n/2*n$
    - 可能移动的次数
        - 0
        - $(1+n)/2$
        - n

#### 2.2 查询操作

~~~
查询某个数值，返回位置
失败返回-1
1 + 2 + 3 + ... + 8
---
8
(1+n)n/2n=(1+n)/2
~~~

#### 2.3 插入操作

- 插入操作?
    - $(1+n)n/2*n$
        - 0
        - ~~$(1+n)/2$~~
        - $n/2$
        - n

~~~
插入元素x到a[i]
元素后移
0 + 1 + 2 + 3 + ... + n
---
0 + n
(0+n)(n+1)/2n
-- 自己分析
0 + 1 + 2 + 3 + ... + n
---
1 + n
(0+n)(n+1)/2(n+1) = n/2
~~~

#### 2.4 删除操作

- 删除操作
    - 0
    - ~~$(n-1)/2$~~
        - $n/2$
    - n-1

~~~
0 + 1 + 2 + 3 + ... + (n-1)
--- 分析
(n-1)n/2n=(n-1)/2
~~~

### 3. 链表

#### 3.1 链表结构

**重要说明**: 链表有两种常见的实现方式

##### 3.1.1 带头结点的链表（本文档采用）

```
头结点 → [数据1|next] → [数据2|next] → [数据3|next] → NULL
```

- **头结点**: 可以存储链表长度或其他信息
- **数据结点**: 包含数据域和指针域
- **head指针**: 指向头结点

##### 3.1.2 不带头结点的链表

```
head → [数据1|next] → [数据2|next] → [数据3|next] → NULL
```

- **head指针**: 直接指向第一个数据结点
- **空链表**: head = NULL

#### 3.2 读操作（按位置读取）

**问题**: 读取链表中第i个位置的元素

**操作过程**:
```c
Node* p = head;  // 从头结点开始
for(int j = 0; j < i; j++) {
    p = p->next;  // 向后移动
}
return p->data;   // 返回数据
```

**时间复杂度分析**:
- **最好情况**: 读取第1个元素，O(1)
- **最坏情况**: 读取第n个元素，O(n)
- **平均情况**: 读取中间位置，O(n/2) = O(n)

**结论**: 读操作时间复杂度为 **O(n)**

#### 3.3 查找操作（按值查找）

**问题**: 在链表中查找指定值，返回位置

**操作过程**:
```c
Node* p = head->next;  // 从第一个数据结点开始
int pos = 0;
while(p != NULL) {
    if(p->data == target) return pos;
    p = p->next;
    pos++;
}
return -1;  // 未找到
```

**时间复杂度分析**:
- **最好情况**: 第1个元素就是目标，O(1)
- **最坏情况**: 目标在最后或不存在，O(n)
- **平均情况**: 目标在中间位置，O(n/2) = O(n)

**结论**: 查找操作时间复杂度为 **O(n)**

#### 3.4 插入操作

##### 3.4.1 头插法（在链表头部插入）

**带头结点的实现**:
```c
Node* newNode = createNode(data);
newNode->next = head->next;  // 新结点指向原第一个数据结点
head->next = newNode;        // 头结点指向新结点
```

**不带头结点的实现**:
```c
Node* newNode = createNode(data);
newNode->next = head;        // 新结点指向原第一个结点
head = newNode;              // head指向新结点（需要修改head指针）
```

**时间复杂度**: **O(1)**

**注意**: 不带头结点时需要修改head指针本身，函数需要传递head的地址

##### 3.4.2 尾插法（在链表尾部插入）

**操作过程**:
```c
Node* p = head;
while(p->next != NULL) {  // 找到最后一个结点
    p = p->next;
}
Node* newNode = createNode(data);
p->next = newNode;
newNode->next = NULL;
```

**时间复杂度**: **O(n)**

##### 3.4.3 中间插入（在第i个位置插入）

**操作过程**:
```c
Node* p = head;
for(int j = 0; j < i-1; j++) {  // 找到第i-1个结点
    p = p->next;
}
Node* newNode = createNode(data);
newNode->next = p->next;
p->next = newNode;
```

**时间复杂度分析**:
- **最好情况**: 在头部插入，O(1),todo 视频是这个（单链表）
- **最坏情况**: 在尾部插入，O(n)
- **平均情况**: 在中间插入，O(n/2) = O(n)

**结论**: 插入操作平均时间复杂度为 **O(n)**

##### 3.4.4 插入操作详细分析

假设链表有n个数据结点，分析在各位置插入的时间：

| 插入位置 | 需要遍历的结点数 | 时间复杂度 |
|---------|----------------|------------|
| 位置0（头部） | 0 | O(1) |
| 位置1 | 1 | O(1) |
| 位置2 | 2 | O(2) |
| ... | ... | ... |
| 位置i | i | O(i) |
| ... | ... | ... |
| 位置n（尾部） | n | O(n) |

**平均遍历次数**:
```
E = (0 + 1 + 2 + ... + n) / (n + 1)
  = n(n+1)/2 / (n+1)
  = n/2
```

**平均时间复杂度**: **O(n)**

#### 3.5 删除操作

- 备注
- 删除某个节点的时候，比如删除q节点，需要q前一个节点的指针（p），指向q下一个节点，才能删除q节点
    - 所以，知道p才能删除q节点，如果不知道p，就要从头开始遍历
    - 这就是视频第一步，求q的原因
    - q = p->link;
- todo,删除有两种方式，参考视频
- ![删除两种方式](../../pic/13.%20数据结构/img_4.png)

##### 3.5.1 按位置删除（删除第i个元素）

**操作过程**:
```c
Node* p = head;
for(int j = 0; j < i-1; j++) {  // 找到第i-1个结点
    p = p->next;
}
Node* q = p->next;  // 要删除的结点
p->next = q->next;  // 修改指针
free(q);            // 释放内存
```

**时间复杂度分析**:
- **最好情况**: 删除第1个元素，O(1)
- **最坏情况**: 删除第n个元素，O(n)
- **平均情况**: 删除中间元素，O(n/2) = O(n)

##### 3.5.2 按值删除（删除指定值的结点）

**操作过程**:
```c
Node* p = head;
while(p->next != NULL) {
    if(p->next->data == target) {
        Node* q = p->next;
        p->next = q->next;
        free(q);
        return;
    }
    p = p->next;
}
```

**时间复杂度**: **O(n)**

##### 3.5.3 删除操作详细分析

假设链表有n个数据结点，分析删除各位置元素的时间：

| 删除位置 | 需要遍历的结点数 | 时间复杂度 |
|---------|----------------|------------|
| 位置1 | 0（到达前驱） | O(1) |
| 位置2 | 1 | O(1) |
| 位置3 | 2 | O(2) |
| ... | ... | ... |
| 位置i | i-1 | O(i) |
| ... | ... | ... |
| 位置n | n-1 | O(n) |

**平均遍历次数**:
```
E = (0 + 1 + 2 + ... + (n-1)) / n
  = (n-1)n/2 / n
  = (n-1)/2
```

**平均时间复杂度**: **O(n)**

#### 3.6 链表与顺序表操作对比

| 操作 | 顺序表 | 单链表 | 说明 |
|------|--------|--------|------|
| **读取** | O(1) | O(n) | 顺序表可直接访问，链表需遍历 |
| **查找** | O(n) | O(n) | 都需要逐个比较 |
| **插入** | O(n) | O(n) | 顺序表需移动元素，链表需找位置 |
| **删除** | O(n) | O(n) | 顺序表需移动元素，链表需找位置 |
| **头部插入** | O(n) | O(1) | 链表头插优势明显 |
| **头部删除** | O(n) | O(1) | 链表头删优势明显 |

#### 3.7 链表的优缺点

**优点**:
- 动态分配内存，不需要预先确定大小
- 插入删除不需要移动大量元素（在已知位置的情况下）
- 头部操作效率高

**缺点**:
- 不支持随机访问，只能顺序访问
- 需要额外的指针空间
- 缓存性能较差（内存不连续）

#### 3.8 实际应用场景

**适合使用链表的场景**:
- 频繁的头部插入删除操作
- 不确定数据量大小
- 很少进行随机访问

**适合使用顺序表的场景**:
- 频繁的随机访问
- 对内存使用要求严格
- 需要利用缓存优势



</span>