# 13.3.3. 树与二叉树的特性-02 - Java代码示例

## 二叉树存储结构实现

```java
/**
 * 二叉树节点类
 */
public class TreeNode<T> {
    public T data;
    public TreeNode<T> left;
    public TreeNode<T> right;
    public TreeNode<T> parent; // 三叉链表中的父指针
    
    public TreeNode(T data) {
        this.data = data;
        this.left = null;
        this.right = null;
        this.parent = null;
    }
    
    public TreeNode(T data, TreeNode<T> left, TreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
        this.parent = null;
    }
    
    @Override
    public String toString() {
        return data.toString();
    }
}
```

## 顺序存储结构实现

```java
/**
 * 二叉树的顺序存储结构
 */
public class ArrayBinaryTree<T> {
    private T[] array;
    private int size;
    private static final int DEFAULT_CAPACITY = 16;
    
    @SuppressWarnings("unchecked")
    public ArrayBinaryTree() {
        this.array = (T[]) new Object[DEFAULT_CAPACITY];
        this.size = 0;
    }
    
    @SuppressWarnings("unchecked")
    public ArrayBinaryTree(int capacity) {
        this.array = (T[]) new Object[capacity];
        this.size = 0;
    }
    
    /**
     * 根据数组创建完全二叉树
     */
    public void createFromArray(T[] data) {
        if (data == null || data.length == 0) {
            return;
        }
        
        ensureCapacity(data.length);
        System.arraycopy(data, 0, array, 0, data.length);
        this.size = data.length;
    }
    
    /**
     * 获取左子节点索引
     */
    public int getLeftChildIndex(int index) {
        int leftIndex = 2 * index + 1;
        return leftIndex < size ? leftIndex : -1;
    }
    
    /**
     * 获取右子节点索引
     */
    public int getRightChildIndex(int index) {
        int rightIndex = 2 * index + 2;
        return rightIndex < size ? rightIndex : -1;
    }
    
    /**
     * 获取父节点索引
     */
    public int getParentIndex(int index) {
        if (index <= 0 || index >= size) {
            return -1;
        }
        return (index - 1) / 2;
    }
    
    /**
     * 获取节点数据
     */
    public T getData(int index) {
        if (index < 0 || index >= size) {
            return null;
        }
        return array[index];
    }
    
    /**
     * 设置节点数据
     */
    public void setData(int index, T data) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index out of bounds");
        }
        array[index] = data;
    }
    
    /**
     * 插入节点
     */
    public void insert(T data) {
        ensureCapacity(size + 1);
        array[size] = data;
        size++;
    }
    
    /**
     * 删除最后一个节点
     */
    public T removeLast() {
        if (size == 0) {
            return null;
        }
        T data = array[size - 1];
        array[size - 1] = null;
        size--;
        return data;
    }
    
    /**
     * 获取树的大小
     */
    public int size() {
        return size;
    }
    
    /**
     * 判断是否为空
     */
    public boolean isEmpty() {
        return size == 0;
    }
    
    /**
     * 前序遍历
     */
    public void preorderTraversal() {
        preorderTraversal(0);
    }
    
    private void preorderTraversal(int index) {
        if (index < 0 || index >= size || array[index] == null) {
            return;
        }
        
        System.out.print(array[index] + " ");
        preorderTraversal(getLeftChildIndex(index));
        preorderTraversal(getRightChildIndex(index));
    }
    
    /**
     * 中序遍历
     */
    public void inorderTraversal() {
        inorderTraversal(0);
    }
    
    private void inorderTraversal(int index) {
        if (index < 0 || index >= size || array[index] == null) {
            return;
        }
        
        inorderTraversal(getLeftChildIndex(index));
        System.out.print(array[index] + " ");
        inorderTraversal(getRightChildIndex(index));
    }
    
    /**
     * 后序遍历
     */
    public void postorderTraversal() {
        postorderTraversal(0);
    }
    
    private void postorderTraversal(int index) {
        if (index < 0 || index >= size || array[index] == null) {
            return;
        }
        
        postorderTraversal(getLeftChildIndex(index));
        postorderTraversal(getRightChildIndex(index));
        System.out.print(array[index] + " ");
    }
    
    /**
     * 层序遍历
     */
    public void levelOrderTraversal() {
        for (int i = 0; i < size; i++) {
            if (array[i] != null) {
                System.out.print(array[i] + " ");
            }
        }
    }
    
    /**
     * 确保容量足够
     */
    @SuppressWarnings("unchecked")
    private void ensureCapacity(int minCapacity) {
        if (minCapacity > array.length) {
            int newCapacity = Math.max(array.length * 2, minCapacity);
            T[] newArray = (T[]) new Object[newCapacity];
            System.arraycopy(array, 0, newArray, 0, size);
            array = newArray;
        }
    }
}
```

## 链式存储结构实现

```java
/**
 * 二叉树的链式存储结构
 */
public class LinkedBinaryTree<T> {
    private TreeNode<T> root;
    
    public LinkedBinaryTree() {
        this.root = null;
    }
    
    public LinkedBinaryTree(TreeNode<T> root) {
        this.root = root;
    }
    
    /**
     * 设置根节点
     */
    public void setRoot(TreeNode<T> root) {
        this.root = root;
    }
    
    /**
     * 获取根节点
     */
    public TreeNode<T> getRoot() {
        return root;
    }
    
    /**
     * 判断是否为空
     */
    public boolean isEmpty() {
        return root == null;
    }
    
    /**
     * 获取树的深度
     */
    public int getDepth() {
        return getDepth(root);
    }
    
    private int getDepth(TreeNode<T> node) {
        if (node == null) {
            return 0;
        }
        int leftDepth = getDepth(node.left);
        int rightDepth = getDepth(node.right);
        return Math.max(leftDepth, rightDepth) + 1;
    }
    
    /**
     * 获取节点总数
     */
    public int getNodeCount() {
        return getNodeCount(root);
    }
    
    private int getNodeCount(TreeNode<T> node) {
        if (node == null) {
            return 0;
        }
        return 1 + getNodeCount(node.left) + getNodeCount(node.right);
    }
    
    /**
     * 获取叶子节点数
     */
    public int getLeafCount() {
        return getLeafCount(root);
    }
    
    private int getLeafCount(TreeNode<T> node) {
        if (node == null) {
            return 0;
        }
        if (node.left == null && node.right == null) {
            return 1;
        }
        return getLeafCount(node.left) + getLeafCount(node.right);
    }
}
```

## 二叉树操作实现

```java
/**
 * 二叉树操作类
 */
public class BinaryTreeOperations<T> {
    
    /**
     * 根据数组创建完全二叉树
     */
    public TreeNode<T> createFromArray(T[] arr) {
        if (arr == null || arr.length == 0) {
            return null;
        }
        return createFromArrayHelper(arr, 0);
    }
    
    private TreeNode<T> createFromArrayHelper(T[] arr, int index) {
        if (index >= arr.length) {
            return null;
        }
        
        TreeNode<T> node = new TreeNode<>(arr[index]);
        node.left = createFromArrayHelper(arr, 2 * index + 1);
        node.right = createFromArrayHelper(arr, 2 * index + 2);
        
        return node;
    }
    
    /**
     * 销毁二叉树
     */
    public void destroyTree(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        destroyTree(root.left);
        destroyTree(root.right);
        root.left = null;
        root.right = null;
        root.parent = null;
    }
    
    /**
     * 复制二叉树
     */
    public TreeNode<T> copyTree(TreeNode<T> root) {
        if (root == null) {
            return null;
        }
        
        TreeNode<T> newNode = new TreeNode<>(root.data);
        newNode.left = copyTree(root.left);
        newNode.right = copyTree(root.right);
        
        return newNode;
    }
    
    /**
     * 查找节点
     */
    public TreeNode<T> findNode(TreeNode<T> root, T target) {
        if (root == null) {
            return null;
        }
        if (root.data.equals(target)) {
            return root;
        }
        
        TreeNode<T> leftResult = findNode(root.left, target);
        if (leftResult != null) {
            return leftResult;
        }
        
        return findNode(root.right, target);
    }
    
    /**
     * 查找父节点
     */
    public TreeNode<T> findParent(TreeNode<T> root, T target) {
        if (root == null) {
            return null;
        }
        
        if ((root.left != null && root.left.data.equals(target)) ||
            (root.right != null && root.right.data.equals(target))) {
            return root;
        }
        
        TreeNode<T> leftResult = findParent(root.left, target);
        if (leftResult != null) {
            return leftResult;
        }
        
        return findParent(root.right, target);
    }
    
    /**
     * 插入节点
     */
    public boolean insertNode(TreeNode<T> root, T parentData, T newData, boolean isLeft) {
        TreeNode<T> parent = findNode(root, parentData);
        if (parent == null) {
            return false;
        }
        
        TreeNode<T> newNode = new TreeNode<>(newData);
        newNode.parent = parent;
        
        if (isLeft) {
            if (parent.left != null) {
                return false; // 左子节点已存在
            }
            parent.left = newNode;
        } else {
            if (parent.right != null) {
                return false; // 右子节点已存在
            }
            parent.right = newNode;
        }
        
        return true;
    }
    
    /**
     * 删除节点
     */
    public boolean deleteNode(TreeNode<T> root, T target) {
        if (root == null) {
            return false;
        }
        
        // 删除根节点的特殊情况
        if (root.data.equals(target)) {
            return false; // 不能删除根节点
        }
        
        TreeNode<T> parent = findParent(root, target);
        if (parent == null) {
            return false;
        }
        
        TreeNode<T> targetNode = null;
        boolean isLeftChild = false;
        
        if (parent.left != null && parent.left.data.equals(target)) {
            targetNode = parent.left;
            isLeftChild = true;
        } else if (parent.right != null && parent.right.data.equals(target)) {
            targetNode = parent.right;
            isLeftChild = false;
        }
        
        if (targetNode == null) {
            return false;
        }
        
        // 删除叶子节点
        if (targetNode.left == null && targetNode.right == null) {
            if (isLeftChild) {
                parent.left = null;
            } else {
                parent.right = null;
            }
        }
        // 删除只有一个子节点的节点
        else if (targetNode.left == null || targetNode.right == null) {
            TreeNode<T> child = targetNode.left != null ? targetNode.left : targetNode.right;
            child.parent = parent;
            
            if (isLeftChild) {
                parent.left = child;
            } else {
                parent.right = child;
            }
        }
        // 删除有两个子节点的节点
        else {
            // 找到右子树的最小节点
            TreeNode<T> minNode = findMinNode(targetNode.right);
            targetNode.data = minNode.data;
            deleteNode(targetNode.right, minNode.data);
        }
        
        return true;
    }
    
    /**
     * 找到最小节点
     */
    private TreeNode<T> findMinNode(TreeNode<T> root) {
        while (root.left != null) {
            root = root.left;
        }
        return root;
    }
    
    /**
     * 判断两棵树是否相同
     */
    public boolean isSameTree(TreeNode<T> p, TreeNode<T> q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        return p.data.equals(q.data) && 
               isSameTree(p.left, q.left) && 
               isSameTree(p.right, q.right);
    }
    
    /**
     * 判断是否为平衡二叉树
     */
    public boolean isBalanced(TreeNode<T> root) {
        return getHeightIfBalanced(root) != -1;
    }
    
    private int getHeightIfBalanced(TreeNode<T> root) {
        if (root == null) {
            return 0;
        }
        
        int leftHeight = getHeightIfBalanced(root.left);
        if (leftHeight == -1) {
            return -1;
        }
        
        int rightHeight = getHeightIfBalanced(root.right);
        if (rightHeight == -1) {
            return -1;
        }
        
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

## 三叉链表实现

```java
/**
 * 三叉链表实现
 */
public class TernaryLinkedTree<T> {
    private TreeNode<T> root;
    
    public TernaryLinkedTree() {
        this.root = null;
    }
    
    /**
     * 插入节点并维护父指针
     */
    public boolean insertWithParent(TreeNode<T> parent, T data, boolean isLeft) {
        if (parent == null) {
            if (root == null) {
                root = new TreeNode<>(data);
                return true;
            }
            return false;
        }
        
        TreeNode<T> newNode = new TreeNode<>(data);
        newNode.parent = parent;
        
        if (isLeft) {
            if (parent.left != null) {
                return false;
            }
            parent.left = newNode;
        } else {
            if (parent.right != null) {
                return false;
            }
            parent.right = newNode;
        }
        
        return true;
    }
    
    /**
     * 删除节点并维护父指针
     */
    public boolean deleteWithParent(TreeNode<T> node) {
        if (node == null) {
            return false;
        }
        
        TreeNode<T> parent = node.parent;
        
        // 删除叶子节点
        if (node.left == null && node.right == null) {
            if (parent == null) {
                root = null;
            } else if (parent.left == node) {
                parent.left = null;
            } else {
                parent.right = null;
            }
        }
        // 删除只有一个子节点的节点
        else if (node.left == null || node.right == null) {
            TreeNode<T> child = node.left != null ? node.left : node.right;
            child.parent = parent;
            
            if (parent == null) {
                root = child;
            } else if (parent.left == node) {
                parent.left = child;
            } else {
                parent.right = child;
            }
        }
        // 删除有两个子节点的节点
        else {
            TreeNode<T> minNode = findMinNode(node.right);
            node.data = minNode.data;
            deleteWithParent(minNode);
        }
        
        return true;
    }
    
    /**
     * 找到最小节点
     */
    private TreeNode<T> findMinNode(TreeNode<T> root) {
        while (root.left != null) {
            root = root.left;
        }
        return root;
    }
    
    /**
     * 获取根节点
     */
    public TreeNode<T> getRoot() {
        return root;
    }
    
    /**
     * 设置根节点
     */
    public void setRoot(TreeNode<T> root) {
        this.root = root;
    }
}
```

## 测试代码

```java
/**
 * 二叉树特性测试类
 */
public class BinaryTreePropertiesTest {
    public static void main(String[] args) {
        System.out.println("=== 二叉树存储结构测试 ===");
        testArrayBinaryTree();
        
        System.out.println("\n=== 二叉树操作测试 ===");
        testBinaryTreeOperations();
        
        System.out.println("\n=== 三叉链表测试 ===");
        testTernaryLinkedTree();
    }
    
    /**
     * 测试数组二叉树
     */
    public static void testArrayBinaryTree() {
        Integer[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        ArrayBinaryTree<Integer> arrayTree = new ArrayBinaryTree<>();
        arrayTree.createFromArray(data);
        
        System.out.println("数组二叉树大小: " + arrayTree.size());
        System.out.println("左子节点索引: " + arrayTree.getLeftChildIndex(0));
        System.out.println("右子节点索引: " + arrayTree.getRightChildIndex(0));
        System.out.println("父节点索引: " + arrayTree.getParentIndex(1));
        
        System.out.print("前序遍历: ");
        arrayTree.preorderTraversal();
        System.out.println();
        
        System.out.print("中序遍历: ");
        arrayTree.inorderTraversal();
        System.out.println();
        
        System.out.print("后序遍历: ");
        arrayTree.postorderTraversal();
        System.out.println();
        
        System.out.print("层序遍历: ");
        arrayTree.levelOrderTraversal();
        System.out.println();
    }
    
    /**
     * 测试二叉树操作
     */
    public static void testBinaryTreeOperations() {
        String[] data = {"A", "B", "C", "D", "E", "F", "G"};
        BinaryTreeOperations<String> operations = new BinaryTreeOperations<>();
        TreeNode<String> root = operations.createFromArray(data);
        
        System.out.println("查找节点B: " + (operations.findNode(root, "B") != null));
        System.out.println("查找节点H: " + (operations.findNode(root, "H") != null));
        
        TreeNode<String> parent = operations.findParent(root, "D");
        System.out.println("节点D的父节点: " + (parent != null ? parent.data : "null"));
        
        boolean inserted = operations.insertNode(root, "B", "H", true);
        System.out.println("插入节点H: " + inserted);
        
        boolean deleted = operations.deleteNode(root, "D");
        System.out.println("删除节点D: " + deleted);
        
        TreeNode<String> copied = operations.copyTree(root);
        System.out.println("复制树是否相同: " + operations.isSameTree(root, copied));
        
        System.out.println("是否为平衡树: " + operations.isBalanced(root));
    }
    
    /**
     * 测试三叉链表
     */
    public static void testTernaryLinkedTree() {
        TernaryLinkedTree<Integer> ternaryTree = new TernaryLinkedTree<>();
        
        // 插入根节点
        TreeNode<Integer> root = new TreeNode<>(1);
        ternaryTree.setRoot(root);
        
        // 插入子节点
        ternaryTree.insertWithParent(root, 2, true);
        ternaryTree.insertWithParent(root, 3, false);
        
        TreeNode<Integer> leftChild = root.left;
        ternaryTree.insertWithParent(leftChild, 4, true);
        ternaryTree.insertWithParent(leftChild, 5, false);
        
        System.out.println("根节点: " + ternaryTree.getRoot().data);
        System.out.println("左子节点: " + root.left.data);
        System.out.println("右子节点: " + root.right.data);
        System.out.println("左子节点的父节点: " + root.left.parent.data);
        System.out.println("右子节点的父节点: " + root.right.parent.data);
        
        // 删除节点
        boolean deleted = ternaryTree.deleteWithParent(root.left);
        System.out.println("删除左子节点: " + deleted);
        System.out.println("删除后左子节点: " + (root.left != null ? root.left.data : "null"));
    }
}
```
