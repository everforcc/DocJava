# 13.3.5. 二叉排序树 - Java代码示例

## 二叉排序树节点定义

```java
/**
 * 二叉排序树节点类
 */
public class BSTNode<T extends Comparable<T>> {
    public T data;
    public BSTNode<T> left;
    public BSTNode<T> right;
    
    public BSTNode(T data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
    
    public BSTNode(T data, BSTNode<T> left, BSTNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
    
    @Override
    public String toString() {
        return data.toString();
    }
}
```

## 二叉排序树基本实现

```java
/**
 * 二叉排序树实现类
 */
public class BinarySearchTree<T extends Comparable<T>> {
    private BSTNode<T> root;
    
    public BinarySearchTree() {
        this.root = null;
    }
    
    /**
     * 获取根节点
     */
    public BSTNode<T> getRoot() {
        return root;
    }
    
    /**
     * 判断树是否为空
     */
    public boolean isEmpty() {
        return root == null;
    }
    
    /**
     * 查找节点（递归）
     */
    public BSTNode<T> search(T data) {
        return search(root, data);
    }
    
    private BSTNode<T> search(BSTNode<T> node, T data) {
        if (node == null || node.data.equals(data)) {
            return node;
        }
        
        if (data.compareTo(node.data) < 0) {
            return search(node.left, data);
        } else {
            return search(node.right, data);
        }
    }
    
    /**
     * 查找节点（迭代）
     */
    public BSTNode<T> searchIterative(T data) {
        BSTNode<T> current = root;
        
        while (current != null && !current.data.equals(data)) {
            if (data.compareTo(current.data) < 0) {
                current = current.left;
            } else {
                current = current.right;
            }
        }
        
        return current;
    }
    
    /**
     * 插入节点（递归）
     */
    public void insert(T data) {
        root = insert(root, data);
    }
    
    private BSTNode<T> insert(BSTNode<T> node, T data) {
        if (node == null) {
            return new BSTNode<>(data);
        }
        
        if (data.compareTo(node.data) < 0) {
            node.left = insert(node.left, data);
        } else if (data.compareTo(node.data) > 0) {
            node.right = insert(node.right, data);
        }
        // 如果相等，不插入重复元素
        
        return node;
    }
    
    /**
     * 插入节点（迭代）
     */
    public void insertIterative(T data) {
        if (root == null) {
            root = new BSTNode<>(data);
            return;
        }
        
        BSTNode<T> current = root;
        BSTNode<T> parent = null;
        
        while (current != null) {
            parent = current;
            if (data.compareTo(current.data) < 0) {
                current = current.left;
            } else if (data.compareTo(current.data) > 0) {
                current = current.right;
            } else {
                return; // 不插入重复元素
            }
        }
        
        if (data.compareTo(parent.data) < 0) {
            parent.left = new BSTNode<>(data);
        } else {
            parent.right = new BSTNode<>(data);
        }
    }
    
    /**
     * 删除节点
     */
    public void delete(T data) {
        root = delete(root, data);
    }
    
    private BSTNode<T> delete(BSTNode<T> node, T data) {
        if (node == null) {
            return null;
        }
        
        if (data.compareTo(node.data) < 0) {
            node.left = delete(node.left, data);
        } else if (data.compareTo(node.data) > 0) {
            node.right = delete(node.right, data);
        } else {
            // 找到要删除的节点
            if (node.left == null) {
                return node.right;
            } else if (node.right == null) {
                return node.left;
            } else {
                // 有两个子节点，找到右子树的最小值
                BSTNode<T> minNode = findMin(node.right);
                node.data = minNode.data;
                node.right = delete(node.right, minNode.data);
            }
        }
        
        return node;
    }
    
    /**
     * 找到最小节点
     */
    public BSTNode<T> findMin() {
        return findMin(root);
    }
    
    private BSTNode<T> findMin(BSTNode<T> node) {
        if (node == null) {
            return null;
        }
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }
    
    /**
     * 找到最大节点
     */
    public BSTNode<T> findMax() {
        return findMax(root);
    }
    
    private BSTNode<T> findMax(BSTNode<T> node) {
        if (node == null) {
            return null;
        }
        while (node.right != null) {
            node = node.right;
        }
        return node;
    }
    
    /**
     * 获取树的高度
     */
    public int getHeight() {
        return getHeight(root);
    }
    
    private int getHeight(BSTNode<T> node) {
        if (node == null) {
            return 0;
        }
        int leftHeight = getHeight(node.left);
        int rightHeight = getHeight(node.right);
        return Math.max(leftHeight, rightHeight) + 1;
    }
    
    /**
     * 获取节点总数
     */
    public int getNodeCount() {
        return getNodeCount(root);
    }
    
    private int getNodeCount(BSTNode<T> node) {
        if (node == null) {
            return 0;
        }
        return 1 + getNodeCount(node.left) + getNodeCount(node.right);
    }
    
    /**
     * 判断是否为有效的二叉排序树
     */
    public boolean isValidBST() {
        return isValidBST(root, null, null);
    }
    
    private boolean isValidBST(BSTNode<T> node, T min, T max) {
        if (node == null) {
            return true;
        }
        
        if ((min != null && node.data.compareTo(min) <= 0) ||
            (max != null && node.data.compareTo(max) >= 0)) {
            return false;
        }
        
        return isValidBST(node.left, min, node.data) &&
               isValidBST(node.right, node.data, max);
    }
}
```

## 二叉排序树遍历实现

```java
/**
 * 二叉排序树遍历类
 */
public class BSTTraversal<T extends Comparable<T>> {
    
    /**
     * 中序遍历（递归）
     */
    public static <T extends Comparable<T>> void inorderTraversal(BSTNode<T> root) {
        if (root == null) {
            return;
        }
        
        inorderTraversal(root.left);
        System.out.print(root.data + " ");
        inorderTraversal(root.right);
    }
    
    /**
     * 中序遍历（迭代）
     */
    public static <T extends Comparable<T>> void inorderTraversalIterative(BSTNode<T> root) {
        Stack<BSTNode<T>> stack = new Stack<>();
        BSTNode<T> current = root;
        
        while (current != null || !stack.isEmpty()) {
            while (current != null) {
                stack.push(current);
                current = current.left;
            }
            
            current = stack.pop();
            System.out.print(current.data + " ");
            current = current.right;
        }
    }
    
    /**
     * 前序遍历（递归）
     */
    public static <T extends Comparable<T>> void preorderTraversal(BSTNode<T> root) {
        if (root == null) {
            return;
        }
        
        System.out.print(root.data + " ");
        preorderTraversal(root.left);
        preorderTraversal(root.right);
    }
    
    /**
     * 前序遍历（迭代）
     */
    public static <T extends Comparable<T>> void preorderTraversalIterative(BSTNode<T> root) {
        if (root == null) {
            return;
        }
        
        Stack<BSTNode<T>> stack = new Stack<>();
        stack.push(root);
        
        while (!stack.isEmpty()) {
            BSTNode<T> node = stack.pop();
            System.out.print(node.data + " ");
            
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
        }
    }
    
    /**
     * 后序遍历（递归）
     */
    public static <T extends Comparable<T>> void postorderTraversal(BSTNode<T> root) {
        if (root == null) {
            return;
        }
        
        postorderTraversal(root.left);
        postorderTraversal(root.right);
        System.out.print(root.data + " ");
    }
    
    /**
     * 后序遍历（迭代）
     */
    public static <T extends Comparable<T>> void postorderTraversalIterative(BSTNode<T> root) {
        if (root == null) {
            return;
        }
        
        Stack<BSTNode<T>> stack = new Stack<>();
        Stack<BSTNode<T>> output = new Stack<>();
        stack.push(root);
        
        while (!stack.isEmpty()) {
            BSTNode<T> node = stack.pop();
            output.push(node);
            
            if (node.left != null) {
                stack.push(node.left);
            }
            if (node.right != null) {
                stack.push(node.right);
            }
        }
        
        while (!output.isEmpty()) {
            System.out.print(output.pop().data + " ");
        }
    }
    
    /**
     * 层序遍历
     */
    public static <T extends Comparable<T>> void levelOrderTraversal(BSTNode<T> root) {
        if (root == null) {
            return;
        }
        
        Queue<BSTNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            BSTNode<T> node = queue.poll();
            System.out.print(node.data + " ");
            
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }
    
    /**
     * 获取中序遍历结果列表
     */
    public static <T extends Comparable<T>> List<T> inorderToList(BSTNode<T> root) {
        List<T> result = new ArrayList<>();
        inorderToListHelper(root, result);
        return result;
    }
    
    private static <T extends Comparable<T>> void inorderToListHelper(BSTNode<T> root, List<T> result) {
        if (root == null) {
            return;
        }
        inorderToListHelper(root.left, result);
        result.add(root.data);
        inorderToListHelper(root.right, result);
    }
}
```

## 二叉排序树高级操作

```java
/**
 * 二叉排序树高级操作类
 */
public class BSTAdvancedOperations<T extends Comparable<T>> {
    
    /**
     * 查找前驱节点
     */
    public static <T extends Comparable<T>> BSTNode<T> findPredecessor(BSTNode<T> root, T data) {
        BSTNode<T> current = root;
        BSTNode<T> predecessor = null;
        
        while (current != null) {
            if (data.compareTo(current.data) > 0) {
                predecessor = current;
                current = current.right;
            } else {
                current = current.left;
            }
        }
        
        return predecessor;
    }
    
    /**
     * 查找后继节点
     */
    public static <T extends Comparable<T>> BSTNode<T> findSuccessor(BSTNode<T> root, T data) {
        BSTNode<T> current = root;
        BSTNode<T> successor = null;
        
        while (current != null) {
            if (data.compareTo(current.data) < 0) {
                successor = current;
                current = current.left;
            } else {
                current = current.right;
            }
        }
        
        return successor;
    }
    
    /**
     * 查找第k小的元素
     */
    public static <T extends Comparable<T>> T findKthSmallest(BSTNode<T> root, int k) {
        List<T> inorder = BSTTraversal.inorderToList(root);
        if (k > 0 && k <= inorder.size()) {
            return inorder.get(k - 1);
        }
        return null;
    }
    
    /**
     * 查找第k小的元素（优化版本）
     */
    public static <T extends Comparable<T>> T findKthSmallestOptimized(BSTNode<T> root, int k) {
        int[] count = {0};
        return findKthSmallestHelper(root, k, count);
    }
    
    private static <T extends Comparable<T>> T findKthSmallestHelper(BSTNode<T> root, int k, int[] count) {
        if (root == null) {
            return null;
        }
        
        T left = findKthSmallestHelper(root.left, k, count);
        if (left != null) {
            return left;
        }
        
        count[0]++;
        if (count[0] == k) {
            return root.data;
        }
        
        return findKthSmallestHelper(root.right, k, count);
    }
    
    /**
     * 查找第k大的元素
     */
    public static <T extends Comparable<T>> T findKthLargest(BSTNode<T> root, int k) {
        int[] count = {0};
        return findKthLargestHelper(root, k, count);
    }
    
    private static <T extends Comparable<T>> T findKthLargestHelper(BSTNode<T> root, int k, int[] count) {
        if (root == null) {
            return null;
        }
        
        T right = findKthLargestHelper(root.right, k, count);
        if (right != null) {
            return right;
        }
        
        count[0]++;
        if (count[0] == k) {
            return root.data;
        }
        
        return findKthLargestHelper(root.left, k, count);
    }
    
    /**
     * 查找范围查询
     */
    public static <T extends Comparable<T>> List<T> rangeQuery(BSTNode<T> root, T min, T max) {
        List<T> result = new ArrayList<>();
        rangeQueryHelper(root, min, max, result);
        return result;
    }
    
    private static <T extends Comparable<T>> void rangeQueryHelper(BSTNode<T> root, T min, T max, List<T> result) {
        if (root == null) {
            return;
        }
        
        if (root.data.compareTo(min) >= 0 && root.data.compareTo(max) <= 0) {
            result.add(root.data);
        }
        
        if (root.data.compareTo(min) > 0) {
            rangeQueryHelper(root.left, min, max, result);
        }
        
        if (root.data.compareTo(max) < 0) {
            rangeQueryHelper(root.right, min, max, result);
        }
    }
    
    /**
     * 计算树的平衡因子
     */
    public static <T extends Comparable<T>> int getBalanceFactor(BSTNode<T> root) {
        if (root == null) {
            return 0;
        }
        
        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);
        
        return leftHeight - rightHeight;
    }
    
    private static <T extends Comparable<T>> int getHeight(BSTNode<T> node) {
        if (node == null) {
            return 0;
        }
        int leftHeight = getHeight(node.left);
        int rightHeight = getHeight(node.right);
        return Math.max(leftHeight, rightHeight) + 1;
    }
    
    /**
     * 判断是否为平衡树
     */
    public static <T extends Comparable<T>> boolean isBalanced(BSTNode<T> root) {
        return getHeightIfBalanced(root) != -1;
    }
    
    private static <T extends Comparable<T>> int getHeightIfBalanced(BSTNode<T> root) {
        if (root == null) {
            return 0;
        }
        
        int leftHeight = getHeightIfBalanced(root.left);
        if (leftHeight == -1) {
            return -1;
        }
        
        int rightHeight = getHeightIfBalanced(root.right);
        if (rightHeight == -1) {
            return -1;
        }
        
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

## 二叉排序树构建工具

```java
/**
 * 二叉排序树构建工具类
 */
public class BSTBuilder<T extends Comparable<T>> {
    
    /**
     * 从数组构建二叉排序树
     */
    public static <T extends Comparable<T>> BinarySearchTree<T> buildFromArray(T[] array) {
        BinarySearchTree<T> bst = new BinarySearchTree<>();
        for (T data : array) {
            bst.insert(data);
        }
        return bst;
    }
    
    /**
     * 从有序数组构建平衡二叉排序树
     */
    public static <T extends Comparable<T>> BSTNode<T> buildBalancedBST(T[] sortedArray) {
        return buildBalancedBSTHelper(sortedArray, 0, sortedArray.length - 1);
    }
    
    private static <T extends Comparable<T>> BSTNode<T> buildBalancedBSTHelper(T[] array, int start, int end) {
        if (start > end) {
            return null;
        }
        
        int mid = start + (end - start) / 2;
        BSTNode<T> node = new BSTNode<>(array[mid]);
        
        node.left = buildBalancedBSTHelper(array, start, mid - 1);
        node.right = buildBalancedBSTHelper(array, mid + 1, end);
        
        return node;
    }
    
    /**
     * 从有序数组构建平衡二叉排序树（返回BST对象）
     */
    public static <T extends Comparable<T>> BinarySearchTree<T> buildBalancedBSTFromArray(T[] sortedArray) {
        BinarySearchTree<T> bst = new BinarySearchTree<>();
        bst.root = buildBalancedBST(sortedArray);
        return bst;
    }
    
    /**
     * 随机打乱数组
     */
    public static <T> void shuffleArray(T[] array) {
        Random random = new Random();
        for (int i = array.length - 1; i > 0; i--) {
            int j = random.nextInt(i + 1);
            T temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }
    
    /**
     * 生成随机二叉排序树
     */
    public static BinarySearchTree<Integer> generateRandomBST(int size, int maxValue) {
        Integer[] array = new Integer[size];
        Random random = new Random();
        
        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt(maxValue);
        }
        
        return buildFromArray(array);
    }
}
```

## 测试代码

```java
/**
 * 二叉排序树测试类
 */
public class BinarySearchTreeTest {
    public static void main(String[] args) {
        System.out.println("=== 二叉排序树基本操作测试 ===");
        testBasicOperations();
        
        System.out.println("\n=== 二叉排序树遍历测试 ===");
        testTraversal();
        
        System.out.println("\n=== 二叉排序树高级操作测试 ===");
        testAdvancedOperations();
        
        System.out.println("\n=== 二叉排序树构建测试 ===");
        testBSTBuilder();
        
        System.out.println("\n=== 二叉排序树性能测试 ===");
        testPerformance();
    }
    
    /**
     * 测试基本操作
     */
    public static void testBasicOperations() {
        BinarySearchTree<Integer> bst = new BinarySearchTree<>();
        
        // 插入节点
        int[] values = {5, 3, 8, 2, 4, 7, 9, 1, 6};
        for (int value : values) {
            bst.insert(value);
        }
        
        System.out.println("插入后的树高度: " + bst.getHeight());
        System.out.println("节点总数: " + bst.getNodeCount());
        System.out.println("是否为有效BST: " + bst.isValidBST());
        
        // 查找节点
        System.out.println("查找节点4: " + (bst.search(4) != null ? "找到" : "未找到"));
        System.out.println("查找节点10: " + (bst.search(10) != null ? "找到" : "未找到"));
        
        // 查找最小和最大节点
        System.out.println("最小节点: " + bst.findMin().data);
        System.out.println("最大节点: " + bst.findMax().data);
        
        // 删除节点
        bst.delete(3);
        System.out.println("删除节点3后查找: " + (bst.search(3) != null ? "找到" : "未找到"));
        System.out.println("删除后节点总数: " + bst.getNodeCount());
    }
    
    /**
     * 测试遍历
     */
    public static void testTraversal() {
        BinarySearchTree<Integer> bst = new BinarySearchTree<>();
        int[] values = {5, 3, 8, 2, 4, 7, 9, 1, 6};
        for (int value : values) {
            bst.insert(value);
        }
        
        System.out.print("中序遍历（递归）: ");
        BSTTraversal.inorderTraversal(bst.getRoot());
        System.out.println();
        
        System.out.print("中序遍历（迭代）: ");
        BSTTraversal.inorderTraversalIterative(bst.getRoot());
        System.out.println();
        
        System.out.print("前序遍历: ");
        BSTTraversal.preorderTraversal(bst.getRoot());
        System.out.println();
        
        System.out.print("后序遍历: ");
        BSTTraversal.postorderTraversal(bst.getRoot());
        System.out.println();
        
        System.out.print("层序遍历: ");
        BSTTraversal.levelOrderTraversal(bst.getRoot());
        System.out.println();
    }
    
    /**
     * 测试高级操作
     */
    public static void testAdvancedOperations() {
        BinarySearchTree<Integer> bst = new BinarySearchTree<>();
        int[] values = {5, 3, 8, 2, 4, 7, 9, 1, 6};
        for (int value : values) {
            bst.insert(value);
        }
        
        // 查找前驱和后继
        BSTNode<Integer> predecessor = BSTAdvancedOperations.findPredecessor(bst.getRoot(), 5);
        System.out.println("节点5的前驱: " + (predecessor != null ? predecessor.data : "null"));
        
        BSTNode<Integer> successor = BSTAdvancedOperations.findSuccessor(bst.getRoot(), 5);
        System.out.println("节点5的后继: " + (successor != null ? successor.data : "null"));
        
        // 查找第k小的元素
        System.out.println("第3小的元素: " + BSTAdvancedOperations.findKthSmallest(bst.getRoot(), 3));
        System.out.println("第3小的元素（优化）: " + BSTAdvancedOperations.findKthSmallestOptimized(bst.getRoot(), 3));
        
        // 查找第k大的元素
        System.out.println("第2大的元素: " + BSTAdvancedOperations.findKthLargest(bst.getRoot(), 2));
        
        // 范围查询
        List<Integer> rangeResult = BSTAdvancedOperations.rangeQuery(bst.getRoot(), 3, 7);
        System.out.println("范围查询[3,7]: " + rangeResult);
        
        // 平衡性检查
        System.out.println("平衡因子: " + BSTAdvancedOperations.getBalanceFactor(bst.getRoot()));
        System.out.println("是否为平衡树: " + BSTAdvancedOperations.isBalanced(bst.getRoot()));
    }
    
    /**
     * 测试BST构建
     */
    public static void testBSTBuilder() {
        Integer[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        
        // 从数组构建BST
        BinarySearchTree<Integer> bst1 = BSTBuilder.buildFromArray(array);
        System.out.println("从数组构建的BST高度: " + bst1.getHeight());
        
        // 构建平衡BST
        BinarySearchTree<Integer> bst2 = BSTBuilder.buildBalancedBSTFromArray(array);
        System.out.println("平衡BST高度: " + bst2.getHeight());
        
        // 生成随机BST
        BinarySearchTree<Integer> randomBST = BSTBuilder.generateRandomBST(10, 100);
        System.out.println("随机BST高度: " + randomBST.getHeight());
        System.out.println("随机BST节点数: " + randomBST.getNodeCount());
    }
    
    /**
     * 测试性能
     */
    public static void testPerformance() {
        int[] sizes = {1000, 5000, 10000};
        
        for (int size : sizes) {
            System.out.println("\n测试规模: " + size);
            
            // 测试插入性能
            long startTime = System.nanoTime();
            BinarySearchTree<Integer> bst = new BinarySearchTree<>();
            for (int i = 0; i < size; i++) {
                bst.insert(i);
            }
            long endTime = System.nanoTime();
            System.out.println("插入时间: " + (endTime - startTime) + " ns");
            
            // 测试查找性能
            startTime = System.nanoTime();
            for (int i = 0; i < size; i++) {
                bst.search(i);
            }
            endTime = System.nanoTime();
            System.out.println("查找时间: " + (endTime - startTime) + " ns");
            
            System.out.println("树高度: " + bst.getHeight());
            System.out.println("是否为平衡树: " + BSTAdvancedOperations.isBalanced(bst.getRoot()));
        }
    }
}
```
