# 13.3.6. 最优二叉树 - Java代码示例

## 哈夫曼节点定义

```java
/**
 * 哈夫曼树节点类
 */
public class HuffmanNode implements Comparable<HuffmanNode> {
    public char data;
    public int frequency;
    public HuffmanNode left;
    public HuffmanNode right;
    
    public HuffmanNode(char data, int frequency) {
        this.data = data;
        this.frequency = frequency;
        this.left = null;
        this.right = null;
    }
    
    public HuffmanNode(int frequency, HuffmanNode left, HuffmanNode right) {
        this.data = '\0'; // 内部节点没有字符数据
        this.frequency = frequency;
        this.left = left;
        this.right = right;
    }
    
    /**
     * 判断是否为叶子节点
     */
    public boolean isLeaf() {
        return left == null && right == null;
    }
    
    @Override
    public int compareTo(HuffmanNode other) {
        return this.frequency - other.frequency;
    }
    
    @Override
    public String toString() {
        return "Node{" + data + ":" + frequency + "}";
    }
}
```

## 哈夫曼树实现

```java
import java.util.*;

/**
 * 哈夫曼树实现类
 */
public class HuffmanTree {
    private HuffmanNode root;
    private Map<Character, String> encodingTable;
    private Map<String, Character> decodingTable;
    
    public HuffmanTree() {
        this.root = null;
        this.encodingTable = new HashMap<>();
        this.decodingTable = new HashMap<>();
    }
    
    /**
     * 构建哈夫曼树
     */
    public void buildTree(Map<Character, Integer> frequencies) {
        if (frequencies == null || frequencies.isEmpty()) {
            throw new IllegalArgumentException("频率表不能为空");
        }
        
        // 创建优先队列（最小堆）
        PriorityQueue<HuffmanNode> minHeap = new PriorityQueue<>();
        
        // 为每个字符创建叶子节点
        for (Map.Entry<Character, Integer> entry : frequencies.entrySet()) {
            HuffmanNode node = new HuffmanNode(entry.getKey(), entry.getValue());
            minHeap.offer(node);
        }
        
        // 构建哈夫曼树
        while (minHeap.size() > 1) {
            HuffmanNode left = minHeap.poll();
            HuffmanNode right = minHeap.poll();
            
            // 创建新的内部节点
            HuffmanNode merged = new HuffmanNode(
                left.frequency + right.frequency, left, right
            );
            
            minHeap.offer(merged);
        }
        
        // 设置根节点
        this.root = minHeap.poll();
        
        // 生成编码表
        generateEncodingTable();
    }
    
    /**
     * 从字符串构建哈夫曼树
     */
    public void buildTreeFromString(String text) {
        if (text == null || text.isEmpty()) {
            throw new IllegalArgumentException("输入字符串不能为空");
        }
        
        // 统计字符频率
        Map<Character, Integer> frequencies = new HashMap<>();
        for (char c : text.toCharArray()) {
            frequencies.put(c, frequencies.getOrDefault(c, 0) + 1);
        }
        
        buildTree(frequencies);
    }
    
    /**
     * 生成编码表
     */
    private void generateEncodingTable() {
        encodingTable.clear();
        decodingTable.clear();
        
        if (root == null) {
            return;
        }
        
        // 如果只有一个节点（只有一个字符）
        if (root.isLeaf()) {
            encodingTable.put(root.data, "0");
            decodingTable.put("0", root.data);
            return;
        }
        
        // 递归生成编码
        generateCodes(root, "");
    }
    
    /**
     * 递归生成编码
     */
    private void generateCodes(HuffmanNode node, String code) {
        if (node.isLeaf()) {
            encodingTable.put(node.data, code);
            decodingTable.put(code, node.data);
            return;
        }
        
        if (node.left != null) {
            generateCodes(node.left, code + "0");
        }
        
        if (node.right != null) {
            generateCodes(node.right, code + "1");
        }
    }
    
    /**
     * 编码字符串
     */
    public String encode(String text) {
        if (text == null || text.isEmpty()) {
            return "";
        }
        
        StringBuilder encoded = new StringBuilder();
        for (char c : text.toCharArray()) {
            String code = encodingTable.get(c);
            if (code == null) {
                throw new IllegalArgumentException("字符 '" + c + "' 不在编码表中");
            }
            encoded.append(code);
        }
        
        return encoded.toString();
    }
    
    /**
     * 解码字符串
     */
    public String decode(String encodedText) {
        if (encodedText == null || encodedText.isEmpty()) {
            return "";
        }
        
        StringBuilder decoded = new StringBuilder();
        StringBuilder currentCode = new StringBuilder();
        
        for (char bit : encodedText.toCharArray()) {
            currentCode.append(bit);
            
            Character character = decodingTable.get(currentCode.toString());
            if (character != null) {
                decoded.append(character);
                currentCode.setLength(0); // 清空当前编码
            }
        }
        
        if (currentCode.length() > 0) {
            throw new IllegalArgumentException("无法解码的编码: " + currentCode.toString());
        }
        
        return decoded.toString();
    }
    
    /**
     * 使用树结构解码
     */
    public String decodeUsingTree(String encodedText) {
        if (encodedText == null || encodedText.isEmpty() || root == null) {
            return "";
        }
        
        StringBuilder decoded = new StringBuilder();
        HuffmanNode current = root;
        
        for (char bit : encodedText.toCharArray()) {
            if (bit == '0') {
                current = current.left;
            } else if (bit == '1') {
                current = current.right;
            } else {
                throw new IllegalArgumentException("无效的编码字符: " + bit);
            }
            
            if (current.isLeaf()) {
                decoded.append(current.data);
                current = root; // 重置到根节点
            }
        }
        
        return decoded.toString();
    }
    
    /**
     * 获取编码表
     */
    public Map<Character, String> getEncodingTable() {
        return new HashMap<>(encodingTable);
    }
    
    /**
     * 获取解码表
     */
    public Map<String, Character> getDecodingTable() {
        return new HashMap<>(decodingTable);
    }
    
    /**
     * 计算压缩比
     */
    public double getCompressionRatio(String originalText) {
        if (originalText == null || originalText.isEmpty()) {
            return 0.0;
        }
        
        String encoded = encode(originalText);
        int originalBits = originalText.length() * 8; // 假设每个字符8位
        int compressedBits = encoded.length();
        
        return (double) compressedBits / originalBits;
    }
    
    /**
     * 计算平均编码长度
     */
    public double getAverageCodeLength(Map<Character, Integer> frequencies) {
        if (frequencies == null || frequencies.isEmpty()) {
            return 0.0;
        }
        
        int totalFrequency = frequencies.values().stream().mapToInt(Integer::intValue).sum();
        double weightedSum = 0.0;
        
        for (Map.Entry<Character, Integer> entry : frequencies.entrySet()) {
            String code = encodingTable.get(entry.getKey());
            if (code != null) {
                weightedSum += code.length() * entry.getValue();
            }
        }
        
        return weightedSum / totalFrequency;
    }
    
    /**
     * 打印哈夫曼树结构
     */
    public void printTree() {
        if (root == null) {
            System.out.println("树为空");
            return;
        }
        
        System.out.println("哈夫曼树结构:");
        printTreeHelper(root, "", true);
    }
    
    private void printTreeHelper(HuffmanNode node, String prefix, boolean isLast) {
        System.out.println(prefix + (isLast ? "└── " : "├── ") + node);
        
        if (node.left != null) {
            printTreeHelper(node.left, prefix + (isLast ? "    " : "│   "), node.right == null);
        }
        
        if (node.right != null) {
            printTreeHelper(node.right, prefix + (isLast ? "    " : "│   "), true);
        }
    }
    
    /**
     * 打印编码表
     */
    public void printEncodingTable() {
        System.out.println("编码表:");
        for (Map.Entry<Character, String> entry : encodingTable.entrySet()) {
            System.out.println("'" + entry.getKey() + "' -> " + entry.getValue());
        }
    }
    
    /**
     * 获取树的带权路径长度
     */
    public int getWeightedPathLength() {
        return getWeightedPathLengthHelper(root, 0);
    }
    
    private int getWeightedPathLengthHelper(HuffmanNode node, int depth) {
        if (node == null) {
            return 0;
        }
        
        if (node.isLeaf()) {
            return node.frequency * depth;
        }
        
        return getWeightedPathLengthHelper(node.left, depth + 1) +
               getWeightedPathLengthHelper(node.right, depth + 1);
    }
}
```

## 哈夫曼编码工具类

```java
/**
 * 哈夫曼编码工具类
 */
public class HuffmanCodingUtils {
    
    /**
     * 分析文本字符频率
     */
    public static Map<Character, Integer> analyzeFrequency(String text) {
        Map<Character, Integer> frequencies = new HashMap<>();
        
        for (char c : text.toCharArray()) {
            frequencies.put(c, frequencies.getOrDefault(c, 0) + 1);
        }
        
        return frequencies;
    }
    
    /**
     * 按频率排序字符
     */
    public static List<Map.Entry<Character, Integer>> sortByFrequency(
            Map<Character, Integer> frequencies) {
        List<Map.Entry<Character, Integer>> sorted = new ArrayList<>(frequencies.entrySet());
        sorted.sort((a, b) -> b.getValue().compareTo(a.getValue()));
        return sorted;
    }
    
    /**
     * 计算信息熵
     */
    public static double calculateEntropy(Map<Character, Integer> frequencies) {
        int totalCount = frequencies.values().stream().mapToInt(Integer::intValue).sum();
        double entropy = 0.0;
        
        for (int count : frequencies.values()) {
            double probability = (double) count / totalCount;
            if (probability > 0) {
                entropy -= probability * Math.log(probability) / Math.log(2);
            }
        }
        
        return entropy;
    }
    
    /**
     * 计算理论最小编码长度
     */
    public static double calculateMinCodeLength(Map<Character, Integer> frequencies) {
        return calculateEntropy(frequencies);
    }
    
    /**
     * 比较不同编码方法的效率
     */
    public static void compareEncodingMethods(String text) {
        System.out.println("文本: " + text);
        System.out.println("文本长度: " + text.length() + " 字符");
        
        // 分析频率
        Map<Character, Integer> frequencies = analyzeFrequency(text);
        System.out.println("字符频率: " + frequencies);
        
        // 计算信息熵
        double entropy = calculateEntropy(frequencies);
        System.out.println("信息熵: " + String.format("%.2f", entropy) + " bits/字符");
        
        // 构建哈夫曼树
        HuffmanTree huffmanTree = new HuffmanTree();
        huffmanTree.buildTree(frequencies);
        
        // 计算压缩比
        double compressionRatio = huffmanTree.getCompressionRatio(text);
        System.out.println("压缩比: " + String.format("%.2f", compressionRatio * 100) + "%");
        
        // 计算平均编码长度
        double avgCodeLength = huffmanTree.getAverageCodeLength(frequencies);
        System.out.println("平均编码长度: " + String.format("%.2f", avgCodeLength) + " bits/字符");
        
        // 计算带权路径长度
        int wpl = huffmanTree.getWeightedPathLength();
        System.out.println("带权路径长度: " + wpl);
        
        System.out.println();
    }
    
    /**
     * 生成随机文本用于测试
     */
    public static String generateRandomText(int length, String characters) {
        Random random = new Random();
        StringBuilder text = new StringBuilder();
        
        for (int i = 0; i < length; i++) {
            int index = random.nextInt(characters.length());
            text.append(characters.charAt(index));
        }
        
        return text.toString();
    }
    
    /**
     * 验证编码解码的正确性
     */
    public static boolean verifyEncodingDecoding(String originalText) {
        HuffmanTree tree = new HuffmanTree();
        tree.buildTreeFromString(originalText);
        
        String encoded = tree.encode(originalText);
        String decoded = tree.decode(encoded);
        
        return originalText.equals(decoded);
    }
}
```

## 测试代码

```java
/**
 * 哈夫曼树测试类
 */
public class HuffmanTreeTest {
    public static void main(String[] args) {
        System.out.println("=== 哈夫曼树基本功能测试 ===");
        testBasicFunctionality();
        
        System.out.println("\n=== 哈夫曼树编码解码测试 ===");
        testEncodingDecoding();
        
        System.out.println("\n=== 哈夫曼树性能测试 ===");
        testPerformance();
        
        System.out.println("\n=== 哈夫曼树应用场景测试 ===");
        testApplicationScenarios();
        
        System.out.println("\n=== 哈夫曼树边界情况测试 ===");
        testEdgeCases();
    }
    
    /**
     * 测试基本功能
     */
    public static void testBasicFunctionality() {
        // 测试用例1：简单字符串
        String text1 = "hello";
        HuffmanTree tree1 = new HuffmanTree();
        tree1.buildTreeFromString(text1);
        
        System.out.println("测试文本: " + text1);
        tree1.printTree();
        tree1.printEncodingTable();
        
        // 测试用例2：重复字符
        String text2 = "aaaaabbbbcccdde";
        HuffmanTree tree2 = new HuffmanTree();
        tree2.buildTreeFromString(text2);
        
        System.out.println("\n测试文本: " + text2);
        tree2.printTree();
        tree2.printEncodingTable();
        
        // 测试用例3：单字符
        String text3 = "aaaaaaaaaa";
        HuffmanTree tree3 = new HuffmanTree();
        tree3.buildTreeFromString(text3);
        
        System.out.println("\n测试文本: " + text3);
        tree3.printTree();
        tree3.printEncodingTable();
    }
    
    /**
     * 测试编码解码
     */
    public static void testEncodingDecoding() {
        String[] testTexts = {
            "hello world",
            "abcdefghijklmnopqrstuvwxyz",
            "the quick brown fox jumps over the lazy dog",
            "aaaaaaaaaabbbbbbbbbbcccccccccc"
        };
        
        for (String text : testTexts) {
            System.out.println("测试文本: " + text);
            
            HuffmanTree tree = new HuffmanTree();
            tree.buildTreeFromString(text);
            
            // 编码
            String encoded = tree.encode(text);
            System.out.println("编码结果: " + encoded);
            
            // 解码
            String decoded = tree.decode(encoded);
            System.out.println("解码结果: " + decoded);
            
            // 验证
            boolean isCorrect = text.equals(decoded);
            System.out.println("编码解码正确: " + isCorrect);
            
            // 压缩比
            double compressionRatio = tree.getCompressionRatio(text);
            System.out.println("压缩比: " + String.format("%.2f", compressionRatio * 100) + "%");
            
            System.out.println();
        }
    }
    
    /**
     * 测试性能
     */
    public static void testPerformance() {
        // 测试不同长度的文本
        int[] lengths = {100, 1000, 10000};
        
        for (int length : lengths) {
            String text = HuffmanCodingUtils.generateRandomText(length, "abcdefghijklmnopqrstuvwxyz");
            
            long startTime = System.nanoTime();
            HuffmanTree tree = new HuffmanTree();
            tree.buildTreeFromString(text);
            long buildTime = System.nanoTime() - startTime;
            
            startTime = System.nanoTime();
            String encoded = tree.encode(text);
            long encodeTime = System.nanoTime() - startTime;
            
            startTime = System.nanoTime();
            String decoded = tree.decode(encoded);
            long decodeTime = System.nanoTime() - startTime;
            
            System.out.println("文本长度: " + length);
            System.out.println("构建时间: " + buildTime + " ns");
            System.out.println("编码时间: " + encodeTime + " ns");
            System.out.println("解码时间: " + decodeTime + " ns");
            System.out.println("压缩比: " + String.format("%.2f", tree.getCompressionRatio(text) * 100) + "%");
            System.out.println();
        }
    }
    
    /**
     * 测试应用场景
     */
    public static void testApplicationScenarios() {
        // 场景1：英文文本
        String englishText = "The quick brown fox jumps over the lazy dog. " +
                           "This is a test of Huffman coding algorithm.";
        HuffmanCodingUtils.compareEncodingMethods(englishText);
        
        // 场景2：重复字符
        String repeatedText = "aaaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeee";
        HuffmanCodingUtils.compareEncodingMethods(repeatedText);
        
        // 场景3：随机字符
        String randomText = HuffmanCodingUtils.generateRandomText(100, "abcdefghijklmnopqrstuvwxyz");
        HuffmanCodingUtils.compareEncodingMethods(randomText);
        
        // 场景4：数字文本
        String numberText = "1234567890123456789012345678901234567890";
        HuffmanCodingUtils.compareEncodingMethods(numberText);
    }
    
    /**
     * 测试边界情况
     */
    public static void testEdgeCases() {
        // 测试空字符串
        try {
            HuffmanTree tree = new HuffmanTree();
            tree.buildTreeFromString("");
            System.out.println("空字符串测试: 应该抛出异常");
        } catch (IllegalArgumentException e) {
            System.out.println("空字符串测试: 正确抛出异常 - " + e.getMessage());
        }
        
        // 测试null字符串
        try {
            HuffmanTree tree = new HuffmanTree();
            tree.buildTreeFromString(null);
            System.out.println("null字符串测试: 应该抛出异常");
        } catch (IllegalArgumentException e) {
            System.out.println("null字符串测试: 正确抛出异常 - " + e.getMessage());
        }
        
        // 测试单字符
        String singleChar = "a";
        HuffmanTree tree = new HuffmanTree();
        tree.buildTreeFromString(singleChar);
        String encoded = tree.encode(singleChar);
        String decoded = tree.decode(encoded);
        System.out.println("单字符测试: " + singleChar + " -> " + encoded + " -> " + decoded);
        
        // 测试两个相同字符
        String twoChars = "aa";
        tree.buildTreeFromString(twoChars);
        encoded = tree.encode(twoChars);
        decoded = tree.decode(encoded);
        System.out.println("两字符测试: " + twoChars + " -> " + encoded + " -> " + decoded);
        
        // 测试验证编码解码正确性
        String[] testTexts = {
            "hello",
            "world",
            "test",
            "huffman",
            "coding"
        };
        
        for (String text : testTexts) {
            boolean isCorrect = HuffmanCodingUtils.verifyEncodingDecoding(text);
            System.out.println("验证测试 '" + text + "': " + (isCorrect ? "通过" : "失败"));
        }
    }
}
```

## 高级功能实现

```java
/**
 * 高级哈夫曼树功能
 */
public class AdvancedHuffmanTree extends HuffmanTree {
    
    /**
     * 自适应哈夫曼树（简化版）
     */
    public static class AdaptiveHuffmanTree {
        private Map<Character, Integer> frequencies;
        private HuffmanTree currentTree;
        
        public AdaptiveHuffmanTree() {
            this.frequencies = new HashMap<>();
            this.currentTree = new HuffmanTree();
        }
        
        /**
         * 添加字符并更新树
         */
        public void addCharacter(char c) {
            frequencies.put(c, frequencies.getOrDefault(c, 0) + 1);
            currentTree.buildTree(frequencies);
        }
        
        /**
         * 编码字符
         */
        public String encodeCharacter(char c) {
            return currentTree.encode(String.valueOf(c));
        }
        
        /**
         * 获取当前编码表
         */
        public Map<Character, String> getCurrentEncodingTable() {
            return currentTree.getEncodingTable();
        }
    }
    
    /**
     * 多叉哈夫曼树
     */
    public static class MultiwayHuffmanTree {
        private int arity; // 叉数
        private Map<Character, Integer> frequencies;
        
        public MultiwayHuffmanTree(int arity) {
            this.arity = arity;
            this.frequencies = new HashMap<>();
        }
        
        /**
         * 构建多叉哈夫曼树
         */
        public void buildTree(Map<Character, Integer> frequencies) {
            this.frequencies = new HashMap<>(frequencies);
            // 实现多叉哈夫曼树构建算法
            // 这里简化实现，实际需要更复杂的算法
        }
        
        /**
         * 获取叉数
         */
        public int getArity() {
            return arity;
        }
    }
    
    /**
     * 哈夫曼树分析器
     */
    public static class HuffmanTreeAnalyzer {
        
        /**
         * 分析树的平衡性
         */
        public static double analyzeBalance(HuffmanTree tree) {
            // 实现平衡性分析
            return 0.0; // 简化实现
        }
        
        /**
         * 分析编码效率
         */
        public static double analyzeEfficiency(HuffmanTree tree, Map<Character, Integer> frequencies) {
            double entropy = HuffmanCodingUtils.calculateEntropy(frequencies);
            double avgCodeLength = tree.getAverageCodeLength(frequencies);
            
            return entropy / avgCodeLength; // 效率 = 理论最小值 / 实际值
        }
        
        /**
         * 生成压缩报告
         */
        public static void generateCompressionReport(String text) {
            System.out.println("=== 压缩报告 ===");
            System.out.println("原始文本: " + text);
            System.out.println("文本长度: " + text.length() + " 字符");
            
            Map<Character, Integer> frequencies = HuffmanCodingUtils.analyzeFrequency(text);
            HuffmanTree tree = new HuffmanTree();
            tree.buildTree(frequencies);
            
            String encoded = tree.encode(text);
            System.out.println("编码长度: " + encoded.length() + " bits");
            System.out.println("压缩比: " + String.format("%.2f", tree.getCompressionRatio(text) * 100) + "%");
            
            double efficiency = analyzeEfficiency(tree, frequencies);
            System.out.println("编码效率: " + String.format("%.2f", efficiency * 100) + "%");
            
            System.out.println("带权路径长度: " + tree.getWeightedPathLength());
            System.out.println("平均编码长度: " + String.format("%.2f", tree.getAverageCodeLength(frequencies)) + " bits/字符");
        }
    }
}
```
