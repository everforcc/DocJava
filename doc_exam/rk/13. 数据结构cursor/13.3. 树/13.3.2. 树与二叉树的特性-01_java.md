# 13.3.2. 树与二叉树的特性-01 - Java代码示例

## 树节点定义

```java
/**
 * 树节点类
 */
public class TreeNode<T> {
    public T data;
    public TreeNode<T> left;
    public TreeNode<T> right;
    
    public TreeNode(T data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
    
    public TreeNode(T data, TreeNode<T> left, TreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
    
    @Override
    public String toString() {
        return data.toString();
    }
}
```

## 树特性分析类

```java
/**
 * 树特性分析类
 */
public class TreeProperties {
    
    /**
     * 计算树的高度
     */
    public static <T> int getHeight(TreeNode<T> root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);
        return Math.max(leftHeight, rightHeight) + 1;
    }
    
    /**
     * 计算树的节点总数
     */
    public static <T> int getNodeCount(TreeNode<T> root) {
        if (root == null) {
            return 0;
        }
        return 1 + getNodeCount(root.left) + getNodeCount(root.right);
    }
    
    /**
     * 计算叶子节点数
     */
    public static <T> int getLeafCount(TreeNode<T> root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }
        return getLeafCount(root.left) + getLeafCount(root.right);
    }
    
    /**
     * 计算度为2的节点数
     */
    public static <T> int getDegreeTwoCount(TreeNode<T> root) {
        if (root == null) {
            return 0;
        }
        int count = 0;
        if (root.left != null && root.right != null) {
            count = 1;
        }
        return count + getDegreeTwoCount(root.left) + getDegreeTwoCount(root.right);
    }
    
    /**
     * 验证叶子节点数 = 度为2的节点数 + 1
     */
    public static <T> boolean verifyLeafDegreeRelation(TreeNode<T> root) {
        int leafCount = getLeafCount(root);
        int degreeTwoCount = getDegreeTwoCount(root);
        return leafCount == degreeTwoCount + 1;
    }
    
    /**
     * 计算第k层节点数
     */
    public static <T> int getNodesAtLevel(TreeNode<T> root, int level) {
        if (root == null) {
            return 0;
        }
        if (level == 1) {
            return 1;
        }
        return getNodesAtLevel(root.left, level - 1) + getNodesAtLevel(root.right, level - 1);
    }
    
    /**
     * 判断是否为满二叉树
     */
    public static <T> boolean isFullBinaryTree(TreeNode<T> root) {
        if (root == null) {
            return true;
        }
        
        // 叶子节点
        if (root.left == null && root.right == null) {
            return true;
        }
        
        // 内部节点必须有两个子节点
        if (root.left != null && root.right != null) {
            return isFullBinaryTree(root.left) && isFullBinaryTree(root.right);
        }
        
        return false;
    }
    
    /**
     * 判断是否为完全二叉树
     */
    public static <T> boolean isCompleteBinaryTree(TreeNode<T> root) {
        if (root == null) {
            return true;
        }
        
        Queue<TreeNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        boolean foundNull = false;
        
        while (!queue.isEmpty()) {
            TreeNode<T> node = queue.poll();
            
            if (node == null) {
                foundNull = true;
            } else {
                if (foundNull) {
                    return false; // 在null节点之后又发现了非null节点
                }
                queue.offer(node.left);
                queue.offer(node.right);
            }
        }
        
        return true;
    }
    
    /**
     * 判断是否为平衡二叉树
     */
    public static <T> boolean isBalanced(TreeNode<T> root) {
        return getHeightIfBalanced(root) != -1;
    }
    
    private static <T> int getHeightIfBalanced(TreeNode<T> root) {
        if (root == null) {
            return 0;
        }
        
        int leftHeight = getHeightIfBalanced(root.left);
        if (leftHeight == -1) {
            return -1;
        }
        
        int rightHeight = getHeightIfBalanced(root.right);
        if (rightHeight == -1) {
            return -1;
        }
        
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        
        return Math.max(leftHeight, rightHeight) + 1;
    }
    
    /**
     * 获取树的最大宽度
     */
    public static <T> int getMaxWidth(TreeNode<T> root) {
        if (root == null) {
            return 0;
        }
        
        Queue<TreeNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        int maxWidth = 0;
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            maxWidth = Math.max(maxWidth, levelSize);
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode<T> node = queue.poll();
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }
        
        return maxWidth;
    }
    
    /**
     * 计算树的直径（任意两个节点之间的最长路径）
     */
    public static <T> int getDiameter(TreeNode<T> root) {
        int[] diameter = new int[1];
        getHeightForDiameter(root, diameter);
        return diameter[0];
    }
    
    private static <T> int getHeightForDiameter(TreeNode<T> root, int[] diameter) {
        if (root == null) {
            return 0;
        }
        
        int leftHeight = getHeightForDiameter(root.left, diameter);
        int rightHeight = getHeightForDiameter(root.right, diameter);
        
        diameter[0] = Math.max(diameter[0], leftHeight + rightHeight);
        
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

## 二叉树构建工具

```java
/**
 * 二叉树构建工具类
 */
public class BinaryTreeBuilder {
    
    /**
     * 根据数组构建完全二叉树
     */
    public static <T> TreeNode<T> buildCompleteBinaryTree(T[] array) {
        if (array == null || array.length == 0) {
            return null;
        }
        
        TreeNode<T> root = new TreeNode<>(array[0]);
        Queue<TreeNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        
        for (int i = 1; i < array.length; i += 2) {
            TreeNode<T> parent = queue.poll();
            
            if (i < array.length) {
                parent.left = new TreeNode<>(array[i]);
                queue.offer(parent.left);
            }
            
            if (i + 1 < array.length) {
                parent.right = new TreeNode<>(array[i + 1]);
                queue.offer(parent.right);
            }
        }
        
        return root;
    }
    
    /**
     * 构建满二叉树
     */
    public static TreeNode<Integer> buildFullBinaryTree(int levels) {
        if (levels <= 0) {
            return null;
        }
        
        return buildFullBinaryTreeHelper(1, levels);
    }
    
    private static TreeNode<Integer> buildFullBinaryTreeHelper(int value, int levels) {
        if (levels == 0) {
            return null;
        }
        
        TreeNode<Integer> node = new TreeNode<>(value);
        node.left = buildFullBinaryTreeHelper(value * 2, levels - 1);
        node.right = buildFullBinaryTreeHelper(value * 2 + 1, levels - 1);
        
        return node;
    }
    
    /**
     * 构建平衡二叉树
     */
    public static TreeNode<Integer> buildBalancedBinaryTree(int[] sortedArray) {
        if (sortedArray == null || sortedArray.length == 0) {
            return null;
        }
        
        return buildBalancedBinaryTreeHelper(sortedArray, 0, sortedArray.length - 1);
    }
    
    private static TreeNode<Integer> buildBalancedBinaryTreeHelper(int[] array, int start, int end) {
        if (start > end) {
            return null;
        }
        
        int mid = start + (end - start) / 2;
        TreeNode<Integer> node = new TreeNode<>(array[mid]);
        
        node.left = buildBalancedBinaryTreeHelper(array, start, mid - 1);
        node.right = buildBalancedBinaryTreeHelper(array, mid + 1, end);
        
        return node;
    }
    
    /**
     * 构建链式二叉树（最不平衡）
     */
    public static TreeNode<Integer> buildLinkedListTree(int n) {
        if (n <= 0) {
            return null;
        }
        
        TreeNode<Integer> root = new TreeNode<>(1);
        TreeNode<Integer> current = root;
        
        for (int i = 2; i <= n; i++) {
            current.right = new TreeNode<>(i);
            current = current.right;
        }
        
        return root;
    }
}
```

## 树结构验证类

```java
/**
 * 树结构验证类
 */
public class TreeValidator {
    
    /**
     * 验证树的基本性质
     */
    public static <T> void validateTreeProperties(TreeNode<T> root) {
        System.out.println("=== 树的基本性质验证 ===");
        
        int nodeCount = TreeProperties.getNodeCount(root);
        int leafCount = TreeProperties.getLeafCount(root);
        int degreeTwoCount = TreeProperties.getDegreeTwoCount(root);
        int height = TreeProperties.getHeight(root);
        
        System.out.println("节点总数: " + nodeCount);
        System.out.println("叶子节点数: " + leafCount);
        System.out.println("度为2的节点数: " + degreeTwoCount);
        System.out.println("树的高度: " + height);
        
        // 验证叶子节点数 = 度为2的节点数 + 1
        boolean leafDegreeValid = TreeProperties.verifyLeafDegreeRelation(root);
        System.out.println("叶子节点数 = 度为2的节点数 + 1: " + leafDegreeValid);
        
        // 验证边数 = 节点数 - 1
        int edgeCount = nodeCount - 1;
        System.out.println("边数: " + edgeCount);
        System.out.println("边数 = 节点数 - 1: " + (edgeCount == nodeCount - 1));
    }
    
    /**
     * 验证特殊二叉树类型
     */
    public static <T> void validateSpecialTrees(TreeNode<T> root) {
        System.out.println("\n=== 特殊二叉树类型验证 ===");
        
        boolean isFull = TreeProperties.isFullBinaryTree(root);
        boolean isComplete = TreeProperties.isCompleteBinaryTree(root);
        boolean isBalanced = TreeProperties.isBalanced(root);
        
        System.out.println("是否为满二叉树: " + isFull);
        System.out.println("是否为完全二叉树: " + isComplete);
        System.out.println("是否为平衡二叉树: " + isBalanced);
    }
    
    /**
     * 分析树的层次结构
     */
    public static <T> void analyzeTreeLevels(TreeNode<T> root) {
        System.out.println("\n=== 树的层次结构分析 ===");
        
        int height = TreeProperties.getHeight(root);
        System.out.println("树的高度: " + height);
        
        for (int level = 1; level <= height; level++) {
            int nodesAtLevel = TreeProperties.getNodesAtLevel(root, level);
            int maxNodesAtLevel = (int) Math.pow(2, level - 1);
            System.out.printf("第%d层: %d个节点 (最多%d个)%n", level, nodesAtLevel, maxNodesAtLevel);
        }
        
        int maxWidth = TreeProperties.getMaxWidth(root);
        System.out.println("树的最大宽度: " + maxWidth);
    }
    
    /**
     * 分析树的路径特性
     */
    public static <T> void analyzeTreePaths(TreeNode<T> root) {
        System.out.println("\n=== 树的路径特性分析 ===");
        
        int diameter = TreeProperties.getDiameter(root);
        System.out.println("树的直径: " + diameter);
        
        // 计算从根到叶子的最长路径
        int maxPathFromRoot = TreeProperties.getHeight(root) - 1;
        System.out.println("从根到叶子的最长路径: " + maxPathFromRoot);
    }
}
```

## 树可视化工具

```java
/**
 * 树可视化工具类
 */
public class TreeVisualizer {
    
    /**
     * 打印树的结构
     */
    public static <T> void printTree(TreeNode<T> root) {
        if (root == null) {
            System.out.println("空树");
            return;
        }
        
        System.out.println("=== 树结构可视化 ===");
        printTreeHelper(root, "", true);
    }
    
    private static <T> void printTreeHelper(TreeNode<T> node, String prefix, boolean isLast) {
        System.out.println(prefix + (isLast ? "└── " : "├── ") + node.data);
        
        List<TreeNode<T>> children = new ArrayList<>();
        if (node.left != null) children.add(node.left);
        if (node.right != null) children.add(node.right);
        
        for (int i = 0; i < children.size(); i++) {
            boolean isLastChild = (i == children.size() - 1);
            String newPrefix = prefix + (isLast ? "    " : "│   ");
            printTreeHelper(children.get(i), newPrefix, isLastChild);
        }
    }
    
    /**
     * 按层次打印树
     */
    public static <T> void printTreeByLevel(TreeNode<T> root) {
        if (root == null) {
            System.out.println("空树");
            return;
        }
        
        System.out.println("=== 按层次打印树 ===");
        Queue<TreeNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        int level = 0;
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            System.out.print("第" + level + "层: ");
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode<T> node = queue.poll();
                System.out.print(node.data + " ");
                
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            System.out.println();
            level++;
        }
    }
    
    /**
     * 打印树的统计信息
     */
    public static <T> void printTreeStatistics(TreeNode<T> root) {
        if (root == null) {
            System.out.println("空树");
            return;
        }
        
        System.out.println("=== 树统计信息 ===");
        System.out.println("节点总数: " + TreeProperties.getNodeCount(root));
        System.out.println("叶子节点数: " + TreeProperties.getLeafCount(root));
        System.out.println("度为2的节点数: " + TreeProperties.getDegreeTwoCount(root));
        System.out.println("树的高度: " + TreeProperties.getHeight(root));
        System.out.println("最大宽度: " + TreeProperties.getMaxWidth(root));
        System.out.println("树的直径: " + TreeProperties.getDiameter(root));
        
        System.out.println("\n特殊二叉树类型:");
        System.out.println("满二叉树: " + TreeProperties.isFullBinaryTree(root));
        System.out.println("完全二叉树: " + TreeProperties.isCompleteBinaryTree(root));
        System.out.println("平衡二叉树: " + TreeProperties.isBalanced(root));
    }
}
```

## 测试代码

```java
/**
 * 树特性测试类
 */
public class TreePropertiesTest {
    public static void main(String[] args) {
        System.out.println("=== 树特性测试 ===");
        testTreeProperties();
        
        System.out.println("\n=== 特殊二叉树测试 ===");
        testSpecialBinaryTrees();
        
        System.out.println("\n=== 树结构验证测试 ===");
        testTreeValidation();
    }
    
    /**
     * 测试树的基本性质
     */
    public static void testTreeProperties() {
        // 构建测试树
        TreeNode<Integer> root = new TreeNode<>(1);
        root.left = new TreeNode<>(2);
        root.right = new TreeNode<>(3);
        root.left.left = new TreeNode<>(4);
        root.left.right = new TreeNode<>(5);
        root.right.left = new TreeNode<>(6);
        root.right.right = new TreeNode<>(7);
        
        TreeVisualizer.printTree(root);
        TreeVisualizer.printTreeStatistics(root);
    }
    
    /**
     * 测试特殊二叉树
     */
    public static void testSpecialBinaryTrees() {
        System.out.println("=== 满二叉树测试 ===");
        TreeNode<Integer> fullTree = BinaryTreeBuilder.buildFullBinaryTree(3);
        TreeVisualizer.printTree(fullTree);
        TreeValidator.validateSpecialTrees(fullTree);
        
        System.out.println("\n=== 完全二叉树测试 ===");
        Integer[] completeArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        TreeNode<Integer> completeTree = BinaryTreeBuilder.buildCompleteBinaryTree(completeArray);
        TreeVisualizer.printTreeByLevel(completeTree);
        TreeValidator.validateSpecialTrees(completeTree);
        
        System.out.println("\n=== 平衡二叉树测试 ===");
        int[] sortedArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        TreeNode<Integer> balancedTree = BinaryTreeBuilder.buildBalancedBinaryTree(sortedArray);
        TreeVisualizer.printTree(balancedTree);
        TreeValidator.validateSpecialTrees(balancedTree);
        
        System.out.println("\n=== 链式二叉树测试 ===");
        TreeNode<Integer> linkedTree = BinaryTreeBuilder.buildLinkedListTree(5);
        TreeVisualizer.printTree(linkedTree);
        TreeValidator.validateSpecialTrees(linkedTree);
    }
    
    /**
     * 测试树结构验证
     */
    public static void testTreeValidation() {
        // 构建测试树
        TreeNode<String> root = new TreeNode<>("A");
        root.left = new TreeNode<>("B");
        root.right = new TreeNode<>("C");
        root.left.left = new TreeNode<>("D");
        root.left.right = new TreeNode<>("E");
        root.right.left = new TreeNode<>("F");
        root.right.right = new TreeNode<>("G");
        root.left.left.left = new TreeNode<>("H");
        root.left.left.right = new TreeNode<>("I");
        
        TreeValidator.validateTreeProperties(root);
        TreeValidator.validateSpecialTrees(root);
        TreeValidator.analyzeTreeLevels(root);
        TreeValidator.analyzeTreePaths(root);
    }
}
```
