# 13.3.1. 树知识点概述 - Java代码示例

## 树节点定义

```java
/**
 * 树节点类
 */
public class TreeNode<T> {
    public T data;
    public TreeNode<T> left;
    public TreeNode<T> right;
    
    public TreeNode(T data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
    
    public TreeNode(T data, TreeNode<T> left, TreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
    
    @Override
    public String toString() {
        return data.toString();
    }
}
```

## 二叉树基本操作

```java
/**
 * 二叉树类
 */
public class BinaryTree<T> {
    private TreeNode<T> root;
    
    public BinaryTree() {
        this.root = null;
    }
    
    public BinaryTree(TreeNode<T> root) {
        this.root = root;
    }
    
    /**
     * 获取根节点
     */
    public TreeNode<T> getRoot() {
        return root;
    }
    
    /**
     * 设置根节点
     */
    public void setRoot(TreeNode<T> root) {
        this.root = root;
    }
    
    /**
     * 判断树是否为空
     */
    public boolean isEmpty() {
        return root == null;
    }
    
    /**
     * 获取树的深度
     */
    public int getDepth() {
        return getDepth(root);
    }
    
    private int getDepth(TreeNode<T> node) {
        if (node == null) {
            return 0;
        }
        int leftDepth = getDepth(node.left);
        int rightDepth = getDepth(node.right);
        return Math.max(leftDepth, rightDepth) + 1;
    }
    
    /**
     * 获取节点总数
     */
    public int getNodeCount() {
        return getNodeCount(root);
    }
    
    private int getNodeCount(TreeNode<T> node) {
        if (node == null) {
            return 0;
        }
        return 1 + getNodeCount(node.left) + getNodeCount(node.right);
    }
    
    /**
     * 获取叶子节点数
     */
    public int getLeafCount() {
        return getLeafCount(root);
    }
    
    private int getLeafCount(TreeNode<T> node) {
        if (node == null) {
            return 0;
        }
        if (node.left == null && node.right == null) {
            return 1;
        }
        return getLeafCount(node.left) + getLeafCount(node.right);
    }
    
    /**
     * 查找节点
     */
    public TreeNode<T> find(T data) {
        return find(root, data);
    }
    
    private TreeNode<T> find(TreeNode<T> node, T data) {
        if (node == null) {
            return null;
        }
        if (node.data.equals(data)) {
            return node;
        }
        
        TreeNode<T> leftResult = find(node.left, data);
        if (leftResult != null) {
            return leftResult;
        }
        
        return find(node.right, data);
    }
}
```

## 树的遍历算法

```java
/**
 * 树遍历算法类
 */
public class TreeTraversal {
    
    /**
     * 前序遍历（递归）
     */
    public static <T> void preorderTraversal(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        System.out.print(root.data + " ");  // 访问根节点
        preorderTraversal(root.left);       // 遍历左子树
        preorderTraversal(root.right);      // 遍历右子树
    }
    
    /**
     * 前序遍历（非递归）
     */
    public static <T> void preorderTraversalIterative(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        Stack<TreeNode<T>> stack = new Stack<>();
        stack.push(root);
        
        while (!stack.isEmpty()) {
            TreeNode<T> node = stack.pop();
            System.out.print(node.data + " ");
            
            // 先压入右子树，再压入左子树
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
        }
    }
    
    /**
     * 中序遍历（递归）
     */
    public static <T> void inorderTraversal(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        inorderTraversal(root.left);        // 遍历左子树
        System.out.print(root.data + " ");  // 访问根节点
        inorderTraversal(root.right);       // 遍历右子树
    }
    
    /**
     * 中序遍历（非递归）
     */
    public static <T> void inorderTraversalIterative(TreeNode<T> root) {
        Stack<TreeNode<T>> stack = new Stack<>();
        TreeNode<T> current = root;
        
        while (current != null || !stack.isEmpty()) {
            // 一直向左走到底
            while (current != null) {
                stack.push(current);
                current = current.left;
            }
            
            // 弹出并访问节点
            current = stack.pop();
            System.out.print(current.data + " ");
            
            // 转向右子树
            current = current.right;
        }
    }
    
    /**
     * 后序遍历（递归）
     */
    public static <T> void postorderTraversal(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        postorderTraversal(root.left);      // 遍历左子树
        postorderTraversal(root.right);     // 遍历右子树
        System.out.print(root.data + " ");  // 访问根节点
    }
    
    /**
     * 后序遍历（非递归）
     */
    public static <T> void postorderTraversalIterative(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        Stack<TreeNode<T>> stack = new Stack<>();
        Stack<TreeNode<T>> output = new Stack<>();
        stack.push(root);
        
        while (!stack.isEmpty()) {
            TreeNode<T> node = stack.pop();
            output.push(node);
            
            if (node.left != null) {
                stack.push(node.left);
            }
            if (node.right != null) {
                stack.push(node.right);
            }
        }
        
        while (!output.isEmpty()) {
            System.out.print(output.pop().data + " ");
        }
    }
    
    /**
     * 层序遍历（广度优先）
     */
    public static <T> void levelOrderTraversal(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        Queue<TreeNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode<T> node = queue.poll();
                System.out.print(node.data + " ");
                
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            System.out.println(); // 换行表示新的一层
        }
    }
    
    /**
     * 获取遍历结果列表
     */
    public static <T> List<T> getTraversalResult(TreeNode<T> root, String type) {
        List<T> result = new ArrayList<>();
        
        switch (type.toLowerCase()) {
            case "preorder":
                preorderToList(root, result);
                break;
            case "inorder":
                inorderToList(root, result);
                break;
            case "postorder":
                postorderToList(root, result);
                break;
            case "levelorder":
                levelOrderToList(root, result);
                break;
            default:
                throw new IllegalArgumentException("不支持的遍历类型: " + type);
        }
        
        return result;
    }
    
    private static <T> void preorderToList(TreeNode<T> node, List<T> result) {
        if (node == null) return;
        result.add(node.data);
        preorderToList(node.left, result);
        preorderToList(node.right, result);
    }
    
    private static <T> void inorderToList(TreeNode<T> node, List<T> result) {
        if (node == null) return;
        inorderToList(node.left, result);
        result.add(node.data);
        inorderToList(node.right, result);
    }
    
    private static <T> void postorderToList(TreeNode<T> node, List<T> result) {
        if (node == null) return;
        postorderToList(node.left, result);
        postorderToList(node.right, result);
        result.add(node.data);
    }
    
    private static <T> void levelOrderToList(TreeNode<T> root, List<T> result) {
        if (root == null) return;
        
        Queue<TreeNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode<T> node = queue.poll();
            result.add(node.data);
            
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }
}
```

## 特殊二叉树实现

```java
/**
 * 二叉搜索树
 */
public class BinarySearchTree<T extends Comparable<T>> {
    private TreeNode<T> root;
    
    public BinarySearchTree() {
        this.root = null;
    }
    
    /**
     * 插入节点
     */
    public void insert(T data) {
        root = insert(root, data);
    }
    
    private TreeNode<T> insert(TreeNode<T> node, T data) {
        if (node == null) {
            return new TreeNode<>(data);
        }
        
        int cmp = data.compareTo(node.data);
        if (cmp < 0) {
            node.left = insert(node.left, data);
        } else if (cmp > 0) {
            node.right = insert(node.right, data);
        }
        // 如果相等，不插入重复元素
        
        return node;
    }
    
    /**
     * 查找节点
     */
    public TreeNode<T> search(T data) {
        return search(root, data);
    }
    
    private TreeNode<T> search(TreeNode<T> node, T data) {
        if (node == null || node.data.equals(data)) {
            return node;
        }
        
        int cmp = data.compareTo(node.data);
        if (cmp < 0) {
            return search(node.left, data);
        } else {
            return search(node.right, data);
        }
    }
    
    /**
     * 删除节点
     */
    public void delete(T data) {
        root = delete(root, data);
    }
    
    private TreeNode<T> delete(TreeNode<T> node, T data) {
        if (node == null) {
            return null;
        }
        
        int cmp = data.compareTo(node.data);
        if (cmp < 0) {
            node.left = delete(node.left, data);
        } else if (cmp > 0) {
            node.right = delete(node.right, data);
        } else {
            // 找到要删除的节点
            if (node.left == null) {
                return node.right;
            } else if (node.right == null) {
                return node.left;
            } else {
                // 有两个子节点，找到右子树的最小值
                TreeNode<T> minNode = findMin(node.right);
                node.data = minNode.data;
                node.right = delete(node.right, minNode.data);
            }
        }
        
        return node;
    }
    
    /**
     * 找到最小节点
     */
    private TreeNode<T> findMin(TreeNode<T> node) {
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }
    
    /**
     * 找到最大节点
     */
    public TreeNode<T> findMax() {
        return findMax(root);
    }
    
    private TreeNode<T> findMax(TreeNode<T> node) {
        if (node == null) {
            return null;
        }
        while (node.right != null) {
            node = node.right;
        }
        return node;
    }
    
    /**
     * 判断是否为有效的二叉搜索树
     */
    public boolean isValidBST() {
        return isValidBST(root, null, null);
    }
    
    private boolean isValidBST(TreeNode<T> node, T min, T max) {
        if (node == null) {
            return true;
        }
        
        if ((min != null && node.data.compareTo(min) <= 0) ||
            (max != null && node.data.compareTo(max) >= 0)) {
            return false;
        }
        
        return isValidBST(node.left, min, node.data) &&
               isValidBST(node.right, node.data, max);
    }
    
    /**
     * 获取根节点
     */
    public TreeNode<T> getRoot() {
        return root;
    }
}
```

## 树的工具类

```java
/**
 * 树工具类
 */
public class TreeUtils {
    
    /**
     * 根据数组构建完全二叉树
     */
    public static <T> TreeNode<T> buildCompleteBinaryTree(T[] array) {
        if (array == null || array.length == 0) {
            return null;
        }
        
        TreeNode<T> root = new TreeNode<>(array[0]);
        Queue<TreeNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        
        for (int i = 1; i < array.length; i += 2) {
            TreeNode<T> parent = queue.poll();
            
            if (i < array.length) {
                parent.left = new TreeNode<>(array[i]);
                queue.offer(parent.left);
            }
            
            if (i + 1 < array.length) {
                parent.right = new TreeNode<>(array[i + 1]);
                queue.offer(parent.right);
            }
        }
        
        return root;
    }
    
    /**
     * 根据前序和中序遍历结果构建二叉树
     */
    public static <T> TreeNode<T> buildTreeFromPreorderInorder(T[] preorder, T[] inorder) {
        if (preorder == null || inorder == null || preorder.length != inorder.length) {
            return null;
        }
        
        Map<T, Integer> inorderMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }
        
        return buildTreeFromPreorderInorder(preorder, 0, preorder.length - 1,
                                          inorder, 0, inorder.length - 1, inorderMap);
    }
    
    private static <T> TreeNode<T> buildTreeFromPreorderInorder(T[] preorder, int preStart, int preEnd,
                                                               T[] inorder, int inStart, int inEnd,
                                                               Map<T, Integer> inorderMap) {
        if (preStart > preEnd || inStart > inEnd) {
            return null;
        }
        
        T rootValue = preorder[preStart];
        TreeNode<T> root = new TreeNode<>(rootValue);
        
        int rootIndex = inorderMap.get(rootValue);
        int leftSubtreeSize = rootIndex - inStart;
        
        root.left = buildTreeFromPreorderInorder(preorder, preStart + 1, preStart + leftSubtreeSize,
                                               inorder, inStart, rootIndex - 1, inorderMap);
        root.right = buildTreeFromPreorderInorder(preorder, preStart + leftSubtreeSize + 1, preEnd,
                                                inorder, rootIndex + 1, inEnd, inorderMap);
        
        return root;
    }
    
    /**
     * 判断两棵树是否相同
     */
    public static <T> boolean isSameTree(TreeNode<T> p, TreeNode<T> q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        return p.data.equals(q.data) && 
               isSameTree(p.left, q.left) && 
               isSameTree(p.right, q.right);
    }
    
    /**
     * 判断是否为平衡二叉树
     */
    public static <T> boolean isBalanced(TreeNode<T> root) {
        return getHeight(root) != -1;
    }
    
    private static <T> int getHeight(TreeNode<T> node) {
        if (node == null) {
            return 0;
        }
        
        int leftHeight = getHeight(node.left);
        if (leftHeight == -1) {
            return -1;
        }
        
        int rightHeight = getHeight(node.right);
        if (rightHeight == -1) {
            return -1;
        }
        
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        
        return Math.max(leftHeight, rightHeight) + 1;
    }
    
    /**
     * 获取树的最小深度
     */
    public static <T> int minDepth(TreeNode<T> root) {
        if (root == null) {
            return 0;
        }
        
        if (root.left == null && root.right == null) {
            return 1;
        }
        
        int leftDepth = root.left != null ? minDepth(root.left) : Integer.MAX_VALUE;
        int rightDepth = root.right != null ? minDepth(root.right) : Integer.MAX_VALUE;
        
        return Math.min(leftDepth, rightDepth) + 1;
    }
    
    /**
     * 获取树的最大深度
     */
    public static <T> int maxDepth(TreeNode<T> root) {
        if (root == null) {
            return 0;
        }
        
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        
        return Math.max(leftDepth, rightDepth) + 1;
    }
    
    /**
     * 判断路径和是否存在
     */
    public static boolean hasPathSum(TreeNode<Integer> root, int targetSum) {
        if (root == null) {
            return false;
        }
        
        if (root.left == null && root.right == null) {
            return root.data == targetSum;
        }
        
        return hasPathSum(root.left, targetSum - root.data) ||
               hasPathSum(root.right, targetSum - root.data);
    }
    
    /**
     * 打印树的结构（可视化）
     */
    public static <T> void printTree(TreeNode<T> root) {
        if (root == null) {
            System.out.println("空树");
            return;
        }
        
        printTreeHelper(root, "", true);
    }
    
    private static <T> void printTreeHelper(TreeNode<T> node, String prefix, boolean isLast) {
        System.out.println(prefix + (isLast ? "└── " : "├── ") + node.data);
        
        List<TreeNode<T>> children = new ArrayList<>();
        if (node.left != null) children.add(node.left);
        if (node.right != null) children.add(node.right);
        
        for (int i = 0; i < children.size(); i++) {
            boolean isLastChild = (i == children.size() - 1);
            String newPrefix = prefix + (isLast ? "    " : "│   ");
            printTreeHelper(children.get(i), newPrefix, isLastChild);
        }
    }
}
```

## 测试代码

```java
/**
 * 树测试类
 */
public class TreeTest {
    public static void main(String[] args) {
        System.out.println("=== 二叉树基本操作测试 ===");
        testBinaryTree();
        
        System.out.println("\n=== 树遍历测试 ===");
        testTreeTraversal();
        
        System.out.println("\n=== 二叉搜索树测试 ===");
        testBinarySearchTree();
        
        System.out.println("\n=== 树工具类测试 ===");
        testTreeUtils();
    }
    
    /**
     * 测试二叉树基本操作
     */
    public static void testBinaryTree() {
        // 构建测试树
        TreeNode<Integer> root = new TreeNode<>(1);
        root.left = new TreeNode<>(2);
        root.right = new TreeNode<>(3);
        root.left.left = new TreeNode<>(4);
        root.left.right = new TreeNode<>(5);
        root.right.left = new TreeNode<>(6);
        root.right.right = new TreeNode<>(7);
        
        BinaryTree<Integer> tree = new BinaryTree<>(root);
        
        System.out.println("树是否为空: " + tree.isEmpty());
        System.out.println("树的深度: " + tree.getDepth());
        System.out.println("节点总数: " + tree.getNodeCount());
        System.out.println("叶子节点数: " + tree.getLeafCount());
        
        TreeNode<Integer> found = tree.find(5);
        System.out.println("查找节点5: " + (found != null ? found.data : "未找到"));
    }
    
    /**
     * 测试树遍历
     */
    public static void testTreeTraversal() {
        // 构建测试树
        TreeNode<String> root = new TreeNode<>("A");
        root.left = new TreeNode<>("B");
        root.right = new TreeNode<>("C");
        root.left.left = new TreeNode<>("D");
        root.left.right = new TreeNode<>("E");
        root.right.left = new TreeNode<>("F");
        root.right.right = new TreeNode<>("G");
        
        System.out.println("前序遍历（递归）:");
        TreeTraversal.preorderTraversal(root);
        System.out.println();
        
        System.out.println("前序遍历（非递归）:");
        TreeTraversal.preorderTraversalIterative(root);
        System.out.println();
        
        System.out.println("中序遍历（递归）:");
        TreeTraversal.inorderTraversal(root);
        System.out.println();
        
        System.out.println("中序遍历（非递归）:");
        TreeTraversal.inorderTraversalIterative(root);
        System.out.println();
        
        System.out.println("后序遍历（递归）:");
        TreeTraversal.postorderTraversal(root);
        System.out.println();
        
        System.out.println("后序遍历（非递归）:");
        TreeTraversal.postorderTraversalIterative(root);
        System.out.println();
        
        System.out.println("层序遍历:");
        TreeTraversal.levelOrderTraversal(root);
        
        // 获取遍历结果列表
        List<String> preorderList = TreeTraversal.getTraversalResult(root, "preorder");
        System.out.println("前序遍历结果列表: " + preorderList);
    }
    
    /**
     * 测试二叉搜索树
     */
    public static void testBinarySearchTree() {
        BinarySearchTree<Integer> bst = new BinarySearchTree<>();
        
        // 插入节点
        int[] values = {5, 3, 7, 2, 4, 6, 8};
        for (int value : values) {
            bst.insert(value);
        }
        
        System.out.println("二叉搜索树中序遍历:");
        TreeTraversal.inorderTraversal(bst.getRoot());
        System.out.println();
        
        System.out.println("查找节点4: " + (bst.search(4) != null ? "找到" : "未找到"));
        System.out.println("查找节点9: " + (bst.search(9) != null ? "找到" : "未找到"));
        
        System.out.println("最大节点: " + bst.findMax().data);
        System.out.println("是否为有效BST: " + bst.isValidBST());
        
        // 删除节点
        bst.delete(3);
        System.out.println("删除节点3后的中序遍历:");
        TreeTraversal.inorderTraversal(bst.getRoot());
        System.out.println();
    }
    
    /**
     * 测试树工具类
     */
    public static void testTreeUtils() {
        // 构建完全二叉树
        Integer[] array = {1, 2, 3, 4, 5, 6, 7};
        TreeNode<Integer> completeTree = TreeUtils.buildCompleteBinaryTree(array);
        
        System.out.println("完全二叉树层序遍历:");
        TreeTraversal.levelOrderTraversal(completeTree);
        
        // 测试树的性质
        System.out.println("树的最大深度: " + TreeUtils.maxDepth(completeTree));
        System.out.println("树的最小深度: " + TreeUtils.minDepth(completeTree));
        System.out.println("树是否平衡: " + TreeUtils.isBalanced(completeTree));
        
        // 测试路径和
        TreeNode<Integer> pathTree = new TreeNode<>(5);
        pathTree.left = new TreeNode<>(4);
        pathTree.right = new TreeNode<>(8);
        pathTree.left.left = new TreeNode<>(11);
        pathTree.left.left.left = new TreeNode<>(7);
        pathTree.left.left.right = new TreeNode<>(2);
        pathTree.right.left = new TreeNode<>(13);
        pathTree.right.right = new TreeNode<>(4);
        pathTree.right.right.right = new TreeNode<>(1);
        
        System.out.println("是否存在路径和22: " + TreeUtils.hasPathSum(pathTree, 22));
        
        // 打印树结构
        System.out.println("树结构:");
        TreeUtils.printTree(completeTree);
    }
}
```
