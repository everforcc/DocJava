# 13.3.7. 其他特殊的二叉树 - Java代码示例

## 一、AVL树实现

```java
/**
 * AVL树（平衡二叉搜索树）实现
 */
public class AVLTree {
    
    static class AVLNode {
        int data;
        int height;
        AVLNode left;
        AVLNode right;
        
        public AVLNode(int data) {
            this.data = data;
            this.height = 1;
        }
    }
    
    private AVLNode root;
    
    /**
     * 获取节点高度
     */
    private int getHeight(AVLNode node) {
        return node == null ? 0 : node.height;
    }
    
    /**
     * 获取平衡因子
     */
    private int getBalance(AVLNode node) {
        return node == null ? 0 : getHeight(node.left) - getHeight(node.right);
    }
    
    /**
     * 更新节点高度
     */
    private void updateHeight(AVLNode node) {
        if (node != null) {
            node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
        }
    }
    
    /**
     * 右旋转
     */
    private AVLNode rightRotate(AVLNode y) {
        AVLNode x = y.left;
        AVLNode T2 = x.right;
        
        // 执行旋转
        x.right = y;
        y.left = T2;
        
        // 更新高度
        updateHeight(y);
        updateHeight(x);
        
        return x;
    }
    
    /**
     * 左旋转
     */
    private AVLNode leftRotate(AVLNode x) {
        AVLNode y = x.right;
        AVLNode T2 = y.left;
        
        // 执行旋转
        y.left = x;
        x.right = T2;
        
        // 更新高度
        updateHeight(x);
        updateHeight(y);
        
        return y;
    }
    
    /**
     * 插入节点
     */
    public void insert(int data) {
        root = insertNode(root, data);
    }
    
    private AVLNode insertNode(AVLNode node, int data) {
        // 1. 执行标准BST插入
        if (node == null) {
            return new AVLNode(data);
        }
        
        if (data < node.data) {
            node.left = insertNode(node.left, data);
        } else if (data > node.data) {
            node.right = insertNode(node.right, data);
        } else {
            return node; // 相等的键不插入
        }
        
        // 2. 更新当前节点的高度
        updateHeight(node);
        
        // 3. 获取平衡因子
        int balance = getBalance(node);
        
        // 4. 如果节点不平衡，执行相应的旋转
        // Left Left Case
        if (balance > 1 && data < node.left.data) {
            return rightRotate(node);
        }
        
        // Right Right Case
        if (balance < -1 && data > node.right.data) {
            return leftRotate(node);
        }
        
        // Left Right Case
        if (balance > 1 && data > node.left.data) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }
        
        // Right Left Case
        if (balance < -1 && data < node.right.data) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }
        
        return node;
    }
    
    /**
     * 中序遍历
     */
    public void inorderTraversal() {
        inorderHelper(root);
        System.out.println();
    }
    
    private void inorderHelper(AVLNode node) {
        if (node != null) {
            inorderHelper(node.left);
            System.out.print(node.data + " ");
            inorderHelper(node.right);
        }
    }
}
```

## 二、红黑树实现

```java
/**
 * 红黑树实现
 */
public class RedBlackTree {
    
    enum Color {
        RED, BLACK
    }
    
    static class RBNode {
        int data;
        Color color;
        RBNode left, right, parent;
        
        public RBNode(int data) {
            this.data = data;
            this.color = Color.RED; // 新节点默认为红色
        }
    }
    
    private RBNode root;
    private RBNode NIL; // 哨兵节点
    
    public RedBlackTree() {
        NIL = new RBNode(0);
        NIL.color = Color.BLACK;
        root = NIL;
    }
    
    /**
     * 左旋转
     */
    private void leftRotate(RBNode x) {
        RBNode y = x.right;
        x.right = y.left;
        
        if (y.left != NIL) {
            y.left.parent = x;
        }
        
        y.parent = x.parent;
        
        if (x.parent == NIL) {
            root = y;
        } else if (x == x.parent.left) {
            x.parent.left = y;
        } else {
            x.parent.right = y;
        }
        
        y.left = x;
        x.parent = y;
    }
    
    /**
     * 右旋转
     */
    private void rightRotate(RBNode y) {
        RBNode x = y.left;
        y.left = x.right;
        
        if (x.right != NIL) {
            x.right.parent = y;
        }
        
        x.parent = y.parent;
        
        if (y.parent == NIL) {
            root = x;
        } else if (y == y.parent.right) {
            y.parent.right = x;
        } else {
            y.parent.left = x;
        }
        
        x.right = y;
        y.parent = x;
    }
    
    /**
     * 插入节点
     */
    public void insert(int data) {
        RBNode z = new RBNode(data);
        z.left = NIL;
        z.right = NIL;
        
        RBNode y = NIL;
        RBNode x = root;
        
        while (x != NIL) {
            y = x;
            if (z.data < x.data) {
                x = x.left;
            } else {
                x = x.right;
            }
        }
        
        z.parent = y;
        
        if (y == NIL) {
            root = z;
        } else if (z.data < y.data) {
            y.left = z;
        } else {
            y.right = z;
        }
        
        insertFixup(z);
    }
    
    /**
     * 插入后修复红黑树性质
     */
    private void insertFixup(RBNode z) {
        while (z.parent.color == Color.RED) {
            if (z.parent == z.parent.parent.left) {
                RBNode y = z.parent.parent.right;
                
                if (y.color == Color.RED) {
                    z.parent.color = Color.BLACK;
                    y.color = Color.BLACK;
                    z.parent.parent.color = Color.RED;
                    z = z.parent.parent;
                } else {
                    if (z == z.parent.right) {
                        z = z.parent;
                        leftRotate(z);
                    }
                    z.parent.color = Color.BLACK;
                    z.parent.parent.color = Color.RED;
                    rightRotate(z.parent.parent);
                }
            } else {
                RBNode y = z.parent.parent.left;
                
                if (y.color == Color.RED) {
                    z.parent.color = Color.BLACK;
                    y.color = Color.BLACK;
                    z.parent.parent.color = Color.RED;
                    z = z.parent.parent;
                } else {
                    if (z == z.parent.left) {
                        z = z.parent;
                        rightRotate(z);
                    }
                    z.parent.color = Color.BLACK;
                    z.parent.parent.color = Color.RED;
                    leftRotate(z.parent.parent);
                }
            }
        }
        
        root.color = Color.BLACK;
    }
    
    /**
     * 中序遍历
     */
    public void inorderTraversal() {
        inorderHelper(root);
        System.out.println();
    }
    
    private void inorderHelper(RBNode node) {
        if (node != NIL) {
            inorderHelper(node.left);
            System.out.print(node.data + "(" + node.color + ") ");
            inorderHelper(node.right);
        }
    }
}
```

## 三、字典树（Trie树）实现

```java
/**
 * 字典树实现
 */
public class Trie {
    
    static class TrieNode {
        TrieNode[] children;
        boolean isEndOfWord;
        
        public TrieNode() {
            children = new TrieNode[26]; // 假设只有小写字母
            isEndOfWord = false;
        }
    }
    
    private TrieNode root;
    
    public Trie() {
        root = new TrieNode();
    }
    
    /**
     * 插入单词
     */
    public void insert(String word) {
        TrieNode current = root;
        
        for (char ch : word.toCharArray()) {
            int index = ch - 'a';
            if (current.children[index] == null) {
                current.children[index] = new TrieNode();
            }
            current = current.children[index];
        }
        
        current.isEndOfWord = true;
    }
    
    /**
     * 搜索单词
     */
    public boolean search(String word) {
        TrieNode current = root;
        
        for (char ch : word.toCharArray()) {
            int index = ch - 'a';
            if (current.children[index] == null) {
                return false;
            }
            current = current.children[index];
        }
        
        return current.isEndOfWord;
    }
    
    /**
     * 检查是否存在以prefix开头的单词
     */
    public boolean startsWith(String prefix) {
        TrieNode current = root;
        
        for (char ch : prefix.toCharArray()) {
            int index = ch - 'a';
            if (current.children[index] == null) {
                return false;
            }
            current = current.children[index];
        }
        
        return true;
    }
    
    /**
     * 删除单词
     */
    public void delete(String word) {
        deleteHelper(root, word, 0);
    }
    
    private boolean deleteHelper(TrieNode current, String word, int index) {
        if (index == word.length()) {
            if (!current.isEndOfWord) {
                return false;
            }
            current.isEndOfWord = false;
            return !hasChildren(current);
        }
        
        char ch = word.charAt(index);
        TrieNode node = current.children[ch - 'a'];
        
        if (node == null) {
            return false;
        }
        
        boolean shouldDeleteChild = deleteHelper(node, word, index + 1);
        
        if (shouldDeleteChild) {
            current.children[ch - 'a'] = null;
            return !current.isEndOfWord && !hasChildren(current);
        }
        
        return false;
    }
    
    private boolean hasChildren(TrieNode node) {
        for (TrieNode child : node.children) {
            if (child != null) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * 获取所有以prefix开头的单词
     */
    public java.util.List<String> getWordsWithPrefix(String prefix) {
        java.util.List<String> result = new java.util.ArrayList<>();
        TrieNode current = root;
        
        // 找到前缀的最后一个节点
        for (char ch : prefix.toCharArray()) {
            int index = ch - 'a';
            if (current.children[index] == null) {
                return result;
            }
            current = current.children[index];
        }
        
        // 从前缀节点开始DFS收集所有单词
        dfsCollectWords(current, prefix, result);
        return result;
    }
    
    private void dfsCollectWords(TrieNode node, String prefix, java.util.List<String> result) {
        if (node.isEndOfWord) {
            result.add(prefix);
        }
        
        for (int i = 0; i < 26; i++) {
            if (node.children[i] != null) {
                dfsCollectWords(node.children[i], prefix + (char)('a' + i), result);
            }
        }
    }
}
```

## 四、线段树实现

```java
/**
 * 线段树实现（区间和查询）
 */
public class SegmentTree {
    
    private int[] tree;
    private int n;
    
    public SegmentTree(int[] arr) {
        n = arr.length;
        tree = new int[4 * n];
        build(arr, 1, 0, n - 1);
    }
    
    /**
     * 构建线段树
     */
    private void build(int[] arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
        } else {
            int mid = (start + end) / 2;
            build(arr, 2 * node, start, mid);
            build(arr, 2 * node + 1, mid + 1, end);
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    }
    
    /**
     * 更新单个元素
     */
    public void update(int idx, int val) {
        update(1, 0, n - 1, idx, val);
    }
    
    private void update(int node, int start, int end, int idx, int val) {
        if (start == end) {
            tree[node] = val;
        } else {
            int mid = (start + end) / 2;
            if (idx <= mid) {
                update(2 * node, start, mid, idx, val);
            } else {
                update(2 * node + 1, mid + 1, end, idx, val);
            }
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }
    }
    
    /**
     * 区间查询
     */
    public int query(int l, int r) {
        return query(1, 0, n - 1, l, r);
    }
    
    private int query(int node, int start, int end, int l, int r) {
        if (r < start || end < l) {
            return 0;
        }
        if (l <= start && end <= r) {
            return tree[node];
        }
        
        int mid = (start + end) / 2;
        int p1 = query(2 * node, start, mid, l, r);
        int p2 = query(2 * node + 1, mid + 1, end, l, r);
        return p1 + p2;
    }
}
```

## 五、树状数组实现

```java
/**
 * 树状数组（Binary Indexed Tree）实现
 */
public class BinaryIndexedTree {
    
    private int[] tree;
    private int n;
    
    public BinaryIndexedTree(int size) {
        n = size;
        tree = new int[n + 1];
    }
    
    public BinaryIndexedTree(int[] arr) {
        n = arr.length;
        tree = new int[n + 1];
        for (int i = 0; i < n; i++) {
            update(i + 1, arr[i]);
        }
    }
    
    /**
     * 获取lowbit
     */
    private int lowbit(int x) {
        return x & (-x);
    }
    
    /**
     * 单点更新
     */
    public void update(int idx, int delta) {
        for (int i = idx; i <= n; i += lowbit(i)) {
            tree[i] += delta;
        }
    }
    
    /**
     * 前缀和查询
     */
    public int query(int idx) {
        int sum = 0;
        for (int i = idx; i > 0; i -= lowbit(i)) {
            sum += tree[i];
        }
        return sum;
    }
    
    /**
     * 区间和查询
     */
    public int rangeQuery(int left, int right) {
        return query(right) - query(left - 1);
    }
}
```

## 六、综合测试类

```java
/**
 * 特殊二叉树综合测试
 */
public class SpecialTreesTest {
    
    public static void main(String[] args) {
        System.out.println("特殊二叉树 - Java代码演示");
        System.out.println("========================");
        
        // 测试AVL树
        testAVLTree();
        
        // 测试红黑树
        testRedBlackTree();
        
        // 测试字典树
        testTrie();
        
        // 测试线段树
        testSegmentTree();
        
        // 测试树状数组
        testBinaryIndexedTree();
    }
    
    public static void testAVLTree() {
        System.out.println("\n1. AVL树测试:");
        System.out.println("------------------");
        
        AVLTree avl = new AVLTree();
        int[] values = {10, 20, 30, 40, 50, 25};
        
        for (int val : values) {
            avl.insert(val);
            System.out.println("插入 " + val + " 后的中序遍历:");
            avl.inorderTraversal();
        }
    }
    
    public static void testRedBlackTree() {
        System.out.println("\n2. 红黑树测试:");
        System.out.println("------------------");
        
        RedBlackTree rbt = new RedBlackTree();
        int[] values = {7, 3, 18, 10, 22, 8, 11, 26};
        
        for (int val : values) {
            rbt.insert(val);
        }
        
        System.out.println("红黑树中序遍历:");
        rbt.inorderTraversal();
    }
    
    public static void testTrie() {
        System.out.println("\n3. 字典树测试:");
        System.out.println("------------------");
        
        Trie trie = new Trie();
        String[] words = {"apple", "app", "application", "apply", "banana"};
        
        // 插入单词
        for (String word : words) {
            trie.insert(word);
        }
        
        // 搜索测试
        System.out.println("搜索 'app': " + trie.search("app"));
        System.out.println("搜索 'appl': " + trie.search("appl"));
        System.out.println("前缀 'app' 存在: " + trie.startsWith("app"));
        
        // 获取以app开头的所有单词
        System.out.println("以 'app' 开头的单词: " + trie.getWordsWithPrefix("app"));
    }
    
    public static void testSegmentTree() {
        System.out.println("\n4. 线段树测试:");
        System.out.println("------------------");
        
        int[] arr = {1, 3, 5, 7, 9, 11};
        SegmentTree segTree = new SegmentTree(arr);
        
        System.out.println("原数组: " + java.util.Arrays.toString(arr));
        System.out.println("区间[1,3]的和: " + segTree.query(1, 3));
        System.out.println("区间[2,5]的和: " + segTree.query(2, 5));
        
        segTree.update(1, 10);
        System.out.println("更新索引1为10后，区间[1,3]的和: " + segTree.query(1, 3));
    }
    
    public static void testBinaryIndexedTree() {
        System.out.println("\n5. 树状数组测试:");
        System.out.println("------------------");
        
        int[] arr = {1, 3, 5, 7, 9, 11};
        BinaryIndexedTree bit = new BinaryIndexedTree(arr);
        
        System.out.println("原数组: " + java.util.Arrays.toString(arr));
        System.out.println("前缀和[1,4]: " + bit.query(4));
        System.out.println("区间和[2,5]: " + bit.rangeQuery(2, 5));
        
        bit.update(2, 5); // 给索引2增加5
        System.out.println("索引2增加5后，前缀和[1,4]: " + bit.query(4));
    }
}
```

## 七、学习要点

1. **理解各种特殊树的性质**：平衡性、有序性、特殊约束
2. **掌握基本操作**：插入、删除、查询、旋转
3. **分析时间复杂度**：理解为什么能达到O(log n)
4. **选择合适的数据结构**：根据应用场景选择最优方案
5. **实现细节**：注意边界条件和特殊情况的处理
6. **实际应用**：了解在系统设计中的应用场景
