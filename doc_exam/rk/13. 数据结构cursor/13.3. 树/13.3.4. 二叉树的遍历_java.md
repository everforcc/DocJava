# 13.3.4. 二叉树的遍历 - Java代码示例

## 树节点定义

```java
/**
 * 树节点类
 */
public class TreeNode<T> {
    public T data;
    public TreeNode<T> left;
    public TreeNode<T> right;
    
    public TreeNode(T data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
    
    public TreeNode(T data, TreeNode<T> left, TreeNode<T> right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
    
    @Override
    public String toString() {
        return data.toString();
    }
}
```

## 深度优先遍历（递归实现）

```java
/**
 * 深度优先遍历（递归实现）
 */
public class DFSTraversal {
    
    /**
     * 前序遍历（递归）
     */
    public static <T> void preorderTraversal(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        System.out.print(root.data + " ");  // 访问根节点
        preorderTraversal(root.left);       // 遍历左子树
        preorderTraversal(root.right);      // 遍历右子树
    }
    
    /**
     * 中序遍历（递归）
     */
    public static <T> void inorderTraversal(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        inorderTraversal(root.left);        // 遍历左子树
        System.out.print(root.data + " ");  // 访问根节点
        inorderTraversal(root.right);       // 遍历右子树
    }
    
    /**
     * 后序遍历（递归）
     */
    public static <T> void postorderTraversal(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        postorderTraversal(root.left);      // 遍历左子树
        postorderTraversal(root.right);     // 遍历右子树
        System.out.print(root.data + " ");  // 访问根节点
    }
    
    /**
     * 获取前序遍历结果列表
     */
    public static <T> List<T> preorderToList(TreeNode<T> root) {
        List<T> result = new ArrayList<>();
        preorderToListHelper(root, result);
        return result;
    }
    
    private static <T> void preorderToListHelper(TreeNode<T> root, List<T> result) {
        if (root == null) {
            return;
        }
        result.add(root.data);
        preorderToListHelper(root.left, result);
        preorderToListHelper(root.right, result);
    }
    
    /**
     * 获取中序遍历结果列表
     */
    public static <T> List<T> inorderToList(TreeNode<T> root) {
        List<T> result = new ArrayList<>();
        inorderToListHelper(root, result);
        return result;
    }
    
    private static <T> void inorderToListHelper(TreeNode<T> root, List<T> result) {
        if (root == null) {
            return;
        }
        inorderToListHelper(root.left, result);
        result.add(root.data);
        inorderToListHelper(root.right, result);
    }
    
    /**
     * 获取后序遍历结果列表
     */
    public static <T> List<T> postorderToList(TreeNode<T> root) {
        List<T> result = new ArrayList<>();
        postorderToListHelper(root, result);
        return result;
    }
    
    private static <T> void postorderToListHelper(TreeNode<T> root, List<T> result) {
        if (root == null) {
            return;
        }
        postorderToListHelper(root.left, result);
        postorderToListHelper(root.right, result);
        result.add(root.data);
    }
}
```

## 深度优先遍历（迭代实现）

```java
/**
 * 深度优先遍历（迭代实现）
 */
public class DFSTraversalIterative {
    
    /**
     * 前序遍历（迭代）
     */
    public static <T> void preorderTraversal(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        Stack<TreeNode<T>> stack = new Stack<>();
        stack.push(root);
        
        while (!stack.isEmpty()) {
            TreeNode<T> node = stack.pop();
            System.out.print(node.data + " ");
            
            // 先压入右子树，再压入左子树
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
        }
    }
    
    /**
     * 中序遍历（迭代）
     */
    public static <T> void inorderTraversal(TreeNode<T> root) {
        Stack<TreeNode<T>> stack = new Stack<>();
        TreeNode<T> current = root;
        
        while (current != null || !stack.isEmpty()) {
            // 一直向左走到底
            while (current != null) {
                stack.push(current);
                current = current.left;
            }
            
            // 弹出并访问节点
            current = stack.pop();
            System.out.print(current.data + " ");
            
            // 转向右子树
            current = current.right;
        }
    }
    
    /**
     * 后序遍历（迭代）
     */
    public static <T> void postorderTraversal(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        Stack<TreeNode<T>> stack = new Stack<>();
        Stack<TreeNode<T>> output = new Stack<>();
        stack.push(root);
        
        while (!stack.isEmpty()) {
            TreeNode<T> node = stack.pop();
            output.push(node);
            
            if (node.left != null) {
                stack.push(node.left);
            }
            if (node.right != null) {
                stack.push(node.right);
            }
        }
        
        while (!output.isEmpty()) {
            System.out.print(output.pop().data + " ");
        }
    }
    
    /**
     * 后序遍历（迭代 - 单栈版本）
     */
    public static <T> void postorderTraversalSingleStack(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        Stack<TreeNode<T>> stack = new Stack<>();
        TreeNode<T> current = root;
        TreeNode<T> lastVisited = null;
        
        while (current != null || !stack.isEmpty()) {
            if (current != null) {
                stack.push(current);
                current = current.left;
            } else {
                TreeNode<T> peekNode = stack.peek();
                if (peekNode.right != null && lastVisited != peekNode.right) {
                    current = peekNode.right;
                } else {
                    System.out.print(peekNode.data + " ");
                    lastVisited = stack.pop();
                }
            }
        }
    }
}
```

## 广度优先遍历

```java
/**
 * 广度优先遍历（层序遍历）
 */
public class BFSTraversal {
    
    /**
     * 层序遍历
     */
    public static <T> void levelOrderTraversal(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        Queue<TreeNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode<T> node = queue.poll();
            System.out.print(node.data + " ");
            
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }
    
    /**
     * 按层打印树
     */
    public static <T> void levelOrderTraversalByLevel(TreeNode<T> root) {
        if (root == null) {
            return;
        }
        
        Queue<TreeNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode<T> node = queue.poll();
                System.out.print(node.data + " ");
                
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            System.out.println(); // 换行表示新的一层
        }
    }
    
    /**
     * 获取层序遍历结果列表
     */
    public static <T> List<T> levelOrderToList(TreeNode<T> root) {
        List<T> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        
        Queue<TreeNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode<T> node = queue.poll();
            result.add(node.data);
            
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        
        return result;
    }
    
    /**
     * 获取每层的节点列表
     */
    public static <T> List<List<T>> levelOrderToListByLevel(TreeNode<T> root) {
        List<List<T>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        
        Queue<TreeNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<T> level = new ArrayList<>();
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode<T> node = queue.poll();
                level.add(node.data);
                
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            result.add(level);
        }
        
        return result;
    }
    
    /**
     * 锯齿形层序遍历
     */
    public static <T> List<List<T>> zigzagLevelOrder(TreeNode<T> root) {
        List<List<T>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        
        Queue<TreeNode<T>> queue = new LinkedList<>();
        queue.offer(root);
        boolean leftToRight = true;
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<T> level = new ArrayList<>();
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode<T> node = queue.poll();
                
                if (leftToRight) {
                    level.add(node.data);
                } else {
                    level.add(0, node.data);
                }
                
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            
            result.add(level);
            leftToRight = !leftToRight;
        }
        
        return result;
    }
}
```

## Morris遍历（O(1)空间复杂度）

```java
/**
 * Morris遍历 - O(1)空间复杂度
 */
public class MorrisTraversal {
    
    /**
     * Morris前序遍历
     */
    public static <T> void morrisPreorder(TreeNode<T> root) {
        TreeNode<T> current = root;
        
        while (current != null) {
            if (current.left == null) {
                System.out.print(current.data + " ");
                current = current.right;
            } else {
                TreeNode<T> predecessor = findPredecessor(current);
                
                if (predecessor.right == null) {
                    System.out.print(current.data + " ");
                    predecessor.right = current;
                    current = current.left;
                } else {
                    predecessor.right = null;
                    current = current.right;
                }
            }
        }
    }
    
    /**
     * Morris中序遍历
     */
    public static <T> void morrisInorder(TreeNode<T> root) {
        TreeNode<T> current = root;
        
        while (current != null) {
            if (current.left == null) {
                System.out.print(current.data + " ");
                current = current.right;
            } else {
                TreeNode<T> predecessor = findPredecessor(current);
                
                if (predecessor.right == null) {
                    predecessor.right = current;
                    current = current.left;
                } else {
                    predecessor.right = null;
                    System.out.print(current.data + " ");
                    current = current.right;
                }
            }
        }
    }
    
    /**
     * Morris后序遍历
     */
    public static <T> void morrisPostorder(TreeNode<T> root) {
        TreeNode<T> dummy = new TreeNode<>(null);
        dummy.left = root;
        TreeNode<T> current = dummy;
        
        while (current != null) {
            if (current.left == null) {
                current = current.right;
            } else {
                TreeNode<T> predecessor = findPredecessor(current);
                
                if (predecessor.right == null) {
                    predecessor.right = current;
                    current = current.left;
                } else {
                    predecessor.right = null;
                    reversePrint(current.left, predecessor);
                    current = current.right;
                }
            }
        }
    }
    
    /**
     * 找到前驱节点
     */
    private static <T> TreeNode<T> findPredecessor(TreeNode<T> node) {
        TreeNode<T> predecessor = node.left;
        while (predecessor.right != null && predecessor.right != node) {
            predecessor = predecessor.right;
        }
        return predecessor;
    }
    
    /**
     * 反向打印路径
     */
    private static <T> void reversePrint(TreeNode<T> from, TreeNode<T> to) {
        reverse(from, to);
        
        TreeNode<T> current = to;
        while (true) {
            System.out.print(current.data + " ");
            if (current == from) {
                break;
            }
            current = current.right;
        }
        
        reverse(to, from);
    }
    
    /**
     * 反转路径
     */
    private static <T> void reverse(TreeNode<T> from, TreeNode<T> to) {
        if (from == to) {
            return;
        }
        
        TreeNode<T> prev = from;
        TreeNode<T> current = from.right;
        
        while (prev != to) {
            TreeNode<T> next = current.right;
            current.right = prev;
            prev = current;
            current = next;
        }
    }
}
```

## 遍历应用示例

```java
/**
 * 遍历应用示例
 */
public class TraversalApplications {
    
    /**
     * 验证二叉搜索树
     */
    public static boolean isValidBST(TreeNode<Integer> root) {
        List<Integer> inorder = DFSTraversal.inorderToList(root);
        for (int i = 1; i < inorder.size(); i++) {
            if (inorder.get(i) <= inorder.get(i - 1)) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * 寻找第k小的元素
     */
    public static <T> T findKthSmallest(TreeNode<T> root, int k) {
        List<T> inorder = DFSTraversal.inorderToList(root);
        if (k > 0 && k <= inorder.size()) {
            return inorder.get(k - 1);
        }
        return null;
    }
    
    /**
     * 计算路径和
     */
    public static boolean hasPathSum(TreeNode<Integer> root, int targetSum) {
        if (root == null) {
            return false;
        }
        
        if (root.left == null && root.right == null) {
            return root.data == targetSum;
        }
        
        return hasPathSum(root.left, targetSum - root.data) ||
               hasPathSum(root.right, targetSum - root.data);
    }
    
    /**
     * 找到所有路径和等于目标值的路径
     */
    public static List<List<Integer>> pathSum(TreeNode<Integer> root, int targetSum) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentPath = new ArrayList<>();
        pathSumHelper(root, targetSum, currentPath, result);
        return result;
    }
    
    private static void pathSumHelper(TreeNode<Integer> root, int targetSum, 
                                    List<Integer> currentPath, List<List<Integer>> result) {
        if (root == null) {
            return;
        }
        
        currentPath.add(root.data);
        
        if (root.left == null && root.right == null && root.data == targetSum) {
            result.add(new ArrayList<>(currentPath));
        } else {
            pathSumHelper(root.left, targetSum - root.data, currentPath, result);
            pathSumHelper(root.right, targetSum - root.data, currentPath, result);
        }
        
        currentPath.remove(currentPath.size() - 1);
    }
    
    /**
     * 序列化二叉树
     */
    public static String serialize(TreeNode<Integer> root) {
        List<String> result = new ArrayList<>();
        serializeHelper(root, result);
        return String.join(",", result);
    }
    
    private static void serializeHelper(TreeNode<Integer> root, List<String> result) {
        if (root == null) {
            result.add("null");
            return;
        }
        
        result.add(String.valueOf(root.data));
        serializeHelper(root.left, result);
        serializeHelper(root.right, result);
    }
    
    /**
     * 反序列化二叉树
     */
    public static TreeNode<Integer> deserialize(String data) {
        String[] values = data.split(",");
        Queue<String> queue = new LinkedList<>(Arrays.asList(values));
        return deserializeHelper(queue);
    }
    
    private static TreeNode<Integer> deserializeHelper(Queue<String> queue) {
        String value = queue.poll();
        if ("null".equals(value)) {
            return null;
        }
        
        TreeNode<Integer> root = new TreeNode<>(Integer.parseInt(value));
        root.left = deserializeHelper(queue);
        root.right = deserializeHelper(queue);
        
        return root;
    }
    
    /**
     * 计算树的最大深度
     */
    public static <T> int maxDepth(TreeNode<T> root) {
        if (root == null) {
            return 0;
        }
        
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        
        return Math.max(leftDepth, rightDepth) + 1;
    }
    
    /**
     * 计算树的最小深度
     */
    public static <T> int minDepth(TreeNode<T> root) {
        if (root == null) {
            return 0;
        }
        
        if (root.left == null && root.right == null) {
            return 1;
        }
        
        int leftDepth = root.left != null ? minDepth(root.left) : Integer.MAX_VALUE;
        int rightDepth = root.right != null ? minDepth(root.right) : Integer.MAX_VALUE;
        
        return Math.min(leftDepth, rightDepth) + 1;
    }
}
```

## 测试代码

```java
/**
 * 二叉树遍历测试类
 */
public class TreeTraversalTest {
    public static void main(String[] args) {
        System.out.println("=== 二叉树遍历测试 ===");
        testTreeTraversal();
        
        System.out.println("\n=== 遍历应用测试 ===");
        testTraversalApplications();
        
        System.out.println("\n=== Morris遍历测试 ===");
        testMorrisTraversal();
    }
    
    /**
     * 测试树遍历
     */
    public static void testTreeTraversal() {
        // 构建测试树
        TreeNode<String> root = new TreeNode<>("A");
        root.left = new TreeNode<>("B");
        root.right = new TreeNode<>("C");
        root.left.left = new TreeNode<>("D");
        root.left.right = new TreeNode<>("E");
        root.right.left = new TreeNode<>("F");
        root.right.right = new TreeNode<>("G");
        
        System.out.println("测试树结构:");
        System.out.println("    A");
        System.out.println("   / \\");
        System.out.println("  B   C");
        System.out.println(" / \\ / \\");
        System.out.println("D  E F  G");
        
        System.out.println("\n递归遍历:");
        System.out.print("前序遍历: ");
        DFSTraversal.preorderTraversal(root);
        System.out.println();
        
        System.out.print("中序遍历: ");
        DFSTraversal.inorderTraversal(root);
        System.out.println();
        
        System.out.print("后序遍历: ");
        DFSTraversal.postorderTraversal(root);
        System.out.println();
        
        System.out.println("\n迭代遍历:");
        System.out.print("前序遍历: ");
        DFSTraversalIterative.preorderTraversal(root);
        System.out.println();
        
        System.out.print("中序遍历: ");
        DFSTraversalIterative.inorderTraversal(root);
        System.out.println();
        
        System.out.print("后序遍历: ");
        DFSTraversalIterative.postorderTraversal(root);
        System.out.println();
        
        System.out.println("\n层序遍历:");
        System.out.print("普通层序: ");
        BFSTraversal.levelOrderTraversal(root);
        System.out.println();
        
        System.out.println("按层打印:");
        BFSTraversal.levelOrderTraversalByLevel(root);
        
        System.out.println("锯齿形层序: " + BFSTraversal.zigzagLevelOrder(root));
    }
    
    /**
     * 测试遍历应用
     */
    public static void testTraversalApplications() {
        // 构建二叉搜索树
        TreeNode<Integer> bst = new TreeNode<>(5);
        bst.left = new TreeNode<>(3);
        bst.right = new TreeNode<>(8);
        bst.left.left = new TreeNode<>(2);
        bst.left.right = new TreeNode<>(4);
        bst.right.left = new TreeNode<>(7);
        bst.right.right = new TreeNode<>(9);
        
        System.out.println("二叉搜索树验证: " + TraversalApplications.isValidBST(bst));
        System.out.println("第3小的元素: " + TraversalApplications.findKthSmallest(bst, 3));
        
        // 测试路径和
        TreeNode<Integer> pathTree = new TreeNode<>(5);
        pathTree.left = new TreeNode<>(4);
        pathTree.right = new TreeNode<>(8);
        pathTree.left.left = new TreeNode<>(11);
        pathTree.left.left.left = new TreeNode<>(7);
        pathTree.left.left.right = new TreeNode<>(2);
        pathTree.right.left = new TreeNode<>(13);
        pathTree.right.right = new TreeNode<>(4);
        pathTree.right.right.right = new TreeNode<>(1);
        
        System.out.println("是否存在路径和22: " + TraversalApplications.hasPathSum(pathTree, 22));
        System.out.println("路径和22的所有路径: " + TraversalApplications.pathSum(pathTree, 22));
        
        // 测试序列化
        String serialized = TraversalApplications.serialize(pathTree);
        System.out.println("序列化结果: " + serialized);
        
        TreeNode<Integer> deserialized = TraversalApplications.deserialize(serialized);
        System.out.println("反序列化后前序遍历: ");
        DFSTraversal.preorderTraversal(deserialized);
        System.out.println();
        
        System.out.println("树的最大深度: " + TraversalApplications.maxDepth(pathTree));
        System.out.println("树的最小深度: " + TraversalApplications.minDepth(pathTree));
    }
    
    /**
     * 测试Morris遍历
     */
    public static void testMorrisTraversal() {
        TreeNode<Integer> root = new TreeNode<>(1);
        root.left = new TreeNode<>(2);
        root.right = new TreeNode<>(3);
        root.left.left = new TreeNode<>(4);
        root.left.right = new TreeNode<>(5);
        root.right.left = new TreeNode<>(6);
        root.right.right = new TreeNode<>(7);
        
        System.out.print("Morris前序遍历: ");
        MorrisTraversal.morrisPreorder(root);
        System.out.println();
        
        System.out.print("Morris中序遍历: ");
        MorrisTraversal.morrisInorder(root);
        System.out.println();
        
        System.out.print("Morris后序遍历: ");
        MorrisTraversal.morrisPostorder(root);
        System.out.println();
    }
}
```
