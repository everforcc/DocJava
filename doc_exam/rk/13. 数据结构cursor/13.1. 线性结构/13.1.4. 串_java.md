# 13.1.4. 串 - Java代码示例

## 串的基本操作实现

```java
/**
 * 串的基本操作实现
 */
public class StringOperations {
    
    /**
     * 串比较
     */
    public static int strCompare(String s1, String s2) {
        int len1 = s1.length();
        int len2 = s2.length();
        int minLen = Math.min(len1, len2);
        
        for (int i = 0; i < minLen; i++) {
            if (s1.charAt(i) != s2.charAt(i)) {
                return s1.charAt(i) - s2.charAt(i);
            }
        }
        
        return len1 - len2;
    }
    
    /**
     * 串连接
     */
    public static String concat(String s1, String s2) {
        return s1 + s2;
    }
    
    /**
     * 求子串
     */
    public static String subString(String s, int pos, int len) {
        if (pos < 0 || pos >= s.length() || len < 0 || pos + len > s.length()) {
            throw new IllegalArgumentException("参数不合法");
        }
        return s.substring(pos, pos + len);
    }
    
    /**
     * 串定位（BF算法）
     */
    public static int index(String s, String t) {
        int sLen = s.length();
        int tLen = t.length();
        
        if (tLen == 0) return 0;
        if (sLen < tLen) return -1;
        
        for (int i = 0; i <= sLen - tLen; i++) {
            int j = 0;
            while (j < tLen && s.charAt(i + j) == t.charAt(j)) {
                j++;
            }
            if (j == tLen) {
                return i;
            }
        }
        return -1;
    }
    
    /**
     * 串插入
     */
    public static String strInsert(String s, int pos, String t) {
        if (pos < 0 || pos > s.length()) {
            throw new IllegalArgumentException("插入位置不合法");
        }
        return s.substring(0, pos) + t + s.substring(pos);
    }
    
    /**
     * 串删除
     */
    public static String strDelete(String s, int pos, int len) {
        if (pos < 0 || pos >= s.length() || len < 0 || pos + len > s.length()) {
            throw new IllegalArgumentException("删除参数不合法");
        }
        return s.substring(0, pos) + s.substring(pos + len);
    }
    
    /**
     * 串替换
     */
    public static String replace(String s, String oldStr, String newStr) {
        return s.replace(oldStr, newStr);
    }
}
```

## KMP算法实现

```java
/**
 * KMP算法实现
 */
public class KMPAlgorithm {
    
    /**
     * 计算next数组
     */
    public static int[] getNext(String pattern) {
        int m = pattern.length();
        int[] next = new int[m];
        next[0] = -1;
        
        int j = 0;
        int k = -1;
        
        while (j < m - 1) {
            if (k == -1 || pattern.charAt(j) == pattern.charAt(k)) {
                j++;
                k++;
                next[j] = k;
            } else {
                k = next[k];
            }
        }
        
        return next;
    }
    
    /**
     * KMP模式匹配
     */
    public static int kmpSearch(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        if (m == 0) return 0;
        if (n < m) return -1;
        
        int[] next = getNext(pattern);
        
        int i = 0; // 文本串指针
        int j = 0; // 模式串指针
        
        while (i < n && j < m) {
            if (j == -1 || text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            } else {
                j = next[j];
            }
        }
        
        if (j == m) {
            return i - j;
        } else {
            return -1;
        }
    }
    
    /**
     * 查找所有匹配位置
     */
    public static List<Integer> findAllMatches(String text, String pattern) {
        List<Integer> matches = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        if (m == 0) {
            for (int i = 0; i <= n; i++) {
                matches.add(i);
            }
            return matches;
        }
        
        int[] next = getNext(pattern);
        int i = 0;
        int j = 0;
        
        while (i < n) {
            if (j == -1 || text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
                if (j == m) {
                    matches.add(i - j);
                    j = next[j - 1];
                }
            } else {
                j = next[j];
            }
        }
        
        return matches;
    }
}
```

## 字符串工具类

```java
/**
 * 字符串工具类
 */
public class StringUtils {
    
    /**
     * 字符串反转
     */
    public static String reverse(String s) {
        if (s == null || s.length() <= 1) {
            return s;
        }
        
        char[] chars = s.toCharArray();
        int left = 0;
        int right = chars.length - 1;
        
        while (left < right) {
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;
            left++;
            right--;
        }
        
        return new String(chars);
    }
    
    /**
     * 去除重复字符
     */
    public static String removeDuplicates(String s) {
        if (s == null || s.length() <= 1) {
            return s;
        }
        
        Set<Character> seen = new HashSet<>();
        StringBuilder result = new StringBuilder();
        
        for (char c : s.toCharArray()) {
            if (!seen.contains(c)) {
                seen.add(c);
                result.append(c);
            }
        }
        
        return result.toString();
    }
    
    /**
     * 字符串排序
     */
    public static String sort(String s) {
        if (s == null || s.length() <= 1) {
            return s;
        }
        
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        return new String(chars);
    }
    
    /**
     * 判断是否为回文字符串
     */
    public static boolean isPalindrome(String s) {
        if (s == null || s.length() <= 1) {
            return true;
        }
        
        int left = 0;
        int right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    /**
     * 统计字符出现次数
     */
    public static Map<Character, Integer> countCharacters(String s) {
        Map<Character, Integer> count = new HashMap<>();
        
        for (char c : s.toCharArray()) {
            count.put(c, count.getOrDefault(c, 0) + 1);
        }
        
        return count;
    }
    
    /**
     * 最长公共前缀
     */
    public static String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        
        String prefix = strs[0];
        
        for (int i = 1; i < strs.length; i++) {
            while (strs[i].indexOf(prefix) != 0) {
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.isEmpty()) {
                    return "";
                }
            }
        }
        
        return prefix;
    }
    
    /**
     * 字符串压缩
     */
    public static String compress(String s) {
        if (s == null || s.length() <= 1) {
            return s;
        }
        
        StringBuilder compressed = new StringBuilder();
        int count = 1;
        
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                count++;
            } else {
                compressed.append(s.charAt(i - 1));
                if (count > 1) {
                    compressed.append(count);
                }
                count = 1;
            }
        }
        
        compressed.append(s.charAt(s.length() - 1));
        if (count > 1) {
            compressed.append(count);
        }
        
        return compressed.length() < s.length() ? compressed.toString() : s;
    }
}
```

## 字符串匹配算法比较

```java
/**
 * 字符串匹配算法比较
 */
public class StringMatchingComparison {
    
    /**
     * BF算法（暴力匹配）
     */
    public static int bruteForce(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        for (int i = 0; i <= n - m; i++) {
            int j = 0;
            while (j < m && text.charAt(i + j) == pattern.charAt(j)) {
                j++;
            }
            if (j == m) {
                return i;
            }
        }
        return -1;
    }
    
    /**
     * BM算法（Boyer-Moore）
     */
    public static int boyerMoore(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        if (m == 0) return 0;
        if (n < m) return -1;
        
        // 构建坏字符表
        Map<Character, Integer> badChar = new HashMap<>();
        for (int i = 0; i < m; i++) {
            badChar.put(pattern.charAt(i), i);
        }
        
        int s = 0; // 模式串相对于文本串的偏移量
        
        while (s <= n - m) {
            int j = m - 1;
            
            // 从右向左匹配
            while (j >= 0 && pattern.charAt(j) == text.charAt(s + j)) {
                j--;
            }
            
            if (j < 0) {
                return s;
            } else {
                // 计算移动距离
                int badCharShift = j - badChar.getOrDefault(text.charAt(s + j), -1);
                s += Math.max(1, badCharShift);
            }
        }
        
        return -1;
    }
    
    /**
     * 性能测试
     */
    public static void performanceTest() {
        String text = "abcdefghijklmnopqrstuvwxyz".repeat(1000);
        String pattern = "xyz";
        
        // BF算法测试
        long startTime = System.nanoTime();
        int bfResult = bruteForce(text, pattern);
        long bfTime = System.nanoTime() - startTime;
        
        // KMP算法测试
        startTime = System.nanoTime();
        int kmpResult = KMPAlgorithm.kmpSearch(text, pattern);
        long kmpTime = System.nanoTime() - startTime;
        
        // BM算法测试
        startTime = System.nanoTime();
        int bmResult = boyerMoore(text, pattern);
        long bmTime = System.nanoTime() - startTime;
        
        System.out.println("文本长度: " + text.length());
        System.out.println("模式长度: " + pattern.length());
        System.out.println("BF算法结果: " + bfResult + ", 耗时: " + bfTime + "ns");
        System.out.println("KMP算法结果: " + kmpResult + ", 耗时: " + kmpTime + "ns");
        System.out.println("BM算法结果: " + bmResult + ", 耗时: " + bmTime + "ns");
    }
}
```

## 字符串处理应用示例

### 文本编辑器功能

```java
/**
 * 简单文本编辑器
 */
public class TextEditor {
    private StringBuilder content;
    
    public TextEditor() {
        this.content = new StringBuilder();
    }
    
    public TextEditor(String initialContent) {
        this.content = new StringBuilder(initialContent);
    }
    
    /**
     * 插入文本
     */
    public void insert(int position, String text) {
        if (position < 0 || position > content.length()) {
            throw new IllegalArgumentException("插入位置不合法");
        }
        content.insert(position, text);
    }
    
    /**
     * 删除文本
     */
    public void delete(int start, int end) {
        if (start < 0 || end > content.length() || start > end) {
            throw new IllegalArgumentException("删除位置不合法");
        }
        content.delete(start, end);
    }
    
    /**
     * 查找文本
     */
    public int find(String text) {
        return content.indexOf(text);
    }
    
    /**
     * 替换文本
     */
    public void replace(String oldText, String newText) {
        int index = content.indexOf(oldText);
        if (index != -1) {
            content.replace(index, index + oldText.length(), newText);
        }
    }
    
    /**
     * 替换所有匹配的文本
     */
    public void replaceAll(String oldText, String newText) {
        String result = content.toString().replace(oldText, newText);
        content = new StringBuilder(result);
    }
    
    /**
     * 获取文本长度
     */
    public int length() {
        return content.length();
    }
    
    /**
     * 获取指定位置的字符
     */
    public char charAt(int index) {
        return content.charAt(index);
    }
    
    /**
     * 获取子串
     */
    public String substring(int start, int end) {
        return content.substring(start, end);
    }
    
    /**
     * 清空文本
     */
    public void clear() {
        content.setLength(0);
    }
    
    @Override
    public String toString() {
        return content.toString();
    }
}
```

### 字符串分析器

```java
/**
 * 字符串分析器
 */
public class StringAnalyzer {
    
    /**
     * 分析字符串统计信息
     */
    public static class StringStats {
        public int totalChars;
        public int letters;
        public int digits;
        public int spaces;
        public int specialChars;
        public Map<Character, Integer> charFrequency;
        
        public StringStats() {
            this.charFrequency = new HashMap<>();
        }
        
        @Override
        public String toString() {
            return String.format(
                "总字符数: %d, 字母: %d, 数字: %d, 空格: %d, 特殊字符: %d",
                totalChars, letters, digits, spaces, specialChars
            );
        }
    }
    
    /**
     * 分析字符串
     */
    public static StringStats analyze(String text) {
        StringStats stats = new StringStats();
        
        for (char c : text.toCharArray()) {
            stats.totalChars++;
            stats.charFrequency.put(c, stats.charFrequency.getOrDefault(c, 0) + 1);
            
            if (Character.isLetter(c)) {
                stats.letters++;
            } else if (Character.isDigit(c)) {
                stats.digits++;
            } else if (Character.isWhitespace(c)) {
                stats.spaces++;
            } else {
                stats.specialChars++;
            }
        }
        
        return stats;
    }
    
    /**
     * 查找最频繁的字符
     */
    public static char findMostFrequentChar(String text) {
        Map<Character, Integer> frequency = new HashMap<>();
        
        for (char c : text.toCharArray()) {
            frequency.put(c, frequency.getOrDefault(c, 0) + 1);
        }
        
        char mostFrequent = ' ';
        int maxCount = 0;
        
        for (Map.Entry<Character, Integer> entry : frequency.entrySet()) {
            if (entry.getValue() > maxCount) {
                maxCount = entry.getValue();
                mostFrequent = entry.getKey();
            }
        }
        
        return mostFrequent;
    }
}
```

## 测试代码

```java
/**
 * 串操作测试类
 */
public class StringTest {
    public static void main(String[] args) {
        System.out.println("=== 基本操作测试 ===");
        testBasicOperations();
        
        System.out.println("\n=== 模式匹配测试 ===");
        testPatternMatching();
        
        System.out.println("\n=== 字符串工具测试 ===");
        testStringUtils();
        
        System.out.println("\n=== 文本编辑器测试 ===");
        testTextEditor();
        
        System.out.println("\n=== 字符串分析测试 ===");
        testStringAnalyzer();
        
        System.out.println("\n=== 性能比较测试 ===");
        StringMatchingComparison.performanceTest();
    }
    
    /**
     * 测试基本操作
     */
    public static void testBasicOperations() {
        String s1 = "Hello";
        String s2 = "World";
        
        System.out.println("串比较: " + StringOperations.strCompare(s1, s2));
        System.out.println("串连接: " + StringOperations.concat(s1, s2));
        System.out.println("求子串: " + StringOperations.subString("Hello World", 6, 5));
        System.out.println("串定位: " + StringOperations.index("Hello World", "World"));
        System.out.println("串插入: " + StringOperations.strInsert("Hello", 5, " World"));
        System.out.println("串删除: " + StringOperations.strDelete("Hello World", 5, 6));
    }
    
    /**
     * 测试模式匹配
     */
    public static void testPatternMatching() {
        String text = "ABABCABABA";
        String pattern = "ABABA";
        
        System.out.println("文本: " + text);
        System.out.println("模式: " + pattern);
        System.out.println("KMP匹配位置: " + KMPAlgorithm.kmpSearch(text, pattern));
        
        List<Integer> matches = KMPAlgorithm.findAllMatches(text, pattern);
        System.out.println("所有匹配位置: " + matches);
    }
    
    /**
     * 测试字符串工具
     */
    public static void testStringUtils() {
        String test = "Hello World!";
        
        System.out.println("原字符串: " + test);
        System.out.println("反转: " + StringUtils.reverse(test));
        System.out.println("去重: " + StringUtils.removeDuplicates("aabbcc"));
        System.out.println("排序: " + StringUtils.sort("cba"));
        System.out.println("回文检查: " + StringUtils.isPalindrome("racecar"));
        System.out.println("字符统计: " + StringUtils.countCharacters(test));
        System.out.println("压缩: " + StringUtils.compress("aabcccccaaa"));
    }
    
    /**
     * 测试文本编辑器
     */
    public static void testTextEditor() {
        TextEditor editor = new TextEditor("Hello");
        
        editor.insert(5, " World");
        System.out.println("插入后: " + editor);
        
        editor.replace("World", "Java");
        System.out.println("替换后: " + editor);
        
        editor.delete(5, 9);
        System.out.println("删除后: " + editor);
        
        int pos = editor.find("Hello");
        System.out.println("查找位置: " + pos);
    }
    
    /**
     * 测试字符串分析
     */
    public static void testStringAnalyzer() {
        String text = "Hello World! 123";
        
        StringAnalyzer.StringStats stats = StringAnalyzer.analyze(text);
        System.out.println("分析结果: " + stats);
        
        char mostFrequent = StringAnalyzer.findMostFrequentChar(text);
        System.out.println("最频繁字符: " + mostFrequent);
    }
}
```
