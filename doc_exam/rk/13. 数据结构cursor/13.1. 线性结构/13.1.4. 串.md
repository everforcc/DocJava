# 13.1.4. 串

## 概述
串（String）是由零个或多个字符组成的有限序列，是专门用于处理字符串数据的线性结构。串是计算机科学中非常重要的数据结构，广泛应用于文本处理、模式匹配、数据压缩等领域。

## 串的定义

### 基本概念
- **串**：由字符组成的有限序列
- **串的长度**：串中字符的个数
- **空串**：长度为0的串
- **子串**：串中任意连续的字符序列
- **主串**：包含子串的串
- **串相等**：两个串的长度相等且对应位置的字符相同

### 串的表示
```
串 S = "Hello World"
长度 |S| = 11
字符：H e l l o   W o r l d
位置：0 1 2 3 4 5 6 7 8 9 10
```

## 串的基本操作

### 1. 赋值操作
- **StrAssign(S, chars)**：将字符串chars赋值给串S

### 2. 复制操作
- **StrCopy(S, T)**：将串T复制到串S

### 3. 比较操作
- **StrCompare(S, T)**：比较串S和串T的大小
- 返回值：S < T 返回负数，S = T 返回0，S > T 返回正数

### 4. 连接操作
- **Concat(S, T)**：将串T连接到串S的后面

### 5. 求子串操作
- **SubString(S, pos, len)**：从串S的第pos个字符开始，取长度为len的子串

### 6. 定位操作
- **Index(S, T)**：在串S中查找串T第一次出现的位置

### 7. 插入操作
- **StrInsert(S, pos, T)**：在串S的第pos个字符后插入串T

### 8. 删除操作
- **StrDelete(S, pos, len)**：从串S的第pos个字符开始删除长度为len的子串

### 9. 替换操作
- **Replace(S, T, V)**：将串S中所有的子串T替换为串V

## 串的存储结构

### 1. 定长顺序存储
使用固定长度的数组存储串，需要预先确定串的最大长度。

#### 特点
- **优点**：实现简单，访问速度快
- **缺点**：空间浪费，长度固定

#### 存储结构
```c
typedef struct {
    char ch[MAXLEN];
    int length;
} SString;
```

### 2. 堆分配存储
使用动态分配的数组存储串，可以根据需要调整长度。

#### 特点
- **优点**：空间利用率高，长度可变
- **缺点**：需要动态内存管理

#### 存储结构
```c
typedef struct {
    char *ch;
    int length;
} HString;
```

### 3. 块链存储
使用链表存储串，每个节点存储多个字符。

#### 特点
- **优点**：长度可变，插入删除方便
- **缺点**：实现复杂，访问速度较慢

#### 存储结构
```c
typedef struct Chunk {
    char ch[CHUNKSIZE];
    struct Chunk *next;
} Chunk;

typedef struct {
    Chunk *head, *tail;
    int length;
} LString;
```

## 串的模式匹配

### 1. 朴素模式匹配算法（BF算法）

#### 算法思想
从主串的第一个字符开始，逐个字符与模式串进行比较，如果不匹配，则主串指针后移一位，重新开始比较。

#### 算法步骤
1. 设置主串指针i=0，模式串指针j=0
2. 比较主串[i]和模式串[j]
3. 如果相等，i++，j++
4. 如果不相等，i=i-j+1，j=0
5. 重复步骤2-4，直到找到匹配或主串遍历完毕

#### 时间复杂度
- **最好情况**：O(m) - 第一次就匹配成功
- **最坏情况**：O(n×m) - 每次都要比较到模式串末尾
- **平均情况**：O(n+m)

### 2. KMP算法

#### 算法思想
利用模式串的next数组，当发生不匹配时，不需要回溯主串指针，而是根据next数组移动模式串指针。

#### next数组
next[j]表示模式串中第j个字符之前的子串的最长相等前后缀长度。

#### 算法步骤
1. 计算模式串的next数组
2. 设置主串指针i=0，模式串指针j=0
3. 比较主串[i]和模式串[j]
4. 如果相等，i++，j++
5. 如果不相等，j=next[j]
6. 重复步骤3-5，直到找到匹配或主串遍历完毕

#### 时间复杂度
- **预处理**：O(m)
- **匹配**：O(n)
- **总时间复杂度**：O(n+m)

## 串的应用

### 1. 文本编辑器
- 文本的插入、删除、查找、替换
- 文本的复制、粘贴、剪切
- 文本的格式化

### 2. 搜索引擎
- 关键词匹配
- 全文检索
- 模糊搜索

### 3. 数据压缩
- 字符串压缩算法
- 重复字符串的识别和压缩
- 字典压缩

### 4. 生物信息学
- DNA序列分析
- 蛋白质序列匹配
- 基因序列比较

### 5. 网络协议
- URL解析
- HTTP头部处理
- 数据包解析

## 串的算法应用

### 1. 字符串反转
```java
// 使用双指针法反转字符串
public String reverse(String s) {
    char[] chars = s.toCharArray();
    int left = 0, right = chars.length - 1;
    while (left < right) {
        char temp = chars[left];
        chars[left] = chars[right];
        chars[right] = temp;
        left++;
        right--;
    }
    return new String(chars);
}
```

### 2. 字符串去重
```java
// 去除字符串中的重复字符
public String removeDuplicates(String s) {
    Set<Character> seen = new HashSet<>();
    StringBuilder result = new StringBuilder();
    for (char c : s.toCharArray()) {
        if (!seen.contains(c)) {
            seen.add(c);
            result.append(c);
        }
    }
    return result.toString();
}
```

### 3. 字符串排序
```java
// 对字符串中的字符进行排序
public String sortString(String s) {
    char[] chars = s.toCharArray();
    Arrays.sort(chars);
    return new String(chars);
}
```

## 串的复杂度分析

### 基本操作复杂度
| 操作 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 赋值 | O(n) | O(n) |
| 复制 | O(n) | O(n) |
| 比较 | O(n) | O(1) |
| 连接 | O(n+m) | O(n+m) |
| 求子串 | O(len) | O(len) |
| 定位 | O(n×m) | O(1) |

### 模式匹配复杂度
| 算法 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| BF算法 | O(n×m) | O(1) |
| KMP算法 | O(n+m) | O(m) |

## 串的优化策略

### 1. 空间优化
- 使用字符串池避免重复存储
- 使用压缩存储减少空间占用
- 使用引用计数管理内存

### 2. 时间优化
- 使用KMP算法提高模式匹配效率
- 使用哈希表加速字符串比较
- 使用Trie树优化字符串查找

### 3. 内存优化
- 使用字符串视图避免复制
- 使用延迟计算减少内存分配
- 使用内存池管理字符串对象

## 串的实现注意事项

### 1. 字符编码
- 处理不同字符编码（ASCII、UTF-8、UTF-16）
- 处理多字节字符
- 处理特殊字符和转义字符

### 2. 内存管理
- 避免内存泄漏
- 合理分配和释放内存
- 处理字符串长度变化

### 3. 边界检查
- 检查字符串长度
- 检查数组越界
- 处理空字符串和null值

## 总结
串是处理文本数据的重要数据结构，具有丰富的操作和广泛的应用。掌握串的基本概念、存储结构、模式匹配算法和优化策略，对于开发高效的文本处理程序具有重要意义。在实际应用中，需要根据具体需求选择合适的存储结构和算法，并注意处理各种边界情况。
