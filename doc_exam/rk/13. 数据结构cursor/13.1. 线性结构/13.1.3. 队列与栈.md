<span  style="font-family: Simsun,serif; font-size: 17px; ">

[TOC]

# 13.1.3. 队列与栈

## 概述

- 队列和栈是两种特殊的线性结构，它们对插入和删除操作有特定的限制。栈遵循"后进先出"（LIFO）原则，队列遵循"先进先出"（FIFO）原则。

## 栈（Stack）

### 定义

- 栈是一种只允许在一端进行插入和删除操作的线性表。允许插入和删除的一端称为栈顶（Top），另一端称为栈底（Bottom）。

### 特点

1. **后进先出**：最后插入的元素最先被删除
2. **单端操作**：只能在栈顶进行插入和删除操作
3. **顺序性**：元素按照插入顺序存储
4. **有限性**：栈的大小通常是有限的

### 基本操作

- **push（入栈）**：在栈顶插入元素
- **pop（出栈）**：删除栈顶元素
- **top/peek（查看栈顶）**：获取栈顶元素但不删除
- **isEmpty（判空）**：判断栈是否为空
- **size（大小）**：获取栈中元素个数

### 栈的实现方式

#### 1. 顺序栈

- 使用数组实现，栈顶指针指向栈顶元素的下一个位置。

#### 2. 链式栈

- 使用链表实现，栈顶指针指向链表的头节点。

### 应用场景

1. **函数调用**：程序执行时的函数调用栈
2. **表达式求值**：中缀表达式转后缀表达式
3. **括号匹配**：检查括号是否匹配
4. **递归实现**：递归算法的非递归实现
5. **撤销操作**：编辑器的撤销功能
6. **深度优先搜索**：图的深度优先遍历

## 队列（Queue）

### 定义

- 队列是一种只允许在一端插入，另一端删除的线性表。允许插入的一端称为队尾（Rear），允许删除的一端称为队头（Front）。

### 特点

1. **先进先出**：最先插入的元素最先被删除
2. **双端操作**：在队尾插入，在队头删除
3. **顺序性**：元素按照插入顺序存储
4. **有限性**：队列的大小通常是有限的

### 基本操作

- **enqueue（入队）**：在队尾插入元素
- **dequeue（出队）**：删除队头元素
- **front（查看队头）**：获取队头元素但不删除
- **rear（查看队尾）**：获取队尾元素但不删除
- **isEmpty（判空）**：判断队列是否为空
- **size（大小）**：获取队列中元素个数

### 队列的实现方式

#### 1. 顺序队列

- 使用数组实现，需要处理假溢出问题。

#### 2. 循环队列

- 使用数组实现，通过取模运算实现循环。

#### 3. 链式队列

- 使用链表实现，队头指针指向头节点，队尾指针指向尾节点。

### 队列的类型

#### 1. 普通队列

- 基本的先进先出队列。

#### 2. 双端队列（Deque）

- 允许在两端进行插入和删除操作的队列。

#### 3. 优先队列（Priority Queue）

- 元素具有优先级，优先级高的元素先出队。

#### 4. 循环队列

- 使用循环数组实现的队列，解决假溢出问题。

### 应用场景

1. **任务调度**：操作系统的进程调度
2. **缓冲区管理**：数据缓冲区的管理
3. **广度优先搜索**：图的广度优先遍历
4. **打印队列**：打印任务的排队
5. **消息队列**：系统间的消息传递
6. **网络数据包**：网络数据包的排队处理

## 栈与队列的比较

### 操作限制

| 特性   | 栈    | 队列   |
|------|------|------|
| 插入位置 | 栈顶   | 队尾   |
| 删除位置 | 栈顶   | 队头   |
| 操作端数 | 单端   | 双端   |
| 访问方式 | 后进先出 | 先进先出 |

### 实现复杂度

| 特性   | 栈  | 队列       |
|------|----|----------|
| 顺序实现 | 简单 | 需要处理假溢出  |
| 链式实现 | 简单 | 需要维护两个指针 |
| 空间利用 | 高效 | 循环队列高效   |

### 应用场景

| 特性   | 栈          | 队列         |
|------|------------|------------|
| 主要用途 | 函数调用、表达式求值 | 任务调度、缓冲区管理 |
| 算法应用 | 深度优先搜索     | 广度优先搜索     |
| 系统应用 | 程序执行栈      | 进程调度队列     |

## 栈的实现细节

### 顺序栈

```java
// 栈顶指针指向栈顶元素的下一个位置
// 入栈：data[top] = element; top++;
// 出栈：top--; return data[top];
```

### 链式栈

```java
// 栈顶指针指向链表的头节点
// 入栈：新节点指向原头节点，头指针指向新节点
// 出栈：头指针指向下一个节点，返回原头节点数据
```

## 队列的实现细节

### 顺序队列的问题

1. **假溢出**：队尾指针到达数组末尾，但队头有空闲位置
2. **解决方案**：使用循环队列

### 循环队列

```java
// 队头指针：front
// 队尾指针：rear
// 入队：rear = (rear + 1) % capacity
// 出队：front = (front + 1) % capacity
// 判空：front == rear
// 判满：(rear + 1) % capacity == front
```

### 链式队列

```java
// 队头指针：指向头节点
// 队尾指针：指向尾节点
// 入队：在队尾插入新节点
// 出队：删除队头节点
```

## 算法应用

### 栈的应用

#### 1. 括号匹配

```java
// 使用栈检查括号是否匹配
// 遇到左括号入栈，遇到右括号出栈并检查是否匹配
```

#### 2. 表达式求值

```java
// 中缀表达式转后缀表达式
// 使用两个栈：操作数栈和操作符栈
```

#### 3. 递归转非递归

```java
// 使用栈模拟递归调用过程
// 将递归参数压入栈中
```

### 队列的应用

#### 1. 广度优先搜索

```java
// 使用队列实现BFS
// 将起始节点入队，然后依次处理队列中的节点
```

#### 2. 任务调度

```java
// 使用优先队列实现任务调度
// 根据优先级决定任务执行顺序
```

## 复杂度分析

### 栈的复杂度

- **入栈**：O(1)
- **出栈**：O(1)
- **查看栈顶**：O(1)
- **空间复杂度**：O(n)

### 队列的复杂度

- **入队**：O(1)
- **出队**：O(1)
- **查看队头**：O(1)
- **空间复杂度**：O(n)

## 选择原则

### 选择栈的情况

- 需要后进先出的访问模式
- 实现递归算法
- 表达式求值
- 括号匹配
- 深度优先搜索

### 选择队列的情况

- 需要先进先出的访问模式
- 任务调度
- 缓冲区管理
- 广度优先搜索
- 消息传递

## 总结

- 栈和队列是两种重要的线性数据结构，它们通过限制操作位置来实现特定的访问模式。栈适用于需要后进先出的场景，队列适用于需要先进先出的场景。理解它们的特点和应用场景，对于设计高效的算法和数据结构具有重要意义。

</span>