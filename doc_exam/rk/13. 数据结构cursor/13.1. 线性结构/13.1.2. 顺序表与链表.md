# 13.1.2. 顺序表与链表

## 概述
顺序表和链表是线性表的两种主要存储实现方式。顺序表使用数组实现，链表使用指针实现，两者在存储方式、操作效率和应用场景上都有显著差异。

## 顺序表（Sequential List）

### 定义
顺序表是使用数组实现的线性表，数据元素在内存中连续存储，通过数组下标来访问元素。

### 特点
1. **连续存储**：所有元素在内存中连续存放
2. **随机访问**：可以通过下标直接访问任意位置的元素
3. **空间固定**：数组大小在创建时确定，不易动态调整
4. **缓存友好**：连续存储有利于CPU缓存

### 存储结构
```
内存地址: 1000  1004  1008  1012  1016  1020
数组下标:   0     1     2     3     4     5
元素值:    A     B     C     D     E     F
```

### 基本操作

#### 1. 插入操作
- **时间复杂度**：O(n)
- **操作步骤**：
  1. 检查插入位置是否合法
  2. 检查数组是否已满，如满则扩容
  3. 将插入位置及之后的元素向后移动
  4. 在插入位置放入新元素
  5. 表长加1

#### 2. 删除操作
- **时间复杂度**：O(n)
- **操作步骤**：
  1. 检查删除位置是否合法
  2. 保存要删除的元素
  3. 将删除位置之后的元素向前移动
  4. 表长减1
  5. 返回被删除的元素

#### 3. 查找操作
- **时间复杂度**：O(n)
- **操作步骤**：从第一个元素开始逐个比较

#### 4. 访问操作
- **时间复杂度**：O(1)
- **操作步骤**：直接通过数组下标访问

### 优缺点

#### 优点
1. **随机访问**：可以通过下标直接访问任意元素
2. **空间效率**：不需要额外的指针空间
3. **缓存友好**：连续存储有利于CPU缓存
4. **实现简单**：逻辑简单，易于理解和实现

#### 缺点
1. **插入删除效率低**：需要移动大量元素
2. **空间固定**：数组大小固定，可能浪费空间或空间不足
3. **扩容开销**：动态扩容需要重新分配内存和复制数据

## 链表（Linked List）

### 定义
链表是使用指针实现的线性表，数据元素在内存中可以不连续存储，通过指针连接各个节点。

### 特点
1. **动态存储**：节点在内存中可以不连续
2. **动态大小**：可以根据需要动态增加或减少节点
3. **顺序访问**：只能从头节点开始顺序访问
4. **指针开销**：每个节点需要额外的指针空间

### 存储结构
```
节点1: [数据A|指针] -> 节点2: [数据B|指针] -> 节点3: [数据C|NULL]
地址:   1000             2000             3000
```

### 链表类型

#### 1. 单链表（Singly Linked List）
- 每个节点包含数据和指向下一个节点的指针
- 只能从头到尾遍历

#### 2. 双链表（Doubly Linked List）
- 每个节点包含数据和指向前后两个节点的指针
- 可以双向遍历

#### 3. 循环链表（Circular Linked List）
- 最后一个节点的指针指向第一个节点
- 可以循环遍历

### 基本操作

#### 1. 插入操作
- **时间复杂度**：O(1)（已知插入位置）
- **操作步骤**：
  1. 创建新节点
  2. 修改相关指针
  3. 表长加1

#### 2. 删除操作
- **时间复杂度**：O(1)（已知删除位置）
- **操作步骤**：
  1. 找到要删除的节点
  2. 修改相关指针
  3. 释放节点内存
  4. 表长减1

#### 3. 查找操作
- **时间复杂度**：O(n)
- **操作步骤**：从头节点开始顺序遍历

#### 4. 访问操作
- **时间复杂度**：O(n)
- **操作步骤**：从头节点开始顺序遍历到目标位置

### 优缺点

#### 优点
1. **动态大小**：可以根据需要动态调整大小
2. **插入删除效率高**：只需要修改指针
3. **空间利用率高**：按需分配内存
4. **灵活性好**：可以轻松实现各种链表结构

#### 缺点
1. **顺序访问**：不能随机访问，必须从头开始遍历
2. **指针开销**：每个节点需要额外的指针空间
3. **缓存不友好**：节点分散存储，不利于CPU缓存
4. **实现复杂**：指针操作容易出错

## 顺序表与链表的比较

### 存储方式
| 特性 | 顺序表 | 链表 |
|------|--------|------|
| 存储方式 | 连续存储 | 分散存储 |
| 空间分配 | 静态分配 | 动态分配 |
| 空间利用率 | 可能浪费 | 按需分配 |

### 操作效率
| 操作 | 顺序表 | 链表 |
|------|--------|------|
| 随机访问 | O(1) | O(n) |
| 顺序访问 | O(1) | O(1) |
| 插入（已知位置） | O(n) | O(1) |
| 删除（已知位置） | O(n) | O(1) |
| 查找 | O(n) | O(n) |

### 空间复杂度
| 特性 | 顺序表 | 链表 |
|------|--------|------|
| 额外空间 | 无 | 每个节点一个指针 |
| 空间开销 | 数组大小固定 | 动态调整 |
| 内存碎片 | 无 | 可能有 |

## 应用场景

### 顺序表适用场景
1. **频繁随机访问**：需要频繁访问任意位置的元素
2. **数据量相对固定**：数据量变化不大的情况
3. **内存充足**：对内存使用要求不严格
4. **简单应用**：逻辑简单，不需要复杂的动态操作

### 链表适用场景
1. **频繁插入删除**：需要频繁进行插入和删除操作
2. **数据量变化大**：数据量经常变化的情况
3. **内存受限**：对内存使用要求严格
4. **复杂应用**：需要实现复杂的链表结构

## 选择原则

### 选择顺序表的情况
- 需要频繁随机访问元素
- 数据量相对稳定
- 对内存使用要求不严格
- 实现简单性要求高

### 选择链表的情况
- 需要频繁插入和删除操作
- 数据量变化较大
- 对内存使用要求严格
- 需要实现特殊的链表结构

## 总结
顺序表和链表各有优缺点，在实际应用中需要根据具体需求选择合适的数据结构。理解两者的特点和适用场景，对于设计高效的数据结构解决方案具有重要意义。
