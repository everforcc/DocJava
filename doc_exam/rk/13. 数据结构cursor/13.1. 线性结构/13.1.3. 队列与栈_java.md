# 13.1.3. 队列与栈 - Java代码示例

## 栈接口定义

```java
/**
 * 栈接口
 */
public interface Stack<T> {
    /**
     * 入栈
     */
    void push(T element);
    
    /**
     * 出栈
     */
    T pop();
    
    /**
     * 查看栈顶元素
     */
    T peek();
    
    /**
     * 判断是否为空
     */
    boolean isEmpty();
    
    /**
     * 获取栈大小
     */
    int size();
}
```

## 顺序栈实现

```java
/**
 * 顺序栈实现
 */
public class ArrayStack<T> implements Stack<T> {
    private Object[] data;
    private int top;        // 栈顶指针
    private int capacity;
    private static final int DEFAULT_CAPACITY = 10;
    
    public ArrayStack() {
        this(DEFAULT_CAPACITY);
    }
    
    public ArrayStack(int capacity) {
        this.capacity = capacity;
        this.data = new Object[capacity];
        this.top = 0;
    }
    
    @Override
    public void push(T element) {
        if (top >= capacity) {
            throw new RuntimeException("栈已满");
        }
        data[top++] = element;
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public T pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈为空");
        }
        return (T) data[--top];
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public T peek() {
        if (isEmpty()) {
            throw new RuntimeException("栈为空");
        }
        return (T) data[top - 1];
    }
    
    @Override
    public boolean isEmpty() {
        return top == 0;
    }
    
    @Override
    public int size() {
        return top;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("ArrayStack[");
        for (int i = 0; i < top; i++) {
            sb.append(data[i]);
            if (i < top - 1) {
                sb.append(", ");
            }
        }
        sb.append("]");
        return sb.toString();
    }
}
```

## 链式栈实现

```java
/**
 * 链式栈节点
 */
class StackNode<T> {
    T data;
    StackNode<T> next;
    
    public StackNode(T data) {
        this.data = data;
        this.next = null;
    }
}

/**
 * 链式栈实现
 */
public class LinkedStack<T> implements Stack<T> {
    private StackNode<T> top;
    private int size;
    
    public LinkedStack() {
        this.top = null;
        this.size = 0;
    }
    
    @Override
    public void push(T element) {
        StackNode<T> newNode = new StackNode<>(element);
        newNode.next = top;
        top = newNode;
        size++;
    }
    
    @Override
    public T pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈为空");
        }
        T element = top.data;
        top = top.next;
        size--;
        return element;
    }
    
    @Override
    public T peek() {
        if (isEmpty()) {
            throw new RuntimeException("栈为空");
        }
        return top.data;
    }
    
    @Override
    public boolean isEmpty() {
        return top == null;
    }
    
    @Override
    public int size() {
        return size;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("LinkedStack[");
        StackNode<T> current = top;
        while (current != null) {
            sb.append(current.data);
            if (current.next != null) {
                sb.append(", ");
            }
            current = current.next;
        }
        sb.append("]");
        return sb.toString();
    }
}
```

## 队列接口定义

```java
/**
 * 队列接口
 */
public interface Queue<T> {
    /**
     * 入队
     */
    void enqueue(T element);
    
    /**
     * 出队
     */
    T dequeue();
    
    /**
     * 查看队头元素
     */
    T front();
    
    /**
     * 判断是否为空
     */
    boolean isEmpty();
    
    /**
     * 获取队列大小
     */
    int size();
}
```

## 循环队列实现

```java
/**
 * 循环队列实现
 */
public class CircularQueue<T> implements Queue<T> {
    private Object[] data;
    private int front;      // 队头指针
    private int rear;       // 队尾指针
    private int capacity;
    private static final int DEFAULT_CAPACITY = 10;
    
    public CircularQueue() {
        this(DEFAULT_CAPACITY);
    }
    
    public CircularQueue(int capacity) {
        this.capacity = capacity + 1;  // 多分配一个空间用于区分空和满
        this.data = new Object[this.capacity];
        this.front = 0;
        this.rear = 0;
    }
    
    @Override
    public void enqueue(T element) {
        if (isFull()) {
            throw new RuntimeException("队列已满");
        }
        data[rear] = element;
        rear = (rear + 1) % capacity;
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public T dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        T element = (T) data[front];
        front = (front + 1) % capacity;
        return element;
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public T front() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        return (T) data[front];
    }
    
    @Override
    public boolean isEmpty() {
        return front == rear;
    }
    
    @Override
    public int size() {
        return (rear - front + capacity) % capacity;
    }
    
    /**
     * 判断队列是否已满
     */
    public boolean isFull() {
        return (rear + 1) % capacity == front;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("CircularQueue[");
        int count = 0;
        int current = front;
        while (current != rear) {
            sb.append(data[current]);
            if ((current + 1) % capacity != rear) {
                sb.append(", ");
            }
            current = (current + 1) % capacity;
            count++;
        }
        sb.append("]");
        return sb.toString();
    }
}
```

## 链式队列实现

```java
/**
 * 链式队列节点
 */
class QueueNode<T> {
    T data;
    QueueNode<T> next;
    
    public QueueNode(T data) {
        this.data = data;
        this.next = null;
    }
}

/**
 * 链式队列实现
 */
public class LinkedQueue<T> implements Queue<T> {
    private QueueNode<T> front;  // 队头指针
    private QueueNode<T> rear;   // 队尾指针
    private int size;
    
    public LinkedQueue() {
        this.front = null;
        this.rear = null;
        this.size = 0;
    }
    
    @Override
    public void enqueue(T element) {
        QueueNode<T> newNode = new QueueNode<>(element);
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear.next = newNode;
            rear = newNode;
        }
        size++;
    }
    
    @Override
    public T dequeue() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        T element = front.data;
        front = front.next;
        if (front == null) {
            rear = null;
        }
        size--;
        return element;
    }
    
    @Override
    public T front() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        return front.data;
    }
    
    @Override
    public boolean isEmpty() {
        return front == null;
    }
    
    @Override
    public int size() {
        return size;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("LinkedQueue[");
        QueueNode<T> current = front;
        while (current != null) {
            sb.append(current.data);
            if (current.next != null) {
                sb.append(", ");
            }
            current = current.next;
        }
        sb.append("]");
        return sb.toString();
    }
}
```

## 双端队列实现

```java
/**
 * 双端队列接口
 */
public interface Deque<T> {
    /**
     * 在队头插入
     */
    void addFirst(T element);
    
    /**
     * 在队尾插入
     */
    void addLast(T element);
    
    /**
     * 删除队头元素
     */
    T removeFirst();
    
    /**
     * 删除队尾元素
     */
    T removeLast();
    
    /**
     * 获取队头元素
     */
    T getFirst();
    
    /**
     * 获取队尾元素
     */
    T getLast();
    
    /**
     * 判断是否为空
     */
    boolean isEmpty();
    
    /**
     * 获取队列大小
     */
    int size();
}

/**
 * 双端队列实现
 */
public class ArrayDeque<T> implements Deque<T> {
    private Object[] data;
    private int front;
    private int rear;
    private int capacity;
    private static final int DEFAULT_CAPACITY = 10;
    
    public ArrayDeque() {
        this(DEFAULT_CAPACITY);
    }
    
    public ArrayDeque(int capacity) {
        this.capacity = capacity + 1;
        this.data = new Object[this.capacity];
        this.front = 0;
        this.rear = 0;
    }
    
    @Override
    public void addFirst(T element) {
        if (isFull()) {
            throw new RuntimeException("双端队列已满");
        }
        front = (front - 1 + capacity) % capacity;
        data[front] = element;
    }
    
    @Override
    public void addLast(T element) {
        if (isFull()) {
            throw new RuntimeException("双端队列已满");
        }
        data[rear] = element;
        rear = (rear + 1) % capacity;
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public T removeFirst() {
        if (isEmpty()) {
            throw new RuntimeException("双端队列为空");
        }
        T element = (T) data[front];
        front = (front + 1) % capacity;
        return element;
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public T removeLast() {
        if (isEmpty()) {
            throw new RuntimeException("双端队列为空");
        }
        rear = (rear - 1 + capacity) % capacity;
        return (T) data[rear];
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public T getFirst() {
        if (isEmpty()) {
            throw new RuntimeException("双端队列为空");
        }
        return (T) data[front];
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public T getLast() {
        if (isEmpty()) {
            throw new RuntimeException("双端队列为空");
        }
        int lastIndex = (rear - 1 + capacity) % capacity;
        return (T) data[lastIndex];
    }
    
    @Override
    public boolean isEmpty() {
        return front == rear;
    }
    
    @Override
    public int size() {
        return (rear - front + capacity) % capacity;
    }
    
    private boolean isFull() {
        return (rear + 1) % capacity == front;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("ArrayDeque[");
        int current = front;
        while (current != rear) {
            sb.append(data[current]);
            if ((current + 1) % capacity != rear) {
                sb.append(", ");
            }
            current = (current + 1) % capacity;
        }
        sb.append("]");
        return sb.toString();
    }
}
```

## 栈的应用示例

### 括号匹配

```java
/**
 * 括号匹配检查器
 */
public class BracketMatcher {
    /**
     * 检查括号是否匹配
     */
    public static boolean isMatched(String expression) {
        Stack<Character> stack = new LinkedStack<>();
        
        for (char c : expression.toCharArray()) {
            if (isLeftBracket(c)) {
                stack.push(c);
            } else if (isRightBracket(c)) {
                if (stack.isEmpty()) {
                    return false;
                }
                char left = stack.pop();
                if (!isMatching(left, c)) {
                    return false;
                }
            }
        }
        
        return stack.isEmpty();
    }
    
    private static boolean isLeftBracket(char c) {
        return c == '(' || c == '[' || c == '{';
    }
    
    private static boolean isRightBracket(char c) {
        return c == ')' || c == ']' || c == '}';
    }
    
    private static boolean isMatching(char left, char right) {
        return (left == '(' && right == ')') ||
               (left == '[' && right == ']') ||
               (left == '{' && right == '}');
    }
    
    public static void main(String[] args) {
        String[] expressions = {
            "()",
            "()[]{}",
            "([{}])",
            "([)]",
            "((())",
            "())"
        };
        
        for (String expr : expressions) {
            System.out.println(expr + " -> " + isMatched(expr));
        }
    }
}
```

### 中缀表达式转后缀表达式

```java
/**
 * 表达式转换器
 */
public class ExpressionConverter {
    /**
     * 中缀表达式转后缀表达式
     */
    public static String infixToPostfix(String infix) {
        Stack<Character> stack = new LinkedStack<>();
        StringBuilder postfix = new StringBuilder();
        
        for (char c : infix.toCharArray()) {
            if (Character.isDigit(c)) {
                postfix.append(c);
            } else if (c == '(') {
                stack.push(c);
            } else if (c == ')') {
                while (!stack.isEmpty() && stack.peek() != '(') {
                    postfix.append(stack.pop());
                }
                stack.pop(); // 弹出 '('
            } else if (isOperator(c)) {
                while (!stack.isEmpty() && 
                       stack.peek() != '(' && 
                       getPrecedence(stack.peek()) >= getPrecedence(c)) {
                    postfix.append(stack.pop());
                }
                stack.push(c);
            }
        }
        
        while (!stack.isEmpty()) {
            postfix.append(stack.pop());
        }
        
        return postfix.toString();
    }
    
    private static boolean isOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/';
    }
    
    private static int getPrecedence(char op) {
        switch (op) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            default:
                return 0;
        }
    }
    
    public static void main(String[] args) {
        String infix = "a+b*c-d";
        String postfix = infixToPostfix(infix);
        System.out.println("中缀表达式: " + infix);
        System.out.println("后缀表达式: " + postfix);
    }
}
```

## 队列的应用示例

### 广度优先搜索

```java
/**
 * 图的广度优先搜索
 */
public class GraphBFS {
    private int[][] graph;
    private boolean[] visited;
    private int vertices;
    
    public GraphBFS(int vertices) {
        this.vertices = vertices;
        this.graph = new int[vertices][vertices];
        this.visited = new boolean[vertices];
    }
    
    /**
     * 添加边
     */
    public void addEdge(int from, int to) {
        graph[from][to] = 1;
        graph[to][from] = 1; // 无向图
    }
    
    /**
     * 广度优先搜索
     */
    public void bfs(int start) {
        Queue<Integer> queue = new LinkedQueue<>();
        queue.enqueue(start);
        visited[start] = true;
        
        System.out.print("BFS遍历: ");
        while (!queue.isEmpty()) {
            int vertex = queue.dequeue();
            System.out.print(vertex + " ");
            
            for (int i = 0; i < vertices; i++) {
                if (graph[vertex][i] == 1 && !visited[i]) {
                    visited[i] = true;
                    queue.enqueue(i);
                }
            }
        }
        System.out.println();
    }
    
    public static void main(String[] args) {
        GraphBFS graph = new GraphBFS(6);
        
        // 添加边
        graph.addEdge(0, 1);
        graph.addEdge(0, 2);
        graph.addEdge(1, 3);
        graph.addEdge(1, 4);
        graph.addEdge(2, 5);
        
        // 从顶点0开始BFS
        graph.bfs(0);
    }
}
```

## 测试代码

```java
/**
 * 栈与队列测试类
 */
public class StackQueueTest {
    public static void main(String[] args) {
        System.out.println("=== 栈测试 ===");
        testStack();
        
        System.out.println("\n=== 队列测试 ===");
        testQueue();
        
        System.out.println("\n=== 双端队列测试 ===");
        testDeque();
        
        System.out.println("\n=== 应用示例测试 ===");
        testApplications();
    }
    
    /**
     * 测试栈
     */
    public static void testStack() {
        Stack<Integer> stack = new ArrayStack<>();
        
        // 入栈
        for (int i = 1; i <= 5; i++) {
            stack.push(i);
        }
        System.out.println("入栈后: " + stack);
        
        // 查看栈顶
        System.out.println("栈顶元素: " + stack.peek());
        
        // 出栈
        while (!stack.isEmpty()) {
            System.out.print(stack.pop() + " ");
        }
        System.out.println();
    }
    
    /**
     * 测试队列
     */
    public static void testQueue() {
        Queue<String> queue = new CircularQueue<>();
        
        // 入队
        queue.enqueue("A");
        queue.enqueue("B");
        queue.enqueue("C");
        System.out.println("入队后: " + queue);
        
        // 查看队头
        System.out.println("队头元素: " + queue.front());
        
        // 出队
        while (!queue.isEmpty()) {
            System.out.print(queue.dequeue() + " ");
        }
        System.out.println();
    }
    
    /**
     * 测试双端队列
     */
    public static void testDeque() {
        Deque<Integer> deque = new ArrayDeque<>();
        
        // 在两端添加元素
        deque.addFirst(1);
        deque.addLast(2);
        deque.addFirst(3);
        deque.addLast(4);
        System.out.println("添加后: " + deque);
        
        // 查看两端元素
        System.out.println("队头: " + deque.getFirst());
        System.out.println("队尾: " + deque.getLast());
        
        // 从两端删除元素
        System.out.println("删除队头: " + deque.removeFirst());
        System.out.println("删除队尾: " + deque.removeLast());
        System.out.println("删除后: " + deque);
    }
    
    /**
     * 测试应用示例
     */
    public static void testApplications() {
        // 测试括号匹配
        System.out.println("=== 括号匹配测试 ===");
        String[] expressions = {"()", "()[]{}", "([)]", "((())"};
        for (String expr : expressions) {
            System.out.println(expr + " -> " + BracketMatcher.isMatched(expr));
        }
        
        // 测试表达式转换
        System.out.println("\n=== 表达式转换测试 ===");
        String infix = "a+b*c-d";
        String postfix = ExpressionConverter.infixToPostfix(infix);
        System.out.println("中缀: " + infix);
        System.out.println("后缀: " + postfix);
    }
}
```
