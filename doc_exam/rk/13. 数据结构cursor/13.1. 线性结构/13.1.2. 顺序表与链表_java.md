# 13.1.2. 顺序表与链表 - Java代码示例

## 顺序表实现

```java
/**
 * 顺序表实现
 * 使用数组实现线性表
 */
public class SequentialList<T> {
    private Object[] data;     // 存储数据的数组
    private int size;          // 当前元素个数
    private int capacity;      // 数组容量
    private static final int DEFAULT_CAPACITY = 10;
    
    /**
     * 构造函数
     */
    public SequentialList() {
        this(DEFAULT_CAPACITY);
    }
    
    public SequentialList(int capacity) {
        this.capacity = capacity;
        this.data = new Object[capacity];
        this.size = 0;
    }
    
    /**
     * 判断是否为空
     */
    public boolean isEmpty() {
        return size == 0;
    }
    
    /**
     * 获取长度
     */
    public int length() {
        return size;
    }
    
    /**
     * 获取容量
     */
    public int capacity() {
        return capacity;
    }
    
    /**
     * 获取指定位置的元素
     */
    @SuppressWarnings("unchecked")
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        return (T) data[index];
    }
    
    /**
     * 设置指定位置的元素
     */
    public void set(int index, T element) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        data[index] = element;
    }
    
    /**
     * 在指定位置插入元素
     */
    public void insert(int index, T element) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        // 检查容量，如果不够则扩容
        if (size >= capacity) {
            resize();
        }
        
        // 将index及之后的元素向后移动
        for (int i = size; i > index; i--) {
            data[i] = data[i - 1];
        }
        
        // 插入新元素
        data[index] = element;
        size++;
    }
    
    /**
     * 在末尾添加元素
     */
    public void add(T element) {
        insert(size, element);
    }
    
    /**
     * 删除指定位置的元素
     */
    @SuppressWarnings("unchecked")
    public T remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        T element = (T) data[index];
        
        // 将index之后的元素向前移动
        for (int i = index; i < size - 1; i++) {
            data[i] = data[i + 1];
        }
        
        size--;
        return element;
    }
    
    /**
     * 查找元素的位置
     */
    public int indexOf(T element) {
        for (int i = 0; i < size; i++) {
            if (Objects.equals(data[i], element)) {
                return i;
            }
        }
        return -1;  // 未找到
    }
    
    /**
     * 判断是否包含指定元素
     */
    public boolean contains(T element) {
        return indexOf(element) != -1;
    }
    
    /**
     * 清空顺序表
     */
    public void clear() {
        size = 0;
    }
    
    /**
     * 扩容操作
     */
    private void resize() {
        capacity *= 2;
        Object[] newData = new Object[capacity];
        System.arraycopy(data, 0, newData, 0, size);
        data = newData;
        System.out.println("顺序表扩容至: " + capacity);
    }
    
    /**
     * 转换为数组
     */
    @SuppressWarnings("unchecked")
    public T[] toArray() {
        T[] array = (T[]) new Object[size];
        System.arraycopy(data, 0, array, 0, size);
        return array;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("SequentialList[");
        for (int i = 0; i < size; i++) {
            sb.append(data[i]);
            if (i < size - 1) {
                sb.append(", ");
            }
        }
        sb.append("]");
        return sb.toString();
    }
}
```

## 单链表实现

```java
/**
 * 单链表节点
 */
class SingleListNode<T> {
    T data;
    SingleListNode<T> next;
    
    public SingleListNode(T data) {
        this.data = data;
        this.next = null;
    }
    
    public SingleListNode(T data, SingleListNode<T> next) {
        this.data = data;
        this.next = next;
    }
}

/**
 * 单链表实现
 */
public class SingleLinkedList<T> {
    private SingleListNode<T> head;  // 头节点
    private int size;                // 元素个数
    
    public SingleLinkedList() {
        this.head = null;
        this.size = 0;
    }
    
    /**
     * 判断是否为空
     */
    public boolean isEmpty() {
        return size == 0;
    }
    
    /**
     * 获取长度
     */
    public int length() {
        return size;
    }
    
    /**
     * 获取指定位置的元素
     */
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        SingleListNode<T> current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }
        return current.data;
    }
    
    /**
     * 设置指定位置的元素
     */
    public void set(int index, T element) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        SingleListNode<T> current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }
        current.data = element;
    }
    
    /**
     * 在指定位置插入元素
     */
    public void insert(int index, T element) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        SingleListNode<T> newNode = new SingleListNode<>(element);
        
        if (index == 0) {
            // 在头部插入
            newNode.next = head;
            head = newNode;
        } else {
            // 找到插入位置的前一个节点
            SingleListNode<T> current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current.next;
            }
            newNode.next = current.next;
            current.next = newNode;
        }
        size++;
    }
    
    /**
     * 在头部插入元素
     */
    public void addFirst(T element) {
        insert(0, element);
    }
    
    /**
     * 在尾部插入元素
     */
    public void addLast(T element) {
        insert(size, element);
    }
    
    /**
     * 删除指定位置的元素
     */
    public T remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        T element;
        if (index == 0) {
            // 删除头节点
            element = head.data;
            head = head.next;
        } else {
            // 找到要删除节点的前一个节点
            SingleListNode<T> current = head;
            for (int i = 0; i < index - 1; i++) {
                current = current.next;
            }
            element = current.next.data;
            current.next = current.next.next;
        }
        size--;
        return element;
    }
    
    /**
     * 删除头部元素
     */
    public T removeFirst() {
        return remove(0);
    }
    
    /**
     * 删除尾部元素
     */
    public T removeLast() {
        return remove(size - 1);
    }
    
    /**
     * 查找元素的位置
     */
    public int indexOf(T element) {
        SingleListNode<T> current = head;
        int index = 0;
        while (current != null) {
            if (Objects.equals(current.data, element)) {
                return index;
            }
            current = current.next;
            index++;
        }
        return -1;  // 未找到
    }
    
    /**
     * 判断是否包含指定元素
     */
    public boolean contains(T element) {
        return indexOf(element) != -1;
    }
    
    /**
     * 清空链表
     */
    public void clear() {
        head = null;
        size = 0;
    }
    
    /**
     * 反转链表
     */
    public void reverse() {
        SingleListNode<T> prev = null;
        SingleListNode<T> current = head;
        SingleListNode<T> next;
        
        while (current != null) {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        head = prev;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("SingleLinkedList[");
        SingleListNode<T> current = head;
        while (current != null) {
            sb.append(current.data);
            if (current.next != null) {
                sb.append(", ");
            }
            current = current.next;
        }
        sb.append("]");
        return sb.toString();
    }
}
```

## 双链表实现

```java
/**
 * 双链表节点
 */
class DoubleListNode<T> {
    T data;
    DoubleListNode<T> prev;
    DoubleListNode<T> next;
    
    public DoubleListNode(T data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
    
    public DoubleListNode(T data, DoubleListNode<T> prev, DoubleListNode<T> next) {
        this.data = data;
        this.prev = prev;
        this.next = next;
    }
}

/**
 * 双链表实现
 */
public class DoubleLinkedList<T> {
    private DoubleListNode<T> head;  // 头节点
    private DoubleListNode<T> tail;  // 尾节点
    private int size;                // 元素个数
    
    public DoubleLinkedList() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    
    /**
     * 判断是否为空
     */
    public boolean isEmpty() {
        return size == 0;
    }
    
    /**
     * 获取长度
     */
    public int length() {
        return size;
    }
    
    /**
     * 获取指定位置的元素
     */
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        DoubleListNode<T> current;
        if (index < size / 2) {
            // 从头开始查找
            current = head;
            for (int i = 0; i < index; i++) {
                current = current.next;
            }
        } else {
            // 从尾开始查找
            current = tail;
            for (int i = size - 1; i > index; i--) {
                current = current.prev;
            }
        }
        return current.data;
    }
    
    /**
     * 设置指定位置的元素
     */
    public void set(int index, T element) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        DoubleListNode<T> current;
        if (index < size / 2) {
            current = head;
            for (int i = 0; i < index; i++) {
                current = current.next;
            }
        } else {
            current = tail;
            for (int i = size - 1; i > index; i--) {
                current = current.prev;
            }
        }
        current.data = element;
    }
    
    /**
     * 在指定位置插入元素
     */
    public void insert(int index, T element) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        DoubleListNode<T> newNode = new DoubleListNode<>(element);
        
        if (size == 0) {
            // 空链表
            head = tail = newNode;
        } else if (index == 0) {
            // 在头部插入
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
        } else if (index == size) {
            // 在尾部插入
            newNode.prev = tail;
            tail.next = newNode;
            tail = newNode;
        } else {
            // 在中间插入
            DoubleListNode<T> current = getNode(index);
            newNode.prev = current.prev;
            newNode.next = current;
            current.prev.next = newNode;
            current.prev = newNode;
        }
        size++;
    }
    
    /**
     * 在头部插入元素
     */
    public void addFirst(T element) {
        insert(0, element);
    }
    
    /**
     * 在尾部插入元素
     */
    public void addLast(T element) {
        insert(size, element);
    }
    
    /**
     * 删除指定位置的元素
     */
    public T remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        DoubleListNode<T> current = getNode(index);
        T element = current.data;
        
        if (size == 1) {
            // 只有一个元素
            head = tail = null;
        } else if (current == head) {
            // 删除头节点
            head = head.next;
            head.prev = null;
        } else if (current == tail) {
            // 删除尾节点
            tail = tail.prev;
            tail.next = null;
        } else {
            // 删除中间节点
            current.prev.next = current.next;
            current.next.prev = current.prev;
        }
        size--;
        return element;
    }
    
    /**
     * 删除头部元素
     */
    public T removeFirst() {
        return remove(0);
    }
    
    /**
     * 删除尾部元素
     */
    public T removeLast() {
        return remove(size - 1);
    }
    
    /**
     * 查找元素的位置
     */
    public int indexOf(T element) {
        DoubleListNode<T> current = head;
        int index = 0;
        while (current != null) {
            if (Objects.equals(current.data, element)) {
                return index;
            }
            current = current.next;
            index++;
        }
        return -1;  // 未找到
    }
    
    /**
     * 判断是否包含指定元素
     */
    public boolean contains(T element) {
        return indexOf(element) != -1;
    }
    
    /**
     * 清空链表
     */
    public void clear() {
        head = null;
        tail = null;
        size = 0;
    }
    
    /**
     * 获取指定位置的节点
     */
    private DoubleListNode<T> getNode(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        DoubleListNode<T> current;
        if (index < size / 2) {
            current = head;
            for (int i = 0; i < index; i++) {
                current = current.next;
            }
        } else {
            current = tail;
            for (int i = size - 1; i > index; i--) {
                current = current.prev;
            }
        }
        return current;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("DoubleLinkedList[");
        DoubleListNode<T> current = head;
        while (current != null) {
            sb.append(current.data);
            if (current.next != null) {
                sb.append(", ");
            }
            current = current.next;
        }
        sb.append("]");
        return sb.toString();
    }
}
```

## 测试代码

```java
/**
 * 顺序表与链表测试类
 */
public class ListTest {
    public static void main(String[] args) {
        System.out.println("=== 顺序表测试 ===");
        testSequentialList();
        
        System.out.println("\n=== 单链表测试 ===");
        testSingleLinkedList();
        
        System.out.println("\n=== 双链表测试 ===");
        testDoubleLinkedList();
        
        System.out.println("\n=== 性能比较测试 ===");
        performanceComparison();
    }
    
    /**
     * 测试顺序表
     */
    public static void testSequentialList() {
        SequentialList<Integer> list = new SequentialList<>();
        
        // 添加元素
        for (int i = 1; i <= 5; i++) {
            list.add(i);
        }
        System.out.println("添加元素后: " + list);
        
        // 插入元素
        list.insert(2, 99);
        System.out.println("在位置2插入99后: " + list);
        
        // 删除元素
        int removed = list.remove(3);
        System.out.println("删除位置3的元素: " + removed);
        System.out.println("删除后: " + list);
        
        // 查找元素
        int index = list.indexOf(99);
        System.out.println("元素99的位置: " + index);
    }
    
    /**
     * 测试单链表
     */
    public static void testSingleLinkedList() {
        SingleLinkedList<String> list = new SingleLinkedList<>();
        
        // 添加元素
        list.addLast("Hello");
        list.addLast("World");
        list.addLast("Java");
        System.out.println("添加元素后: " + list);
        
        // 在头部插入
        list.addFirst("Start");
        System.out.println("在头部插入后: " + list);
        
        // 反转链表
        list.reverse();
        System.out.println("反转后: " + list);
        
        // 删除元素
        String removed = list.removeFirst();
        System.out.println("删除头部元素: " + removed);
        System.out.println("删除后: " + list);
    }
    
    /**
     * 测试双链表
     */
    public static void testDoubleLinkedList() {
        DoubleLinkedList<Character> list = new DoubleLinkedList<>();
        
        // 添加元素
        list.addLast('A');
        list.addLast('B');
        list.addLast('C');
        System.out.println("添加元素后: " + list);
        
        // 在头部和尾部插入
        list.addFirst('X');
        list.addLast('Y');
        System.out.println("在头部和尾部插入后: " + list);
        
        // 删除元素
        Character removed = list.remove(2);
        System.out.println("删除位置2的元素: " + removed);
        System.out.println("删除后: " + list);
    }
    
    /**
     * 性能比较测试
     */
    public static void performanceComparison() {
        int n = 10000;
        
        // 测试顺序表插入性能
        long startTime = System.currentTimeMillis();
        SequentialList<Integer> seqList = new SequentialList<>();
        for (int i = 0; i < n; i++) {
            seqList.insert(0, i);  // 在头部插入
        }
        long seqTime = System.currentTimeMillis() - startTime;
        
        // 测试链表插入性能
        startTime = System.currentTimeMillis();
        SingleLinkedList<Integer> linkedList = new SingleLinkedList<>();
        for (int i = 0; i < n; i++) {
            linkedList.addFirst(i);  // 在头部插入
        }
        long linkTime = System.currentTimeMillis() - startTime;
        
        System.out.println("插入" + n + "个元素到头部:");
        System.out.println("顺序表耗时: " + seqTime + "ms");
        System.out.println("链表耗时: " + linkTime + "ms");
        
        // 测试随机访问性能
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            seqList.get(n / 2);
        }
        long seqAccessTime = System.currentTimeMillis() - startTime;
        
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            linkedList.get(n / 2);
        }
        long linkAccessTime = System.currentTimeMillis() - startTime;
        
        System.out.println("\n随机访问1000次:");
        System.out.println("顺序表耗时: " + seqAccessTime + "ms");
        System.out.println("链表耗时: " + linkAccessTime + "ms");
    }
}
```

## 应用示例：LRU缓存

```java
/**
 * LRU缓存实现
 * 使用双链表和哈希表实现
 */
public class LRUCache<K, V> {
    private final int capacity;
    private final Map<K, DoubleListNode<CacheNode<K, V>>> cache;
    private final DoubleLinkedList<CacheNode<K, V>> list;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        this.list = new DoubleLinkedList<>();
    }
    
    /**
     * 获取缓存值
     */
    public V get(K key) {
        DoubleListNode<CacheNode<K, V>> node = cache.get(key);
        if (node == null) {
            return null;
        }
        
        // 移动到头部
        moveToHead(node);
        return node.data.value;
    }
    
    /**
     * 设置缓存值
     */
    public void put(K key, V value) {
        DoubleListNode<CacheNode<K, V>> node = cache.get(key);
        
        if (node != null) {
            // 更新现有节点
            node.data.value = value;
            moveToHead(node);
        } else {
            // 添加新节点
            CacheNode<K, V> cacheNode = new CacheNode<>(key, value);
            DoubleListNode<CacheNode<K, V>> newNode = new DoubleListNode<>(cacheNode);
            
            if (cache.size() >= capacity) {
                // 删除尾部节点
                DoubleListNode<CacheNode<K, V>> tail = list.tail;
                cache.remove(tail.data.key);
                list.removeLast();
            }
            
            // 添加到头部
            list.addFirst(cacheNode);
            cache.put(key, list.head);
        }
    }
    
    /**
     * 移动节点到头部
     */
    private void moveToHead(DoubleListNode<CacheNode<K, V>> node) {
        // 从当前位置删除
        if (node.prev != null) {
            node.prev.next = node.next;
        }
        if (node.next != null) {
            node.next.prev = node.prev;
        }
        
        // 添加到头部
        node.prev = null;
        node.next = list.head;
        if (list.head != null) {
            list.head.prev = node;
        }
        list.head = node;
    }
    
    /**
     * 缓存节点
     */
    private static class CacheNode<K, V> {
        K key;
        V value;
        
        public CacheNode(K key, V value) {
            this.key = key;
            this.value = value;
        }
        
        @Override
        public String toString() {
            return key + "=" + value;
        }
    }
    
    @Override
    public String toString() {
        return "LRUCache" + list.toString();
    }
    
    public static void main(String[] args) {
        LRUCache<String, Integer> cache = new LRUCache<>(3);
        
        cache.put("A", 1);
        cache.put("B", 2);
        cache.put("C", 3);
        System.out.println("初始缓存: " + cache);
        
        cache.get("A");  // 访问A，A移动到头部
        System.out.println("访问A后: " + cache);
        
        cache.put("D", 4);  // 添加D，B被淘汰
        System.out.println("添加D后: " + cache);
    }
}
```
