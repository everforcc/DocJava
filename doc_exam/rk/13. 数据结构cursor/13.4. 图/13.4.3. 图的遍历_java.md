# 13.4.3. 图的遍历 - Java代码示例

## 图遍历接口定义

```java
/**
 * 图遍历接口
 */
public interface GraphTraversal {
    /**
     * 深度优先搜索（递归）
     */
    List<Integer> dfsRecursive(int start);
    
    /**
     * 深度优先搜索（迭代）
     */
    List<Integer> dfsIterative(int start);
    
    /**
     * 广度优先搜索
     */
    List<Integer> bfs(int start);
    
    /**
     * 获取连通分量
     */
    List<List<Integer>> getConnectedComponents();
    
    /**
     * 检测图中是否存在环
     */
    boolean hasCycle();
    
    /**
     * 获取从起点到终点的路径
     */
    List<Integer> getPath(int start, int end);
    
    /**
     * 获取最短路径（无权图）
     */
    List<Integer> getShortestPath(int start, int end);
}
```

## 基于邻接表的图遍历实现

```java
import java.util.*;

/**
 * 基于邻接表的图遍历实现
 */
public class AdjacencyListGraphTraversal implements GraphTraversal {
    private List<List<Integer>> adjList;
    private int vertexCount;
    private boolean isDirected;
    
    public AdjacencyListGraphTraversal(List<List<Integer>> adjList, boolean isDirected) {
        this.adjList = adjList;
        this.vertexCount = adjList.size();
        this.isDirected = isDirected;
    }
    
    @Override
    public List<Integer> dfsRecursive(int start) {
        if (start < 0 || start >= vertexCount) {
            throw new IllegalArgumentException("起始顶点超出范围");
        }
        
        List<Integer> result = new ArrayList<>();
        boolean[] visited = new boolean[vertexCount];
        
        dfsRecursiveHelper(start, visited, result);
        return result;
    }
    
    private void dfsRecursiveHelper(int vertex, boolean[] visited, List<Integer> result) {
        visited[vertex] = true;
        result.add(vertex);
        
        for (int neighbor : adjList.get(vertex)) {
            if (!visited[neighbor]) {
                dfsRecursiveHelper(neighbor, visited, result);
            }
        }
    }
    
    @Override
    public List<Integer> dfsIterative(int start) {
        if (start < 0 || start >= vertexCount) {
            throw new IllegalArgumentException("起始顶点超出范围");
        }
        
        List<Integer> result = new ArrayList<>();
        boolean[] visited = new boolean[vertexCount];
        Stack<Integer> stack = new Stack<>();
        
        stack.push(start);
        
        while (!stack.isEmpty()) {
            int vertex = stack.pop();
            
            if (!visited[vertex]) {
                visited[vertex] = true;
                result.add(vertex);
                
                // 将邻居按相反顺序入栈，以保持与递归版本相同的访问顺序
                List<Integer> neighbors = adjList.get(vertex);
                for (int i = neighbors.size() - 1; i >= 0; i--) {
                    int neighbor = neighbors.get(i);
                    if (!visited[neighbor]) {
                        stack.push(neighbor);
                    }
                }
            }
        }
        
        return result;
    }
    
    @Override
    public List<Integer> bfs(int start) {
        if (start < 0 || start >= vertexCount) {
            throw new IllegalArgumentException("起始顶点超出范围");
        }
        
        List<Integer> result = new ArrayList<>();
        boolean[] visited = new boolean[vertexCount];
        Queue<Integer> queue = new LinkedList<>();
        
        visited[start] = true;
        queue.offer(start);
        
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            result.add(vertex);
            
            for (int neighbor : adjList.get(vertex)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.offer(neighbor);
                }
            }
        }
        
        return result;
    }
    
    @Override
    public List<List<Integer>> getConnectedComponents() {
        List<List<Integer>> components = new ArrayList<>();
        boolean[] visited = new boolean[vertexCount];
        
        for (int i = 0; i < vertexCount; i++) {
            if (!visited[i]) {
                List<Integer> component = new ArrayList<>();
                dfsComponent(i, visited, component);
                components.add(component);
            }
        }
        
        return components;
    }
    
    private void dfsComponent(int vertex, boolean[] visited, List<Integer> component) {
        visited[vertex] = true;
        component.add(vertex);
        
        for (int neighbor : adjList.get(vertex)) {
            if (!visited[neighbor]) {
                dfsComponent(neighbor, visited, component);
            }
        }
    }
    
    @Override
    public boolean hasCycle() {
        boolean[] visited = new boolean[vertexCount];
        boolean[] recursionStack = new boolean[vertexCount];
        
        for (int i = 0; i < vertexCount; i++) {
            if (!visited[i]) {
                if (hasCycleDFS(i, visited, recursionStack)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    private boolean hasCycleDFS(int vertex, boolean[] visited, boolean[] recursionStack) {
        visited[vertex] = true;
        recursionStack[vertex] = true;
        
        for (int neighbor : adjList.get(vertex)) {
            if (!visited[neighbor]) {
                if (hasCycleDFS(neighbor, visited, recursionStack)) {
                    return true;
                }
            } else if (recursionStack[neighbor]) {
                return true;
            }
        }
        
        recursionStack[vertex] = false;
        return false;
    }
    
    @Override
    public List<Integer> getPath(int start, int end) {
        if (start < 0 || start >= vertexCount || end < 0 || end >= vertexCount) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        boolean[] visited = new boolean[vertexCount];
        List<Integer> path = new ArrayList<>();
        
        if (dfsPath(start, end, visited, path)) {
            return path;
        }
        
        return new ArrayList<>(); // 没有路径
    }
    
    private boolean dfsPath(int current, int end, boolean[] visited, List<Integer> path) {
        visited[current] = true;
        path.add(current);
        
        if (current == end) {
            return true;
        }
        
        for (int neighbor : adjList.get(current)) {
            if (!visited[neighbor]) {
                if (dfsPath(neighbor, end, visited, path)) {
                    return true;
                }
            }
        }
        
        path.remove(path.size() - 1);
        return false;
    }
    
    @Override
    public List<Integer> getShortestPath(int start, int end) {
        if (start < 0 || start >= vertexCount || end < 0 || end >= vertexCount) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        boolean[] visited = new boolean[vertexCount];
        int[] parent = new int[vertexCount];
        Arrays.fill(parent, -1);
        
        Queue<Integer> queue = new LinkedList<>();
        visited[start] = true;
        queue.offer(start);
        
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            
            if (vertex == end) {
                break;
            }
            
            for (int neighbor : adjList.get(vertex)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    parent[neighbor] = vertex;
                    queue.offer(neighbor);
                }
            }
        }
        
        // 重构路径
        List<Integer> path = new ArrayList<>();
        if (visited[end]) {
            int current = end;
            while (current != -1) {
                path.add(current);
                current = parent[current];
            }
            Collections.reverse(path);
        }
        
        return path;
    }
    
    /**
     * 获取所有路径
     */
    public List<List<Integer>> getAllPaths(int start, int end) {
        List<List<Integer>> allPaths = new ArrayList<>();
        boolean[] visited = new boolean[vertexCount];
        List<Integer> currentPath = new ArrayList<>();
        
        dfsAllPaths(start, end, visited, currentPath, allPaths);
        return allPaths;
    }
    
    private void dfsAllPaths(int current, int end, boolean[] visited, 
                           List<Integer> currentPath, List<List<Integer>> allPaths) {
        visited[current] = true;
        currentPath.add(current);
        
        if (current == end) {
            allPaths.add(new ArrayList<>(currentPath));
        } else {
            for (int neighbor : adjList.get(current)) {
                if (!visited[neighbor]) {
                    dfsAllPaths(neighbor, end, visited, currentPath, allPaths);
                }
            }
        }
        
        visited[current] = false;
        currentPath.remove(currentPath.size() - 1);
    }
    
    /**
     * 检测二分图
     */
    public boolean isBipartite() {
        int[] color = new int[vertexCount];
        Arrays.fill(color, -1);
        
        for (int i = 0; i < vertexCount; i++) {
            if (color[i] == -1) {
                if (!isBipartiteDFS(i, color)) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    private boolean isBipartiteDFS(int vertex, int[] color) {
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(vertex);
        color[vertex] = 0;
        
        while (!queue.isEmpty()) {
            int current = queue.poll();
            
            for (int neighbor : adjList.get(current)) {
                if (color[neighbor] == -1) {
                    color[neighbor] = 1 - color[current];
                    queue.offer(neighbor);
                } else if (color[neighbor] == color[current]) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    /**
     * 获取图的直径（最长路径）
     */
    public int getDiameter() {
        int maxDiameter = 0;
        
        for (int i = 0; i < vertexCount; i++) {
            int[] distances = bfsDistances(i);
            for (int distance : distances) {
                if (distance != Integer.MAX_VALUE) {
                    maxDiameter = Math.max(maxDiameter, distance);
                }
            }
        }
        
        return maxDiameter;
    }
    
    private int[] bfsDistances(int start) {
        int[] distances = new int[vertexCount];
        Arrays.fill(distances, Integer.MAX_VALUE);
        
        Queue<Integer> queue = new LinkedList<>();
        distances[start] = 0;
        queue.offer(start);
        
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            
            for (int neighbor : adjList.get(vertex)) {
                if (distances[neighbor] == Integer.MAX_VALUE) {
                    distances[neighbor] = distances[vertex] + 1;
                    queue.offer(neighbor);
                }
            }
        }
        
        return distances;
    }
}
```

## 基于邻接矩阵的图遍历实现

```java
/**
 * 基于邻接矩阵的图遍历实现
 */
public class AdjacencyMatrixGraphTraversal implements GraphTraversal {
    private int[][] matrix;
    private int vertexCount;
    private boolean isDirected;
    
    public AdjacencyMatrixGraphTraversal(int[][] matrix, boolean isDirected) {
        this.matrix = matrix;
        this.vertexCount = matrix.length;
        this.isDirected = isDirected;
    }
    
    @Override
    public List<Integer> dfsRecursive(int start) {
        if (start < 0 || start >= vertexCount) {
            throw new IllegalArgumentException("起始顶点超出范围");
        }
        
        List<Integer> result = new ArrayList<>();
        boolean[] visited = new boolean[vertexCount];
        
        dfsRecursiveHelper(start, visited, result);
        return result;
    }
    
    private void dfsRecursiveHelper(int vertex, boolean[] visited, List<Integer> result) {
        visited[vertex] = true;
        result.add(vertex);
        
        for (int i = 0; i < vertexCount; i++) {
            if (matrix[vertex][i] != 0 && !visited[i]) {
                dfsRecursiveHelper(i, visited, result);
            }
        }
    }
    
    @Override
    public List<Integer> dfsIterative(int start) {
        if (start < 0 || start >= vertexCount) {
            throw new IllegalArgumentException("起始顶点超出范围");
        }
        
        List<Integer> result = new ArrayList<>();
        boolean[] visited = new boolean[vertexCount];
        Stack<Integer> stack = new Stack<>();
        
        stack.push(start);
        
        while (!stack.isEmpty()) {
            int vertex = stack.pop();
            
            if (!visited[vertex]) {
                visited[vertex] = true;
                result.add(vertex);
                
                // 将邻居按相反顺序入栈
                for (int i = vertexCount - 1; i >= 0; i--) {
                    if (matrix[vertex][i] != 0 && !visited[i]) {
                        stack.push(i);
                    }
                }
            }
        }
        
        return result;
    }
    
    @Override
    public List<Integer> bfs(int start) {
        if (start < 0 || start >= vertexCount) {
            throw new IllegalArgumentException("起始顶点超出范围");
        }
        
        List<Integer> result = new ArrayList<>();
        boolean[] visited = new boolean[vertexCount];
        Queue<Integer> queue = new LinkedList<>();
        
        visited[start] = true;
        queue.offer(start);
        
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            result.add(vertex);
            
            for (int i = 0; i < vertexCount; i++) {
                if (matrix[vertex][i] != 0 && !visited[i]) {
                    visited[i] = true;
                    queue.offer(i);
                }
            }
        }
        
        return result;
    }
    
    @Override
    public List<List<Integer>> getConnectedComponents() {
        List<List<Integer>> components = new ArrayList<>();
        boolean[] visited = new boolean[vertexCount];
        
        for (int i = 0; i < vertexCount; i++) {
            if (!visited[i]) {
                List<Integer> component = new ArrayList<>();
                dfsComponent(i, visited, component);
                components.add(component);
            }
        }
        
        return components;
    }
    
    private void dfsComponent(int vertex, boolean[] visited, List<Integer> component) {
        visited[vertex] = true;
        component.add(vertex);
        
        for (int i = 0; i < vertexCount; i++) {
            if (matrix[vertex][i] != 0 && !visited[i]) {
                dfsComponent(i, visited, component);
            }
        }
    }
    
    @Override
    public boolean hasCycle() {
        boolean[] visited = new boolean[vertexCount];
        boolean[] recursionStack = new boolean[vertexCount];
        
        for (int i = 0; i < vertexCount; i++) {
            if (!visited[i]) {
                if (hasCycleDFS(i, visited, recursionStack)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    private boolean hasCycleDFS(int vertex, boolean[] visited, boolean[] recursionStack) {
        visited[vertex] = true;
        recursionStack[vertex] = true;
        
        for (int i = 0; i < vertexCount; i++) {
            if (matrix[vertex][i] != 0) {
                if (!visited[i]) {
                    if (hasCycleDFS(i, visited, recursionStack)) {
                        return true;
                    }
                } else if (recursionStack[i]) {
                    return true;
                }
            }
        }
        
        recursionStack[vertex] = false;
        return false;
    }
    
    @Override
    public List<Integer> getPath(int start, int end) {
        if (start < 0 || start >= vertexCount || end < 0 || end >= vertexCount) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        boolean[] visited = new boolean[vertexCount];
        List<Integer> path = new ArrayList<>();
        
        if (dfsPath(start, end, visited, path)) {
            return path;
        }
        
        return new ArrayList<>();
    }
    
    private boolean dfsPath(int current, int end, boolean[] visited, List<Integer> path) {
        visited[current] = true;
        path.add(current);
        
        if (current == end) {
            return true;
        }
        
        for (int i = 0; i < vertexCount; i++) {
            if (matrix[current][i] != 0 && !visited[i]) {
                if (dfsPath(i, end, visited, path)) {
                    return true;
                }
            }
        }
        
        path.remove(path.size() - 1);
        return false;
    }
    
    @Override
    public List<Integer> getShortestPath(int start, int end) {
        if (start < 0 || start >= vertexCount || end < 0 || end >= vertexCount) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        boolean[] visited = new boolean[vertexCount];
        int[] parent = new int[vertexCount];
        Arrays.fill(parent, -1);
        
        Queue<Integer> queue = new LinkedList<>();
        visited[start] = true;
        queue.offer(start);
        
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            
            if (vertex == end) {
                break;
            }
            
            for (int i = 0; i < vertexCount; i++) {
                if (matrix[vertex][i] != 0 && !visited[i]) {
                    visited[i] = true;
                    parent[i] = vertex;
                    queue.offer(i);
                }
            }
        }
        
        List<Integer> path = new ArrayList<>();
        if (visited[end]) {
            int current = end;
            while (current != -1) {
                path.add(current);
                current = parent[current];
            }
            Collections.reverse(path);
        }
        
        return path;
    }
}
```

## 图遍历工具类

```java
/**
 * 图遍历工具类
 */
public class GraphTraversalUtils {
    
    /**
     * 比较DFS和BFS的遍历结果
     */
    public static void compareTraversalMethods(GraphTraversal traversal, int start) {
        System.out.println("=== 图遍历方法比较 ===");
        System.out.println("起始顶点: " + start);
        
        // DFS递归
        long startTime = System.nanoTime();
        List<Integer> dfsRecursive = traversal.dfsRecursive(start);
        long dfsRecursiveTime = System.nanoTime() - startTime;
        
        // DFS迭代
        startTime = System.nanoTime();
        List<Integer> dfsIterative = traversal.dfsIterative(start);
        long dfsIterativeTime = System.nanoTime() - startTime;
        
        // BFS
        startTime = System.nanoTime();
        List<Integer> bfs = traversal.bfs(start);
        long bfsTime = System.nanoTime() - startTime;
        
        System.out.println("DFS递归: " + dfsRecursive + " (时间: " + dfsRecursiveTime + " ns)");
        System.out.println("DFS迭代: " + dfsIterative + " (时间: " + dfsIterativeTime + " ns)");
        System.out.println("BFS: " + bfs + " (时间: " + bfsTime + " ns)");
        
        System.out.println();
    }
    
    /**
     * 分析图的连通性
     */
    public static void analyzeConnectivity(GraphTraversal traversal) {
        System.out.println("=== 图连通性分析 ===");
        
        List<List<Integer>> components = traversal.getConnectedComponents();
        System.out.println("连通分量数量: " + components.size());
        
        for (int i = 0; i < components.size(); i++) {
            System.out.println("连通分量 " + (i + 1) + ": " + components.get(i));
        }
        
        boolean hasCycle = traversal.hasCycle();
        System.out.println("是否存在环: " + hasCycle);
        
        System.out.println();
    }
    
    /**
     * 测试路径查找
     */
    public static void testPathFinding(GraphTraversal traversal, int start, int end) {
        System.out.println("=== 路径查找测试 ===");
        System.out.println("从 " + start + " 到 " + end);
        
        // DFS路径
        List<Integer> dfsPath = traversal.getPath(start, end);
        System.out.println("DFS路径: " + dfsPath);
        
        // BFS最短路径
        List<Integer> bfsPath = traversal.getShortestPath(start, end);
        System.out.println("BFS最短路径: " + bfsPath);
        
        System.out.println();
    }
    
    /**
     * 生成随机图用于测试
     */
    public static List<List<Integer>> generateRandomGraph(int vertexCount, int edgeCount, boolean isDirected) {
        List<List<Integer>> adjList = new ArrayList<>();
        for (int i = 0; i < vertexCount; i++) {
            adjList.add(new ArrayList<>());
        }
        
        Random random = new Random();
        for (int i = 0; i < edgeCount; i++) {
            int from = random.nextInt(vertexCount);
            int to = random.nextInt(vertexCount);
            
            if (from != to && !adjList.get(from).contains(to)) {
                adjList.get(from).add(to);
                if (!isDirected && !adjList.get(to).contains(from)) {
                    adjList.get(to).add(from);
                }
            }
        }
        
        return adjList;
    }
    
    /**
     * 生成完全图
     */
    public static List<List<Integer>> generateCompleteGraph(int vertexCount) {
        List<List<Integer>> adjList = new ArrayList<>();
        for (int i = 0; i < vertexCount; i++) {
            adjList.add(new ArrayList<>());
        }
        
        for (int i = 0; i < vertexCount; i++) {
            for (int j = 0; j < vertexCount; j++) {
                if (i != j) {
                    adjList.get(i).add(j);
                }
            }
        }
        
        return adjList;
    }
    
    /**
     * 生成链式图
     */
    public static List<List<Integer>> generateChainGraph(int vertexCount) {
        List<List<Integer>> adjList = new ArrayList<>();
        for (int i = 0; i < vertexCount; i++) {
            adjList.add(new ArrayList<>());
        }
        
        for (int i = 0; i < vertexCount - 1; i++) {
            adjList.get(i).add(i + 1);
            adjList.get(i + 1).add(i);
        }
        
        return adjList;
    }
    
    /**
     * 生成星形图
     */
    public static List<List<Integer>> generateStarGraph(int vertexCount) {
        List<List<Integer>> adjList = new ArrayList<>();
        for (int i = 0; i < vertexCount; i++) {
            adjList.add(new ArrayList<>());
        }
        
        int center = 0;
        for (int i = 1; i < vertexCount; i++) {
            adjList.get(center).add(i);
            adjList.get(i).add(center);
        }
        
        return adjList;
    }
}
```

## 测试代码

```java
/**
 * 图遍历测试类
 */
public class GraphTraversalTest {
    public static void main(String[] args) {
        System.out.println("=== 图遍历基本功能测试 ===");
        testBasicTraversal();
        
        System.out.println("\n=== 图遍历性能测试 ===");
        testTraversalPerformance();
        
        System.out.println("\n=== 图遍历应用测试 ===");
        testTraversalApplications();
        
        System.out.println("\n=== 特殊图遍历测试 ===");
        testSpecialGraphs();
    }
    
    /**
     * 测试基本遍历功能
     */
    public static void testBasicTraversal() {
        // 创建测试图
        List<List<Integer>> adjList = new ArrayList<>();
        adjList.add(Arrays.asList(1, 2));      // 0 -> 1, 2
        adjList.add(Arrays.asList(0, 3));      // 1 -> 0, 3
        adjList.add(Arrays.asList(0, 3));      // 2 -> 0, 3
        adjList.add(Arrays.asList(1, 2));      // 3 -> 1, 2
        
        GraphTraversal traversal = new AdjacencyListGraphTraversal(adjList, false);
        
        System.out.println("测试图: " + adjList);
        
        // 测试DFS递归
        List<Integer> dfsRecursive = traversal.dfsRecursive(0);
        System.out.println("DFS递归从0开始: " + dfsRecursive);
        
        // 测试DFS迭代
        List<Integer> dfsIterative = traversal.dfsIterative(0);
        System.out.println("DFS迭代从0开始: " + dfsIterative);
        
        // 测试BFS
        List<Integer> bfs = traversal.bfs(0);
        System.out.println("BFS从0开始: " + bfs);
        
        // 测试连通分量
        List<List<Integer>> components = traversal.getConnectedComponents();
        System.out.println("连通分量: " + components);
        
        // 测试环检测
        boolean hasCycle = traversal.hasCycle();
        System.out.println("是否存在环: " + hasCycle);
    }
    
    /**
     * 测试遍历性能
     */
    public static void testTraversalPerformance() {
        int[] vertexCounts = {100, 500, 1000};
        
        for (int vertexCount : vertexCounts) {
            System.out.println("顶点数: " + vertexCount);
            
            // 生成随机图
            List<List<Integer>> adjList = GraphTraversalUtils.generateRandomGraph(
                vertexCount, vertexCount * 2, false);
            
            GraphTraversal traversal = new AdjacencyListGraphTraversal(adjList, false);
            
            // 测试DFS递归性能
            long startTime = System.nanoTime();
            traversal.dfsRecursive(0);
            long dfsRecursiveTime = System.nanoTime() - startTime;
            
            // 测试DFS迭代性能
            startTime = System.nanoTime();
            traversal.dfsIterative(0);
            long dfsIterativeTime = System.nanoTime() - startTime;
            
            // 测试BFS性能
            startTime = System.nanoTime();
            traversal.bfs(0);
            long bfsTime = System.nanoTime() - startTime;
            
            System.out.println("DFS递归时间: " + dfsRecursiveTime + " ns");
            System.out.println("DFS迭代时间: " + dfsIterativeTime + " ns");
            System.out.println("BFS时间: " + bfsTime + " ns");
            System.out.println();
        }
    }
    
    /**
     * 测试遍历应用
     */
    public static void testTraversalApplications() {
        // 创建测试图
        List<List<Integer>> adjList = new ArrayList<>();
        adjList.add(Arrays.asList(1, 2));      // 0 -> 1, 2
        adjList.add(Arrays.asList(0, 3));      // 1 -> 0, 3
        adjList.add(Arrays.asList(0, 3));      // 2 -> 0, 3
        adjList.add(Arrays.asList(1, 2));      // 3 -> 1, 2
        
        GraphTraversal traversal = new AdjacencyListGraphTraversal(adjList, false);
        
        // 测试路径查找
        GraphTraversalUtils.testPathFinding(traversal, 0, 3);
        
        // 测试连通性分析
        GraphTraversalUtils.analyzeConnectivity(traversal);
        
        // 测试二分图检测
        boolean isBipartite = ((AdjacencyListGraphTraversal) traversal).isBipartite();
        System.out.println("是否为二分图: " + isBipartite);
        
        // 测试所有路径
        List<List<Integer>> allPaths = ((AdjacencyListGraphTraversal) traversal).getAllPaths(0, 3);
        System.out.println("从0到3的所有路径: " + allPaths);
        
        System.out.println();
    }
    
    /**
     * 测试特殊图
     */
    public static void testSpecialGraphs() {
        // 测试完全图
        System.out.println("=== 完全图测试 ===");
        List<List<Integer>> completeGraph = GraphTraversalUtils.generateCompleteGraph(5);
        GraphTraversal completeTraversal = new AdjacencyListGraphTraversal(completeGraph, false);
        GraphTraversalUtils.compareTraversalMethods(completeTraversal, 0);
        
        // 测试链式图
        System.out.println("=== 链式图测试 ===");
        List<List<Integer>> chainGraph = GraphTraversalUtils.generateChainGraph(5);
        GraphTraversal chainTraversal = new AdjacencyListGraphTraversal(chainGraph, false);
        GraphTraversalUtils.compareTraversalMethods(chainTraversal, 0);
        
        // 测试星形图
        System.out.println("=== 星形图测试 ===");
        List<List<Integer>> starGraph = GraphTraversalUtils.generateStarGraph(5);
        GraphTraversal starTraversal = new AdjacencyListGraphTraversal(starGraph, false);
        GraphTraversalUtils.compareTraversalMethods(starTraversal, 0);
        
        // 测试有向图
        System.out.println("=== 有向图测试 ===");
        List<List<Integer>> directedAdjList = new ArrayList<>();
        directedAdjList.add(Arrays.asList(1));        // 0 -> 1
        directedAdjList.add(Arrays.asList(2));        // 1 -> 2
        directedAdjList.add(Arrays.asList(0));        // 2 -> 0
        directedAdjList.add(Arrays.asList(0));        // 3 -> 0
        
        GraphTraversal directedTraversal = new AdjacencyListGraphTraversal(directedAdjList, true);
        GraphTraversalUtils.compareTraversalMethods(directedTraversal, 0);
        GraphTraversalUtils.analyzeConnectivity(directedTraversal);
    }
}
```

