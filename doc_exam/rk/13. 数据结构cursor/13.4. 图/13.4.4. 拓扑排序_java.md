# 13.4.4. 拓扑排序 - Java代码示例

## 一、基于Kahn算法的拓扑排序

```java
import java.util.*;

/**
 * 基于Kahn算法的拓扑排序实现
 */
public class TopologicalSortKahn {
    
    /**
     * 图的邻接表表示
     */
    static class Graph {
        private int vertices;
        private List<List<Integer>> adjList;
        
        public Graph(int vertices) {
            this.vertices = vertices;
            this.adjList = new ArrayList<>();
            for (int i = 0; i < vertices; i++) {
                adjList.add(new ArrayList<>());
            }
        }
        
        public void addEdge(int from, int to) {
            adjList.get(from).add(to);
        }
        
        public List<Integer> getAdjacent(int vertex) {
            return adjList.get(vertex);
        }
        
        public int getVertices() {
            return vertices;
        }
    }
    
    /**
     * Kahn算法实现拓扑排序
     */
    public static List<Integer> topologicalSort(Graph graph) {
        int vertices = graph.getVertices();
        int[] inDegree = new int[vertices];
        
        // 计算所有顶点的入度
        for (int i = 0; i < vertices; i++) {
            for (int neighbor : graph.getAdjacent(i)) {
                inDegree[neighbor]++;
            }
        }
        
        // 将入度为0的顶点加入队列
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < vertices; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        
        List<Integer> result = new ArrayList<>();
        
        // 处理队列中的顶点
        while (!queue.isEmpty()) {
            int current = queue.poll();
            result.add(current);
            
            // 更新邻接顶点的入度
            for (int neighbor : graph.getAdjacent(current)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }
        
        // 检查是否存在环
        if (result.size() != vertices) {
            throw new RuntimeException("图中存在环，无法进行拓扑排序");
        }
        
        return result;
    }
    
    /**
     * 检测有向图中是否存在环
     */
    public static boolean hasCycle(Graph graph) {
        try {
            topologicalSort(graph);
            return false;
        } catch (RuntimeException e) {
            return true;
        }
    }
    
    /**
     * 字典序最小的拓扑排序
     */
    public static List<Integer> lexicographicalTopologicalSort(Graph graph) {
        int vertices = graph.getVertices();
        int[] inDegree = new int[vertices];
        
        // 计算入度
        for (int i = 0; i < vertices; i++) {
            for (int neighbor : graph.getAdjacent(i)) {
                inDegree[neighbor]++;
            }
        }
        
        // 使用优先队列确保字典序最小
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int i = 0; i < vertices; i++) {
            if (inDegree[i] == 0) {
                pq.offer(i);
            }
        }
        
        List<Integer> result = new ArrayList<>();
        
        while (!pq.isEmpty()) {
            int current = pq.poll();
            result.add(current);
            
            for (int neighbor : graph.getAdjacent(current)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    pq.offer(neighbor);
                }
            }
        }
        
        if (result.size() != vertices) {
            throw new RuntimeException("图中存在环，无法进行拓扑排序");
        }
        
        return result;
    }
}
```

## 二、基于DFS的拓扑排序

```java
/**
 * 基于DFS的拓扑排序实现
 */
public class TopologicalSortDFS {
    
    /**
     * 使用DFS进行拓扑排序
     */
    public static List<Integer> topologicalSort(TopologicalSortKahn.Graph graph) {
        int vertices = graph.getVertices();
        boolean[] visited = new boolean[vertices];
        Stack<Integer> stack = new Stack<>();
        
        // 对所有未访问的顶点进行DFS
        for (int i = 0; i < vertices; i++) {
            if (!visited[i]) {
                dfs(graph, i, visited, stack);
            }
        }
        
        // 从栈中弹出元素得到拓扑排序
        List<Integer> result = new ArrayList<>();
        while (!stack.isEmpty()) {
            result.add(stack.pop());
        }
        
        return result;
    }
    
    /**
     * DFS辅助方法
     */
    private static void dfs(TopologicalSortKahn.Graph graph, int vertex, 
                           boolean[] visited, Stack<Integer> stack) {
        visited[vertex] = true;
        
        // 递归访问所有邻接顶点
        for (int neighbor : graph.getAdjacent(vertex)) {
            if (!visited[neighbor]) {
                dfs(graph, neighbor, visited, stack);
            }
        }
        
        // 在递归返回前将顶点压入栈
        stack.push(vertex);
    }
    
    /**
     * 基于DFS的环检测
     */
    public static boolean hasCycle(TopologicalSortKahn.Graph graph) {
        int vertices = graph.getVertices();
        int[] color = new int[vertices]; // 0:白色, 1:灰色, 2:黑色
        
        for (int i = 0; i < vertices; i++) {
            if (color[i] == 0) {
                if (dfsHasCycle(graph, i, color)) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * DFS环检测辅助方法
     */
    private static boolean dfsHasCycle(TopologicalSortKahn.Graph graph, 
                                      int vertex, int[] color) {
        color[vertex] = 1; // 标记为灰色（正在访问）
        
        for (int neighbor : graph.getAdjacent(vertex)) {
            if (color[neighbor] == 1) {
                return true; // 发现后向边，存在环
            }
            if (color[neighbor] == 0 && dfsHasCycle(graph, neighbor, color)) {
                return true;
            }
        }
        
        color[vertex] = 2; // 标记为黑色（已完成）
        return false;
    }
}
```

## 三、拓扑排序的应用

```java
/**
 * 拓扑排序的实际应用示例
 */
public class TopologicalSortApplications {
    
    /**
     * 课程安排问题
     */
    public static class CourseSchedule {
        
        /**
         * 判断是否可以完成所有课程
         * @param numCourses 课程总数
         * @param prerequisites 先修课程关系
         * @return 是否可以完成所有课程
         */
        public static boolean canFinish(int numCourses, int[][] prerequisites) {
            TopologicalSortKahn.Graph graph = new TopologicalSortKahn.Graph(numCourses);
            
            // 构建图
            for (int[] prereq : prerequisites) {
                graph.addEdge(prereq[1], prereq[0]); // prereq[1] -> prereq[0]
            }
            
            // 检查是否存在环
            return !TopologicalSortKahn.hasCycle(graph);
        }
        
        /**
         * 返回完成所有课程的一种顺序
         */
        public static int[] findOrder(int numCourses, int[][] prerequisites) {
            TopologicalSortKahn.Graph graph = new TopologicalSortKahn.Graph(numCourses);
            
            // 构建图
            for (int[] prereq : prerequisites) {
                graph.addEdge(prereq[1], prereq[0]);
            }
            
            try {
                List<Integer> order = TopologicalSortKahn.topologicalSort(graph);
                return order.stream().mapToInt(Integer::intValue).toArray();
            } catch (RuntimeException e) {
                return new int[0]; // 无法完成所有课程
            }
        }
    }
    
    /**
     * 任务调度问题
     */
    public static class TaskScheduling {
        
        static class Task {
            int id;
            String name;
            List<Integer> dependencies;
            
            public Task(int id, String name) {
                this.id = id;
                this.name = name;
                this.dependencies = new ArrayList<>();
            }
            
            public void addDependency(int taskId) {
                dependencies.add(taskId);
            }
        }
        
        /**
         * 任务调度
         */
        public static List<Task> scheduleTasks(List<Task> tasks) {
            int n = tasks.size();
            TopologicalSortKahn.Graph graph = new TopologicalSortKahn.Graph(n);
            
            // 构建依赖图
            for (Task task : tasks) {
                for (int dependency : task.dependencies) {
                    graph.addEdge(dependency, task.id);
                }
            }
            
            // 获取拓扑排序
            List<Integer> order = TopologicalSortKahn.topologicalSort(graph);
            
            // 根据排序结果返回任务列表
            List<Task> scheduledTasks = new ArrayList<>();
            for (int taskId : order) {
                scheduledTasks.add(tasks.get(taskId));
            }
            
            return scheduledTasks;
        }
    }
    
    /**
     * 编译依赖分析
     */
    public static class CompilationOrder {
        
        /**
         * 确定编译顺序
         * @param files 文件列表
         * @param dependencies 依赖关系 [a, b] 表示文件a依赖文件b
         * @return 编译顺序
         */
        public static List<String> getCompilationOrder(List<String> files, 
                                                      List<int[]> dependencies) {
            int n = files.size();
            TopologicalSortKahn.Graph graph = new TopologicalSortKahn.Graph(n);
            
            // 构建依赖图
            for (int[] dep : dependencies) {
                graph.addEdge(dep[1], dep[0]); // 被依赖的文件 -> 依赖的文件
            }
            
            // 获取拓扑排序
            List<Integer> order = TopologicalSortKahn.topologicalSort(graph);
            
            // 转换为文件名列表
            List<String> compilationOrder = new ArrayList<>();
            for (int index : order) {
                compilationOrder.add(files.get(index));
            }
            
            return compilationOrder;
        }
    }
}
```

## 四、高级拓扑排序算法

```java
/**
 * 高级拓扑排序算法
 */
public class AdvancedTopologicalSort {
    
    /**
     * 获取所有可能的拓扑排序
     */
    public static List<List<Integer>> allTopologicalSorts(TopologicalSortKahn.Graph graph) {
        int vertices = graph.getVertices();
        int[] inDegree = new int[vertices];
        
        // 计算入度
        for (int i = 0; i < vertices; i++) {
            for (int neighbor : graph.getAdjacent(i)) {
                inDegree[neighbor]++;
            }
        }
        
        List<List<Integer>> results = new ArrayList<>();
        List<Integer> current = new ArrayList<>();
        boolean[] visited = new boolean[vertices];
        
        backtrack(graph, inDegree, visited, current, results);
        return results;
    }
    
    /**
     * 回溯生成所有拓扑排序
     */
    private static void backtrack(TopologicalSortKahn.Graph graph, int[] inDegree, 
                                 boolean[] visited, List<Integer> current, 
                                 List<List<Integer>> results) {
        if (current.size() == graph.getVertices()) {
            results.add(new ArrayList<>(current));
            return;
        }
        
        for (int i = 0; i < graph.getVertices(); i++) {
            if (!visited[i] && inDegree[i] == 0) {
                // 选择当前顶点
                visited[i] = true;
                current.add(i);
                
                // 更新邻接顶点的入度
                for (int neighbor : graph.getAdjacent(i)) {
                    inDegree[neighbor]--;
                }
                
                // 递归
                backtrack(graph, inDegree, visited, current, results);
                
                // 回溯
                for (int neighbor : graph.getAdjacent(i)) {
                    inDegree[neighbor]++;
                }
                current.remove(current.size() - 1);
                visited[i] = false;
            }
        }
    }
    
    /**
     * 并行拓扑排序（适用于大图）
     */
    public static List<Integer> parallelTopologicalSort(TopologicalSortKahn.Graph graph) {
        int vertices = graph.getVertices();
        int[] inDegree = new int[vertices];
        
        // 计算入度
        for (int i = 0; i < vertices; i++) {
            for (int neighbor : graph.getAdjacent(i)) {
                inDegree[neighbor]++;
            }
        }
        
        List<Integer> result = new ArrayList<>();
        Set<Integer> currentLevel = new HashSet<>();
        
        // 找到初始的入度为0的顶点
        for (int i = 0; i < vertices; i++) {
            if (inDegree[i] == 0) {
                currentLevel.add(i);
            }
        }
        
        while (!currentLevel.isEmpty()) {
            Set<Integer> nextLevel = new HashSet<>();
            
            // 并行处理当前层的所有顶点
            currentLevel.parallelStream().forEach(vertex -> {
                synchronized (result) {
                    result.add(vertex);
                }
                
                // 更新邻接顶点的入度
                for (int neighbor : graph.getAdjacent(vertex)) {
                    synchronized (inDegree) {
                        inDegree[neighbor]--;
                        if (inDegree[neighbor] == 0) {
                            synchronized (nextLevel) {
                                nextLevel.add(neighbor);
                            }
                        }
                    }
                }
            });
            
            currentLevel = nextLevel;
        }
        
        if (result.size() != vertices) {
            throw new RuntimeException("图中存在环，无法进行拓扑排序");
        }
        
        return result;
    }
}
```

## 五、综合测试类

```java
/**
 * 拓扑排序综合测试
 */
public class TopologicalSortTest {
    
    public static void main(String[] args) {
        System.out.println("拓扑排序 - Java代码演示");
        System.out.println("======================");
        
        // 基本拓扑排序测试
        testBasicTopologicalSort();
        
        // 环检测测试
        testCycleDetection();
        
        // 应用场景测试
        testApplications();
        
        // 高级算法测试
        testAdvancedAlgorithms();
    }
    
    public static void testBasicTopologicalSort() {
        System.out.println("\n1. 基本拓扑排序测试:");
        System.out.println("---------------------");
        
        // 创建测试图: 0->1, 0->2, 1->3, 2->3
        TopologicalSortKahn.Graph graph = new TopologicalSortKahn.Graph(4);
        graph.addEdge(0, 1);
        graph.addEdge(0, 2);
        graph.addEdge(1, 3);
        graph.addEdge(2, 3);
        
        // Kahn算法
        List<Integer> kahnResult = TopologicalSortKahn.topologicalSort(graph);
        System.out.println("Kahn算法结果: " + kahnResult);
        
        // DFS算法
        List<Integer> dfsResult = TopologicalSortDFS.topologicalSort(graph);
        System.out.println("DFS算法结果: " + dfsResult);
        
        // 字典序最小
        List<Integer> lexResult = TopologicalSortKahn.lexicographicalTopologicalSort(graph);
        System.out.println("字典序最小结果: " + lexResult);
    }
    
    public static void testCycleDetection() {
        System.out.println("\n2. 环检测测试:");
        System.out.println("----------------");
        
        // 无环图
        TopologicalSortKahn.Graph acyclicGraph = new TopologicalSortKahn.Graph(3);
        acyclicGraph.addEdge(0, 1);
        acyclicGraph.addEdge(1, 2);
        System.out.println("无环图检测结果: " + !TopologicalSortKahn.hasCycle(acyclicGraph));
        
        // 有环图
        TopologicalSortKahn.Graph cyclicGraph = new TopologicalSortKahn.Graph(3);
        cyclicGraph.addEdge(0, 1);
        cyclicGraph.addEdge(1, 2);
        cyclicGraph.addEdge(2, 0);
        System.out.println("有环图检测结果: " + TopologicalSortKahn.hasCycle(cyclicGraph));
    }
    
    public static void testApplications() {
        System.out.println("\n3. 应用场景测试:");
        System.out.println("------------------");
        
        // 课程安排测试
        int numCourses = 4;
        int[][] prerequisites = {{1, 0}, {2, 0}, {3, 1}, {3, 2}};
        
        boolean canFinish = TopologicalSortApplications.CourseSchedule.canFinish(numCourses, prerequisites);
        System.out.println("是否可以完成所有课程: " + canFinish);
        
        int[] order = TopologicalSortApplications.CourseSchedule.findOrder(numCourses, prerequisites);
        System.out.println("课程完成顺序: " + Arrays.toString(order));
        
        // 任务调度测试
        List<TopologicalSortApplications.TaskScheduling.Task> tasks = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            tasks.add(new TopologicalSortApplications.TaskScheduling.Task(i, "Task" + i));
        }
        tasks.get(1).addDependency(0);
        tasks.get(2).addDependency(0);
        tasks.get(3).addDependency(1);
        tasks.get(3).addDependency(2);
        
        List<TopologicalSortApplications.TaskScheduling.Task> scheduledTasks = 
            TopologicalSortApplications.TaskScheduling.scheduleTasks(tasks);
        
        System.out.print("任务调度顺序: ");
        for (TopologicalSortApplications.TaskScheduling.Task task : scheduledTasks) {
            System.out.print(task.name + " ");
        }
        System.out.println();
    }
    
    public static void testAdvancedAlgorithms() {
        System.out.println("\n4. 高级算法测试:");
        System.out.println("------------------");
        
        // 创建简单图用于测试所有拓扑排序
        TopologicalSortKahn.Graph graph = new TopologicalSortKahn.Graph(3);
        graph.addEdge(0, 1);
        graph.addEdge(0, 2);
        
        List<List<Integer>> allSorts = AdvancedTopologicalSort.allTopologicalSorts(graph);
        System.out.println("所有可能的拓扑排序:");
        for (List<Integer> sort : allSorts) {
            System.out.println(sort);
        }
    }
}
```

## 六、学习要点

1. **理解拓扑排序的概念**：有向无环图的线性排序
2. **掌握两种主要算法**：Kahn算法和DFS算法
3. **学会环检测**：理解环与拓扑排序的关系
4. **实际应用场景**：课程安排、任务调度、编译依赖
5. **算法优化**：字典序最小、并行处理、所有可能排序
6. **复杂度分析**：时间O(V+E)，空间O(V)
