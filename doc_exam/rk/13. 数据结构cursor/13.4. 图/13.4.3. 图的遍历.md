# 13.4.3. 图的遍历

## 概述
图的遍历是指从图中的某个顶点出发，按照某种规则访问图中的所有顶点，且每个顶点只访问一次的过程。图的遍历是图算法的基础，许多图算法都建立在遍历的基础上。根据访问顶点的顺序不同，图的遍历主要分为深度优先搜索（DFS）和广度优先搜索（BFS）两种方法。

## 图遍历的基本概念

### 定义
图的遍历是从图的某个顶点开始，按照某种规则访问图中的所有顶点，且每个顶点只访问一次的过程。

### 基本术语
- **访问（Visit）**：对顶点进行某种操作，如输出、标记等
- **访问标记（Visited）**：记录顶点是否已被访问
- **遍历序列**：访问顶点的顺序
- **遍历树**：遍历过程中形成的树结构

### 遍历的特点
1. **唯一性**：每个顶点只访问一次
2. **完整性**：所有可达顶点都会被访问
3. **有序性**：按照特定规则访问顶点
4. **连通性**：只能访问连通分量中的顶点

## 深度优先搜索（DFS）

### 基本思想
深度优先搜索采用递归或栈的方式，尽可能深地搜索图的分支。当搜索到某个顶点时，先访问该顶点，然后递归地访问它的所有未访问的邻接顶点。

### 算法步骤
1. 从起始顶点开始
2. 访问当前顶点并标记为已访问
3. 递归访问当前顶点的所有未访问邻接顶点
4. 重复步骤3，直到所有可达顶点都被访问

### 递归实现
```java
public void dfsRecursive(int start) {
    boolean[] visited = new boolean[vertexCount];
    dfsHelper(start, visited);
}

private void dfsHelper(int vertex, boolean[] visited) {
    visited[vertex] = true;
    System.out.print(vertex + " ");
    
    for (int neighbor : getNeighbors(vertex)) {
        if (!visited[neighbor]) {
            dfsHelper(neighbor, visited);
        }
    }
}
```

### 迭代实现
```java
public void dfsIterative(int start) {
    boolean[] visited = new boolean[vertexCount];
    Stack<Integer> stack = new Stack<>();
    
    stack.push(start);
    
    while (!stack.isEmpty()) {
        int vertex = stack.pop();
        
        if (!visited[vertex]) {
            visited[vertex] = true;
            System.out.print(vertex + " ");
            
            for (int neighbor : getNeighbors(vertex)) {
                if (!visited[neighbor]) {
                    stack.push(neighbor);
                }
            }
        }
    }
}
```

### DFS的特点
- **时间复杂度**：O(V + E)
- **空间复杂度**：O(V)（递归栈空间）
- **遍历顺序**：深度优先，尽可能深地搜索
- **应用场景**：拓扑排序、强连通分量、路径查找

## 广度优先搜索（BFS）

### 基本思想
广度优先搜索采用队列的方式，逐层访问图中的顶点。从起始顶点开始，先访问所有距离为1的顶点，再访问距离为2的顶点，以此类推。

### 算法步骤
1. 从起始顶点开始
2. 访问当前顶点并标记为已访问
3. 将当前顶点的所有未访问邻接顶点加入队列
4. 从队列中取出下一个顶点，重复步骤2-3
5. 直到队列为空

### 实现
```java
public void bfs(int start) {
    boolean[] visited = new boolean[vertexCount];
    Queue<Integer> queue = new LinkedList<>();
    
    visited[start] = true;
    queue.offer(start);
    
    while (!queue.isEmpty()) {
        int vertex = queue.poll();
        System.out.print(vertex + " ");
        
        for (int neighbor : getNeighbors(vertex)) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                queue.offer(neighbor);
            }
        }
    }
}
```

### BFS的特点
- **时间复杂度**：O(V + E)
- **空间复杂度**：O(V)（队列空间）
- **遍历顺序**：广度优先，逐层访问
- **应用场景**：最短路径、最小生成树、层次遍历

## DFS与BFS的比较

### 访问顺序
- **DFS**：深度优先，尽可能深地搜索
- **BFS**：广度优先，逐层访问

### 数据结构
- **DFS**：使用栈（递归或显式栈）
- **BFS**：使用队列

### 空间复杂度
- **DFS**：O(V)（递归栈深度）
- **BFS**：O(V)（队列大小）

### 应用场景
- **DFS**：适合路径查找、拓扑排序
- **BFS**：适合最短路径、层次遍历

## 图的连通性

### 连通分量
连通分量是图中的一个极大连通子图。对于无向图，连通分量是指任意两个顶点之间都有路径的极大子图。

### DFS求连通分量
```java
public List<List<Integer>> getConnectedComponents() {
    boolean[] visited = new boolean[vertexCount];
    List<List<Integer>> components = new ArrayList<>();
    
    for (int i = 0; i < vertexCount; i++) {
        if (!visited[i]) {
            List<Integer> component = new ArrayList<>();
            dfsComponent(i, visited, component);
            components.add(component);
        }
    }
    
    return components;
}

private void dfsComponent(int vertex, boolean[] visited, List<Integer> component) {
    visited[vertex] = true;
    component.add(vertex);
    
    for (int neighbor : getNeighbors(vertex)) {
        if (!visited[neighbor]) {
            dfsComponent(neighbor, visited, component);
        }
    }
}
```

### 强连通分量
对于有向图，强连通分量是指任意两个顶点都相互可达的极大子图。

## 图的遍历应用

### 1. 路径查找
- **DFS**：查找从起点到终点的路径
- **BFS**：查找最短路径（无权图）

### 2. 连通性检测
- **DFS**：检测图的连通性
- **BFS**：检测图的连通性

### 3. 环检测
- **DFS**：检测图中是否存在环
- **BFS**：检测图中是否存在环

### 4. 拓扑排序
- **DFS**：对有向无环图进行拓扑排序
- **BFS**：对有向无环图进行拓扑排序

### 5. 最小生成树
- **DFS**：生成深度优先搜索树
- **BFS**：生成广度优先搜索树

## 特殊图的遍历

### 1. 二分图遍历
- **DFS**：检测二分图
- **BFS**：检测二分图

### 2. 树遍历
- **DFS**：前序、中序、后序遍历
- **BFS**：层序遍历

### 3. 有向无环图遍历
- **DFS**：拓扑排序
- **BFS**：拓扑排序

### 4. 加权图遍历
- **DFS**：路径查找
- **BFS**：最短路径（权重相等）

## 遍历的优化

### 1. 剪枝优化
- **DFS**：提前终止搜索
- **BFS**：跳过已访问顶点

### 2. 记忆化搜索
- **DFS**：避免重复计算
- **BFS**：记录访问状态

### 3. 并行搜索
- **DFS**：并行搜索不同分支
- **BFS**：并行搜索不同层

### 4. 启发式搜索
- **DFS**：A*算法
- **BFS**：Dijkstra算法

## 遍历的复杂度分析

### 时间复杂度
- **邻接矩阵**：O(V²)
- **邻接表**：O(V + E)
- **边集**：O(V × E)

### 空间复杂度
- **DFS**：O(V)（递归栈）
- **BFS**：O(V)（队列）
- **访问标记**：O(V)

### 实际性能
- **稠密图**：邻接矩阵效率高
- **稀疏图**：邻接表效率高
- **大规模图**：需要考虑内存限制

## 遍历的实现技巧

### 1. 访问标记
- 使用布尔数组记录访问状态
- 使用位运算优化空间
- 使用哈希表记录访问状态

### 2. 数据结构选择
- **DFS**：栈或递归
- **BFS**：队列
- **优先级队列**：带权图

### 3. 边界处理
- 检查顶点范围
- 处理空图
- 处理单顶点图

### 4. 错误处理
- 处理无效输入
- 处理内存不足
- 处理栈溢出

## 学习重点

### 1. 理论基础
- 理解DFS和BFS的基本思想
- 掌握遍历算法的实现
- 了解遍历的应用场景

### 2. 实现技能
- 能够实现DFS和BFS算法
- 掌握遍历的优化技巧
- 理解遍历的复杂度分析

### 3. 应用能力
- 能够根据问题选择合适的遍历方法
- 掌握遍历在实际中的应用
- 理解遍历与其他算法的关系

## 总结
图的遍历是图算法的基础，DFS和BFS是两种最重要的遍历方法。DFS适合深度搜索和路径查找，BFS适合广度搜索和最短路径。在实际应用中，需要根据问题的特点选择合适的遍历方法，并考虑时间复杂度和空间复杂度的平衡。掌握图的遍历对于学习更复杂的图算法具有重要意义。

