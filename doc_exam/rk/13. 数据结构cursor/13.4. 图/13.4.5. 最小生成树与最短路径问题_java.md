# 13.4.5. 最小生成树与最短路径问题 - Java代码示例

## 一、Kruskal算法实现

```java
import java.util.*;

/**
 * Kruskal算法实现最小生成树
 */
public class KruskalMST {
    
    static class Edge implements Comparable<Edge> {
        int src, dest, weight;
        
        public Edge(int src, int dest, int weight) {
            this.src = src;
            this.dest = dest;
            this.weight = weight;
        }
        
        @Override
        public int compareTo(Edge other) {
            return Integer.compare(this.weight, other.weight);
        }
        
        @Override
        public String toString() {
            return String.format("(%d-%d: %d)", src, dest, weight);
        }
    }
    
    /**
     * 并查集实现
     */
    static class UnionFind {
        private int[] parent;
        private int[] rank;
        
        public UnionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
        }
        
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]); // 路径压缩
            }
            return parent[x];
        }
        
        public boolean union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            
            if (rootX == rootY) {
                return false; // 已经在同一个集合中
            }
            
            // 按秩合并
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
            
            return true;
        }
    }
    
    /**
     * Kruskal算法求最小生成树
     */
    public static List<Edge> kruskalMST(int vertices, List<Edge> edges) {
        // 按权重排序
        Collections.sort(edges);
        
        List<Edge> mst = new ArrayList<>();
        UnionFind uf = new UnionFind(vertices);
        
        for (Edge edge : edges) {
            if (uf.union(edge.src, edge.dest)) {
                mst.add(edge);
                if (mst.size() == vertices - 1) {
                    break; // MST完成
                }
            }
        }
        
        return mst;
    }
    
    /**
     * 计算MST的总权重
     */
    public static int getMSTWeight(List<Edge> mst) {
        return mst.stream().mapToInt(e -> e.weight).sum();
    }
}
```

## 二、Prim算法实现

```java
/**
 * Prim算法实现最小生成树
 */
public class PrimMST {
    
    static class Edge {
        int dest;
        int weight;
        
        public Edge(int dest, int weight) {
            this.dest = dest;
            this.weight = weight;
        }
    }
    
    static class Node implements Comparable<Node> {
        int vertex;
        int weight;
        
        public Node(int vertex, int weight) {
            this.vertex = vertex;
            this.weight = weight;
        }
        
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.weight, other.weight);
        }
    }
    
    /**
     * Prim算法求最小生成树
     */
    public static List<KruskalMST.Edge> primMST(List<List<Edge>> graph) {
        int vertices = graph.size();
        boolean[] inMST = new boolean[vertices];
        int[] parent = new int[vertices];
        int[] key = new int[vertices];
        
        Arrays.fill(key, Integer.MAX_VALUE);
        Arrays.fill(parent, -1);
        
        PriorityQueue<Node> pq = new PriorityQueue<>();
        
        // 从顶点0开始
        key[0] = 0;
        pq.offer(new Node(0, 0));
        
        List<KruskalMST.Edge> mst = new ArrayList<>();
        
        while (!pq.isEmpty()) {
            int u = pq.poll().vertex;
            
            if (inMST[u]) {
                continue;
            }
            
            inMST[u] = true;
            
            // 添加边到MST（除了起始顶点）
            if (parent[u] != -1) {
                mst.add(new KruskalMST.Edge(parent[u], u, key[u]));
            }
            
            // 更新邻接顶点的key值
            for (Edge edge : graph.get(u)) {
                int v = edge.dest;
                int weight = edge.weight;
                
                if (!inMST[v] && weight < key[v]) {
                    key[v] = weight;
                    parent[v] = u;
                    pq.offer(new Node(v, key[v]));
                }
            }
        }
        
        return mst;
    }
}
```

## 三、Dijkstra算法实现

```java
/**
 * Dijkstra算法实现单源最短路径
 */
public class DijkstraShortestPath {
    
    static class Edge {
        int dest;
        int weight;
        
        public Edge(int dest, int weight) {
            this.dest = dest;
            this.weight = weight;
        }
    }
    
    static class Node implements Comparable<Node> {
        int vertex;
        int distance;
        
        public Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }
        
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.distance, other.distance);
        }
    }
    
    /**
     * Dijkstra算法求单源最短路径
     */
    public static int[] dijkstra(List<List<Edge>> graph, int source) {
        int n = graph.size();
        int[] dist = new int[n];
        boolean[] visited = new boolean[n];
        
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[source] = 0;
        
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(source, 0));
        
        while (!pq.isEmpty()) {
            Node current = pq.poll();
            int u = current.vertex;
            
            if (visited[u]) {
                continue;
            }
            
            visited[u] = true;
            
            // 更新邻接顶点的距离
            for (Edge edge : graph.get(u)) {
                int v = edge.dest;
                int weight = edge.weight;
                
                if (!visited[v] && dist[u] != Integer.MAX_VALUE && 
                    dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    pq.offer(new Node(v, dist[v]));
                }
            }
        }
        
        return dist;
    }
    
    /**
     * 获取最短路径
     */
    public static List<Integer> getShortestPath(List<List<Edge>> graph, 
                                               int source, int target) {
        int n = graph.size();
        int[] dist = new int[n];
        int[] parent = new int[n];
        boolean[] visited = new boolean[n];
        
        Arrays.fill(dist, Integer.MAX_VALUE);
        Arrays.fill(parent, -1);
        dist[source] = 0;
        
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(source, 0));
        
        while (!pq.isEmpty()) {
            Node current = pq.poll();
            int u = current.vertex;
            
            if (visited[u]) {
                continue;
            }
            
            visited[u] = true;
            
            if (u == target) {
                break; // 找到目标，提前退出
            }
            
            for (Edge edge : graph.get(u)) {
                int v = edge.dest;
                int weight = edge.weight;
                
                if (!visited[v] && dist[u] != Integer.MAX_VALUE && 
                    dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    parent[v] = u;
                    pq.offer(new Node(v, dist[v]));
                }
            }
        }
        
        // 重构路径
        List<Integer> path = new ArrayList<>();
        if (dist[target] == Integer.MAX_VALUE) {
            return path; // 无法到达
        }
        
        int current = target;
        while (current != -1) {
            path.add(current);
            current = parent[current];
        }
        
        Collections.reverse(path);
        return path;
    }
}
```

## 四、Bellman-Ford算法实现

```java
/**
 * Bellman-Ford算法实现单源最短路径（支持负权边）
 */
public class BellmanFordShortestPath {
    
    static class Edge {
        int src, dest, weight;
        
        public Edge(int src, int dest, int weight) {
            this.src = src;
            this.dest = dest;
            this.weight = weight;
        }
    }
    
    static class Result {
        int[] distances;
        boolean hasNegativeCycle;
        
        public Result(int[] distances, boolean hasNegativeCycle) {
            this.distances = distances;
            this.hasNegativeCycle = hasNegativeCycle;
        }
    }
    
    /**
     * Bellman-Ford算法求单源最短路径
     */
    public static Result bellmanFord(int vertices, List<Edge> edges, int source) {
        int[] dist = new int[vertices];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[source] = 0;
        
        // 进行V-1轮松弛操作
        for (int i = 0; i < vertices - 1; i++) {
            for (Edge edge : edges) {
                if (dist[edge.src] != Integer.MAX_VALUE && 
                    dist[edge.src] + edge.weight < dist[edge.dest]) {
                    dist[edge.dest] = dist[edge.src] + edge.weight;
                }
            }
        }
        
        // 检查负权环
        boolean hasNegativeCycle = false;
        for (Edge edge : edges) {
            if (dist[edge.src] != Integer.MAX_VALUE && 
                dist[edge.src] + edge.weight < dist[edge.dest]) {
                hasNegativeCycle = true;
                break;
            }
        }
        
        return new Result(dist, hasNegativeCycle);
    }
    
    /**
     * SPFA算法（Bellman-Ford的队列优化）
     */
    public static Result spfa(List<List<DijkstraShortestPath.Edge>> graph, int source) {
        int n = graph.size();
        int[] dist = new int[n];
        boolean[] inQueue = new boolean[n];
        int[] count = new int[n]; // 记录每个顶点的松弛次数
        
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[source] = 0;
        
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(source);
        inQueue[source] = true;
        
        while (!queue.isEmpty()) {
            int u = queue.poll();
            inQueue[u] = false;
            
            for (DijkstraShortestPath.Edge edge : graph.get(u)) {
                int v = edge.dest;
                int weight = edge.weight;
                
                if (dist[u] != Integer.MAX_VALUE && 
                    dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    
                    if (!inQueue[v]) {
                        queue.offer(v);
                        inQueue[v] = true;
                        count[v]++;
                        
                        // 如果某个顶点被松弛超过V次，说明存在负权环
                        if (count[v] >= n) {
                            return new Result(dist, true);
                        }
                    }
                }
            }
        }
        
        return new Result(dist, false);
    }
}
```

## 五、Floyd-Warshall算法实现

```java
/**
 * Floyd-Warshall算法实现所有顶点对最短路径
 */
public class FloydWarshallShortestPath {
    
    /**
     * Floyd-Warshall算法
     */
    public static int[][] floydWarshall(int[][] graph) {
        int n = graph.length;
        int[][] dist = new int[n][n];
        
        // 初始化距离矩阵
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i == j) {
                    dist[i][j] = 0;
                } else if (graph[i][j] != 0) {
                    dist[i][j] = graph[i][j];
                } else {
                    dist[i][j] = Integer.MAX_VALUE;
                }
            }
        }
        
        // 动态规划求解
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] != Integer.MAX_VALUE && 
                        dist[k][j] != Integer.MAX_VALUE && 
                        dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }
        
        return dist;
    }
    
    /**
     * 获取路径重构
     */
    public static List<Integer> getPath(int[][] next, int i, int j) {
        List<Integer> path = new ArrayList<>();
        
        if (next[i][j] == -1) {
            return path; // 无路径
        }
        
        path.add(i);
        while (i != j) {
            i = next[i][j];
            path.add(i);
        }
        
        return path;
    }
    
    /**
     * 带路径重构的Floyd-Warshall算法
     */
    public static class FloydResult {
        int[][] dist;
        int[][] next;
        
        public FloydResult(int[][] dist, int[][] next) {
            this.dist = dist;
            this.next = next;
        }
    }
    
    public static FloydResult floydWarshallWithPath(int[][] graph) {
        int n = graph.length;
        int[][] dist = new int[n][n];
        int[][] next = new int[n][n];
        
        // 初始化
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i == j) {
                    dist[i][j] = 0;
                    next[i][j] = -1;
                } else if (graph[i][j] != 0) {
                    dist[i][j] = graph[i][j];
                    next[i][j] = j;
                } else {
                    dist[i][j] = Integer.MAX_VALUE;
                    next[i][j] = -1;
                }
            }
        }
        
        // 动态规划
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] != Integer.MAX_VALUE && 
                        dist[k][j] != Integer.MAX_VALUE && 
                        dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                        next[i][j] = next[i][k];
                    }
                }
            }
        }
        
        return new FloydResult(dist, next);
    }
}
```

## 六、综合测试类

```java
/**
 * 最小生成树和最短路径算法综合测试
 */
public class GraphAlgorithmTest {
    
    public static void main(String[] args) {
        System.out.println("最小生成树与最短路径算法 - Java代码演示");
        System.out.println("=========================================");
        
        // 测试最小生成树
        testMST();
        
        // 测试最短路径
        testShortestPath();
        
        // 测试负权边算法
        testNegativeWeightAlgorithms();
        
        // 测试所有对最短路径
        testAllPairsShortestPath();
    }
    
    public static void testMST() {
        System.out.println("\n1. 最小生成树测试:");
        System.out.println("-------------------");
        
        // 创建测试图
        List<KruskalMST.Edge> edges = Arrays.asList(
            new KruskalMST.Edge(0, 1, 10),
            new KruskalMST.Edge(0, 2, 6),
            new KruskalMST.Edge(0, 3, 5),
            new KruskalMST.Edge(1, 3, 15),
            new KruskalMST.Edge(2, 3, 4)
        );
        
        // Kruskal算法
        List<KruskalMST.Edge> kruskalMST = KruskalMST.kruskalMST(4, edges);
        System.out.println("Kruskal算法MST:");
        kruskalMST.forEach(System.out::println);
        System.out.println("总权重: " + KruskalMST.getMSTWeight(kruskalMST));
        
        // Prim算法
        List<List<PrimMST.Edge>> graph = createAdjacencyList(4, edges);
        List<KruskalMST.Edge> primMST = PrimMST.primMST(graph);
        System.out.println("\nPrim算法MST:");
        primMST.forEach(System.out::println);
        System.out.println("总权重: " + KruskalMST.getMSTWeight(primMST));
    }
    
    public static void testShortestPath() {
        System.out.println("\n2. 最短路径测试:");
        System.out.println("------------------");
        
        // 创建有向图
        List<List<DijkstraShortestPath.Edge>> graph = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            graph.add(new ArrayList<>());
        }
        
        graph.get(0).add(new DijkstraShortestPath.Edge(1, 10));
        graph.get(0).add(new DijkstraShortestPath.Edge(4, 5));
        graph.get(1).add(new DijkstraShortestPath.Edge(2, 1));
        graph.get(1).add(new DijkstraShortestPath.Edge(4, 2));
        graph.get(2).add(new DijkstraShortestPath.Edge(3, 4));
        graph.get(3).add(new DijkstraShortestPath.Edge(2, 6));
        graph.get(4).add(new DijkstraShortestPath.Edge(1, 3));
        graph.get(4).add(new DijkstraShortestPath.Edge(2, 9));
        graph.get(4).add(new DijkstraShortestPath.Edge(3, 2));
        
        // Dijkstra算法
        int[] distances = DijkstraShortestPath.dijkstra(graph, 0);
        System.out.println("从顶点0到各顶点的最短距离:");
        for (int i = 0; i < distances.length; i++) {
            System.out.println("到顶点" + i + ": " + 
                             (distances[i] == Integer.MAX_VALUE ? "∞" : distances[i]));
        }
        
        // 获取具体路径
        List<Integer> path = DijkstraShortestPath.getShortestPath(graph, 0, 3);
        System.out.println("从顶点0到顶点3的最短路径: " + path);
    }
    
    public static void testNegativeWeightAlgorithms() {
        System.out.println("\n3. 负权边算法测试:");
        System.out.println("--------------------");
        
        // 创建包含负权边的图
        List<BellmanFordShortestPath.Edge> edges = Arrays.asList(
            new BellmanFordShortestPath.Edge(0, 1, -1),
            new BellmanFordShortestPath.Edge(0, 2, 4),
            new BellmanFordShortestPath.Edge(1, 2, 3),
            new BellmanFordShortestPath.Edge(1, 3, 2),
            new BellmanFordShortestPath.Edge(1, 4, 2),
            new BellmanFordShortestPath.Edge(3, 2, 5),
            new BellmanFordShortestPath.Edge(3, 1, 1),
            new BellmanFordShortestPath.Edge(4, 3, -3)
        );
        
        BellmanFordShortestPath.Result result = 
            BellmanFordShortestPath.bellmanFord(5, edges, 0);
        
        System.out.println("Bellman-Ford算法结果:");
        System.out.println("是否存在负权环: " + result.hasNegativeCycle);
        
        if (!result.hasNegativeCycle) {
            System.out.println("从顶点0到各顶点的最短距离:");
            for (int i = 0; i < result.distances.length; i++) {
                System.out.println("到顶点" + i + ": " + 
                                 (result.distances[i] == Integer.MAX_VALUE ? "∞" : result.distances[i]));
            }
        }
    }
    
    public static void testAllPairsShortestPath() {
        System.out.println("\n4. 所有对最短路径测试:");
        System.out.println("------------------------");
        
        // 创建邻接矩阵
        int[][] graph = {
            {0, 5, 0, 10},
            {0, 0, 3, 0},
            {0, 0, 0, 1},
            {0, 0, 0, 0}
        };
        
        int[][] distances = FloydWarshallShortestPath.floydWarshall(graph);
        
        System.out.println("所有顶点对之间的最短距离:");
        for (int i = 0; i < distances.length; i++) {
            for (int j = 0; j < distances[i].length; j++) {
                if (distances[i][j] == Integer.MAX_VALUE) {
                    System.out.print("∞\t");
                } else {
                    System.out.print(distances[i][j] + "\t");
                }
            }
            System.out.println();
        }
    }
    
    /**
     * 将边列表转换为邻接表
     */
    private static List<List<PrimMST.Edge>> createAdjacencyList(int vertices, 
                                                               List<KruskalMST.Edge> edges) {
        List<List<PrimMST.Edge>> graph = new ArrayList<>();
        for (int i = 0; i < vertices; i++) {
            graph.add(new ArrayList<>());
        }
        
        for (KruskalMST.Edge edge : edges) {
            graph.get(edge.src).add(new PrimMST.Edge(edge.dest, edge.weight));
            graph.get(edge.dest).add(new PrimMST.Edge(edge.src, edge.weight));
        }
        
        return graph;
    }
}
```

## 七、性能比较测试

```java
/**
 * 算法性能比较测试
 */
public class AlgorithmPerformanceTest {
    
    public static void performanceTest() {
        System.out.println("\n算法性能比较测试:");
        System.out.println("==================");
        
        int[] sizes = {100, 500, 1000};
        
        for (int size : sizes) {
            System.out.println("\n图规模: " + size + " 个顶点");
            System.out.println("------------------------");
            
            // 生成随机图
            List<KruskalMST.Edge> edges = generateRandomGraph(size, size * 2);
            List<List<DijkstraShortestPath.Edge>> adjList = convertToAdjList(size, edges);
            
            // 测试MST算法
            testMSTPerformance(size, edges, adjList);
            
            // 测试最短路径算法
            testShortestPathPerformance(adjList);
        }
    }
    
    private static void testMSTPerformance(int vertices, List<KruskalMST.Edge> edges,
                                          List<List<DijkstraShortestPath.Edge>> adjList) {
        // Kruskal算法
        long startTime = System.nanoTime();
        List<KruskalMST.Edge> kruskalResult = KruskalMST.kruskalMST(vertices, edges);
        long kruskalTime = System.nanoTime() - startTime;
        
        // Prim算法
        startTime = System.nanoTime();
        List<List<PrimMST.Edge>> primGraph = convertToPrimGraph(adjList);
        List<KruskalMST.Edge> primResult = PrimMST.primMST(primGraph);
        long primTime = System.nanoTime() - startTime;
        
        System.out.printf("Kruskal算法: %d ns, MST权重: %d\n", 
                         kruskalTime, KruskalMST.getMSTWeight(kruskalResult));
        System.out.printf("Prim算法: %d ns, MST权重: %d\n", 
                         primTime, KruskalMST.getMSTWeight(primResult));
    }
    
    private static void testShortestPathPerformance(List<List<DijkstraShortestPath.Edge>> graph) {
        int source = 0;
        
        // Dijkstra算法
        long startTime = System.nanoTime();
        int[] dijkstraResult = DijkstraShortestPath.dijkstra(graph, source);
        long dijkstraTime = System.nanoTime() - startTime;
        
        System.out.printf("Dijkstra算法: %d ns\n", dijkstraTime);
    }
    
    private static List<KruskalMST.Edge> generateRandomGraph(int vertices, int edges) {
        List<KruskalMST.Edge> edgeList = new ArrayList<>();
        Random random = new Random();
        
        for (int i = 0; i < edges; i++) {
            int src = random.nextInt(vertices);
            int dest = random.nextInt(vertices);
            if (src != dest) {
                int weight = random.nextInt(100) + 1;
                edgeList.add(new KruskalMST.Edge(src, dest, weight));
            }
        }
        
        return edgeList;
    }
    
    private static List<List<DijkstraShortestPath.Edge>> convertToAdjList(int vertices, 
                                                                         List<KruskalMST.Edge> edges) {
        List<List<DijkstraShortestPath.Edge>> graph = new ArrayList<>();
        for (int i = 0; i < vertices; i++) {
            graph.add(new ArrayList<>());
        }
        
        for (KruskalMST.Edge edge : edges) {
            graph.get(edge.src).add(new DijkstraShortestPath.Edge(edge.dest, edge.weight));
        }
        
        return graph;
    }
    
    private static List<List<PrimMST.Edge>> convertToPrimGraph(List<List<DijkstraShortestPath.Edge>> graph) {
        List<List<PrimMST.Edge>> primGraph = new ArrayList<>();
        
        for (List<DijkstraShortestPath.Edge> edges : graph) {
            List<PrimMST.Edge> primEdges = new ArrayList<>();
            for (DijkstraShortestPath.Edge edge : edges) {
                primEdges.add(new PrimMST.Edge(edge.dest, edge.weight));
            }
            primGraph.add(primEdges);
        }
        
        return primGraph;
    }
}
```

## 八、学习要点

1. **理解算法原理**：掌握每种算法的基本思想和适用场景
2. **数据结构选择**：合理选择并查集、优先队列等辅助数据结构
3. **复杂度分析**：理解时间空间复杂度，选择合适的算法
4. **边界条件处理**：注意负权边、不连通图等特殊情况
5. **实际应用**：了解算法在网络路由、地图导航等领域的应用
6. **性能优化**：学会根据图的特点选择最优算法
