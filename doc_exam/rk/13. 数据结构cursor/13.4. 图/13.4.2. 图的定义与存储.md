# 13.4.2. 图的定义与存储

## 概述
图的存储是图论中的基础问题，不同的存储方式会影响图算法的效率和实现复杂度。选择合适的存储结构对于图算法的性能至关重要。本章将详细介绍图的定义、基本概念以及各种存储方式的优缺点和适用场景。

## 图的定义

### 数学定义
图G由两个集合组成：
- **顶点集合V**：G = {v1, v2, ..., vn}
- **边集合E**：G = {e1, e2, ..., em}

记作：G = (V, E)

### 基本概念
- **顶点（Vertex/Node）**：图中的基本元素，也称为节点
- **边（Edge）**：连接两个顶点的线段
- **邻接（Adjacent）**：如果两个顶点之间有边相连，则称这两个顶点邻接
- **关联（Incident）**：边与顶点之间的关系
- **度（Degree）**：与顶点相关联的边的数量

### 图的分类

#### 1. 按边的方向分类
- **无向图（Undirected Graph）**：边没有方向，可以双向通行
- **有向图（Directed Graph）**：边有方向，只能单向通行

#### 2. 按边的权重分类
- **无权图（Unweighted Graph）**：边没有权重或权重相等
- **有权图（Weighted Graph）**：边有权重，表示距离、成本等

#### 3. 按连通性分类
- **连通图（Connected Graph）**：任意两个顶点之间都有路径
- **非连通图（Disconnected Graph）**：存在不连通的顶点

#### 4. 按边的数量分类
- **稀疏图（Sparse Graph）**：边数相对较少，E << V²
- **稠密图（Dense Graph）**：边数相对较多，E ≈ V²

## 图的存储方式

### 1. 邻接矩阵（Adjacency Matrix）

#### 定义
使用二维数组A[V][V]表示图，其中A[i][j]表示顶点i和顶点j之间是否有边。

#### 实现方式
```java
// 无权图
boolean[][] adjMatrix = new boolean[V][V];

// 有权图
int[][] adjMatrix = new int[V][V];
// 或使用Integer.MAX_VALUE表示无穷大
```

#### 特点
- **空间复杂度**：O(V²)
- **查找边**：O(1)
- **添加边**：O(1)
- **删除边**：O(1)
- **遍历所有边**：O(V²)

#### 优点
1. **实现简单**：代码简洁，易于理解
2. **查找效率高**：判断两个顶点是否相邻只需O(1)时间
3. **便于计算度数**：顶点的度数可以直接计算
4. **支持动态操作**：添加和删除边操作简单

#### 缺点
1. **空间浪费**：对于稀疏图，大量空间被浪费
2. **内存限制**：对于大图，内存需求巨大
3. **不便于动态添加顶点**：需要重新分配数组

#### 适用场景
- 稠密图
- 频繁查找边的操作
- 小规模图
- 需要快速判断两顶点是否相邻

### 2. 邻接表（Adjacency List）

#### 定义
使用链表数组表示图，每个顶点对应一个链表，存储与该顶点相邻的所有顶点。

#### 实现方式
```java
// 使用ArrayList
List<List<Integer>> adjList = new ArrayList<>();

// 使用LinkedList
List<LinkedList<Integer>> adjList = new ArrayList<>();

// 使用数组和链表
class GraphNode {
    int vertex;
    List<Integer> neighbors;
}
```

#### 特点
- **空间复杂度**：O(V + E)
- **查找边**：O(degree)
- **添加边**：O(1)
- **删除边**：O(degree)
- **遍历所有边**：O(V + E)

#### 优点
1. **空间效率高**：只存储实际存在的边
2. **适合稀疏图**：空间复杂度与边数成正比
3. **便于遍历**：可以高效地遍历所有边
4. **动态性好**：易于添加和删除顶点

#### 缺点
1. **查找效率低**：判断两顶点是否相邻需要遍历链表
2. **实现复杂**：相比邻接矩阵实现更复杂
3. **缓存不友好**：链表结构不利于缓存

#### 适用场景
- 稀疏图
- 频繁遍历操作
- 大规模图
- 需要动态添加顶点的场景

### 3. 边集（Edge List）

#### 定义
直接存储所有边的集合，每条边包含两个顶点和可能的权重。

#### 实现方式
```java
// 无权边
class Edge {
    int from, to;
}

// 有权边
class WeightedEdge {
    int from, to, weight;
}

// 使用数组
int[][] edges = new int[E][2]; // 无权图
int[][] edges = new int[E][3]; // 有权图 [from, to, weight]
```

#### 特点
- **空间复杂度**：O(E)
- **查找边**：O(E)
- **添加边**：O(1)
- **删除边**：O(E)
- **遍历所有边**：O(E)

#### 优点
1. **空间最省**：只存储边的信息
2. **实现简单**：结构简单，易于理解
3. **便于处理边信息**：适合需要处理边属性的场景

#### 缺点
1. **查找效率低**：查找特定边需要遍历所有边
2. **不便于计算度数**：需要遍历所有边才能计算顶点度数
3. **不便于遍历邻接顶点**：需要遍历所有边

#### 适用场景
- 边数很少的图
- 需要频繁处理边信息的场景
- 内存极度受限的环境
- 某些特殊算法（如Kruskal算法）

### 4. 前向星（Forward Star）

#### 定义
一种特殊的邻接表实现，使用数组存储边信息，通过索引数组快速定位。

#### 实现方式
```java
class ForwardStar {
    int[] head;        // 每个顶点的第一条边
    int[] next;        // 下一条边的索引
    int[] to;          // 边的终点
    int[] weight;      // 边的权重
    int edgeCount;     // 边的数量
}
```

#### 特点
- **空间复杂度**：O(V + E)
- **查找边**：O(degree)
- **添加边**：O(1)
- **删除边**：O(degree)
- **遍历所有边**：O(V + E)

#### 优点
1. **空间效率高**：与邻接表相当
2. **缓存友好**：使用数组存储，缓存性能好
3. **实现灵活**：可以方便地添加边属性

#### 缺点
1. **实现复杂**：需要维护多个数组
2. **删除困难**：删除边操作复杂

#### 适用场景
- 需要高性能的图算法
- 频繁的边遍历操作
- 对缓存性能要求高的场景

## 存储方式的选择

### 选择原则

#### 1. 根据图的性质选择
- **稠密图**：优先选择邻接矩阵
- **稀疏图**：优先选择邻接表或边集
- **小规模图**：邻接矩阵简单高效
- **大规模图**：邻接表或前向星更合适

#### 2. 根据操作特点选择
- **频繁查找边**：邻接矩阵
- **频繁遍历**：邻接表或前向星
- **频繁添加边**：邻接表或边集
- **频繁删除边**：邻接矩阵

#### 3. 根据内存限制选择
- **内存充足**：邻接矩阵
- **内存受限**：邻接表或边集
- **内存极度受限**：边集

#### 4. 根据算法需求选择
- **最短路径算法**：邻接表或前向星
- **最小生成树算法**：边集（Kruskal）或邻接表（Prim）
- **拓扑排序**：邻接表
- **强连通分量**：邻接表

### 性能比较

| 操作 | 邻接矩阵 | 邻接表 | 边集 | 前向星 |
|------|----------|--------|------|--------|
| 空间复杂度 | O(V²) | O(V+E) | O(E) | O(V+E) |
| 查找边 | O(1) | O(degree) | O(E) | O(degree) |
| 添加边 | O(1) | O(1) | O(1) | O(1) |
| 删除边 | O(1) | O(degree) | O(E) | O(degree) |
| 遍历所有边 | O(V²) | O(V+E) | O(E) | O(V+E) |
| 计算度数 | O(V) | O(degree) | O(E) | O(degree) |

## 特殊图的存储

### 1. 二分图
- **邻接表**：最常用的存储方式
- **邻接矩阵**：适合稠密二分图
- **特殊优化**：可以针对二分图特性进行优化

### 2. 树
- **邻接表**：最自然的存储方式
- **父节点表示**：只存储父节点信息
- **左孩子右兄弟**：特殊的树存储方式

### 3. 有向无环图（DAG）
- **邻接表**：适合大多数DAG算法
- **邻接矩阵**：适合稠密DAG
- **拓扑排序**：可以优化存储结构

### 4. 平面图
- **邻接表**：保持平面性信息
- **特殊结构**：可以存储面的信息

## 图的动态操作

### 1. 添加顶点
- **邻接矩阵**：需要重新分配数组
- **邻接表**：直接添加新的链表
- **边集**：不需要特殊处理

### 2. 删除顶点
- **邻接矩阵**：需要标记或重新分配
- **邻接表**：需要删除相关链表
- **边集**：需要删除相关边

### 3. 添加边
- **邻接矩阵**：直接设置数组元素
- **邻接表**：在相应链表中添加节点
- **边集**：直接添加边记录

### 4. 删除边
- **邻接矩阵**：直接清除数组元素
- **邻接表**：在链表中查找并删除
- **边集**：遍历查找并删除

## 图的序列化

### 1. 邻接矩阵序列化
```java
// 保存为二维数组
int[][] matrix = {{0,1,0,1}, {1,0,1,0}, {0,1,0,1}, {1,0,1,0}};

// 保存为字符串
String serialized = "0,1,0,1;1,0,1,0;0,1,0,1;1,0,1,0";
```

### 2. 邻接表序列化
```java
// 保存为列表
List<List<Integer>> adjList = Arrays.asList(
    Arrays.asList(1, 3),
    Arrays.asList(0, 2),
    Arrays.asList(1, 3),
    Arrays.asList(0, 2)
);
```

### 3. 边集序列化
```java
// 保存为边列表
List<Edge> edges = Arrays.asList(
    new Edge(0, 1),
    new Edge(1, 2),
    new Edge(2, 3),
    new Edge(3, 0)
);
```

## 图的压缩存储

### 1. 稀疏矩阵压缩
- **CSR格式**：压缩稀疏行格式
- **CSC格式**：压缩稀疏列格式
- **COO格式**：坐标格式

### 2. 图压缩算法
- **图重排序**：优化顶点顺序
- **图分割**：将大图分割成小图
- **图压缩**：使用压缩算法减少存储

### 3. 分布式存储
- **图分割**：将图分割到多个节点
- **边分割**：按边分割图
- **顶点分割**：按顶点分割图

## 学习重点

### 1. 理论基础
- 理解图的基本概念和分类
- 掌握各种存储方式的特点
- 了解存储方式的选择原则

### 2. 实现技能
- 能够实现各种存储方式
- 掌握图的动态操作
- 理解存储方式的性能特点

### 3. 应用能力
- 能够根据问题选择合适的存储方式
- 掌握图在实际中的应用
- 理解存储方式对算法性能的影响

## 总结
图的存储是图算法的基础，选择合适的存储方式对于算法的性能至关重要。邻接矩阵适合稠密图和频繁查找边的场景，邻接表适合稀疏图和频繁遍历的场景，边集适合边数很少的场景。在实际应用中，需要根据图的性质、操作特点和性能要求来选择合适的存储方式。
