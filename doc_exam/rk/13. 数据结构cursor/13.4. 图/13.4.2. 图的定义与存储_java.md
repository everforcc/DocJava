# 13.4.2. 图的定义与存储 - Java代码示例

## 图的基本接口定义

```java
/**
 * 图的基本接口
 */
public interface Graph {
    /**
     * 添加顶点
     */
    void addVertex(int vertex);
    
    /**
     * 删除顶点
     */
    void removeVertex(int vertex);
    
    /**
     * 添加边
     */
    void addEdge(int from, int to);
    
    /**
     * 添加有权边
     */
    void addEdge(int from, int to, int weight);
    
    /**
     * 删除边
     */
    void removeEdge(int from, int to);
    
    /**
     * 判断是否存在边
     */
    boolean hasEdge(int from, int to);
    
    /**
     * 获取顶点的邻居
     */
    List<Integer> getNeighbors(int vertex);
    
    /**
     * 获取顶点数
     */
    int getVertexCount();
    
    /**
     * 获取边数
     */
    int getEdgeCount();
    
    /**
     * 获取所有顶点
     */
    List<Integer> getAllVertices();
    
    /**
     * 获取所有边
     */
    List<Edge> getAllEdges();
}
```

## 边类定义

```java
/**
 * 边类
 */
public class Edge {
    public int from;
    public int to;
    public int weight;
    
    public Edge(int from, int to) {
        this.from = from;
        this.to = to;
        this.weight = 1; // 默认权重为1
    }
    
    public Edge(int from, int to, int weight) {
        this.from = from;
        this.to = to;
        this.weight = weight;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Edge edge = (Edge) obj;
        return from == edge.from && to == edge.to;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(from, to);
    }
    
    @Override
    public String toString() {
        return "(" + from + " -> " + to + ", weight: " + weight + ")";
    }
}
```

## 邻接矩阵实现

```java
/**
 * 邻接矩阵实现
 */
public class AdjacencyMatrixGraph implements Graph {
    private int[][] matrix;
    private int vertexCount;
    private int edgeCount;
    private boolean isDirected;
    
    public AdjacencyMatrixGraph(int maxVertices, boolean isDirected) {
        this.matrix = new int[maxVertices][maxVertices];
        this.vertexCount = 0;
        this.edgeCount = 0;
        this.isDirected = isDirected;
        
        // 初始化矩阵
        for (int i = 0; i < maxVertices; i++) {
            for (int j = 0; j < maxVertices; j++) {
                matrix[i][j] = 0; // 0表示无边
            }
        }
    }
    
    @Override
    public void addVertex(int vertex) {
        if (vertex < 0 || vertex >= matrix.length) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        // 邻接矩阵中顶点是隐式的，不需要特殊处理
    }
    
    @Override
    public void removeVertex(int vertex) {
        if (vertex < 0 || vertex >= matrix.length) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        // 删除与该顶点相关的所有边
        for (int i = 0; i < matrix.length; i++) {
            if (matrix[vertex][i] != 0) {
                matrix[vertex][i] = 0;
                edgeCount--;
            }
            if (matrix[i][vertex] != 0) {
                matrix[i][vertex] = 0;
                if (isDirected) {
                    edgeCount--;
                }
            }
        }
    }
    
    @Override
    public void addEdge(int from, int to) {
        addEdge(from, to, 1);
    }
    
    @Override
    public void addEdge(int from, int to, int weight) {
        if (from < 0 || from >= matrix.length || to < 0 || to >= matrix.length) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        if (matrix[from][to] == 0) {
            matrix[from][to] = weight;
            edgeCount++;
        }
        
        if (!isDirected && matrix[to][from] == 0) {
            matrix[to][from] = weight;
        }
    }
    
    @Override
    public void removeEdge(int from, int to) {
        if (from < 0 || from >= matrix.length || to < 0 || to >= matrix.length) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        if (matrix[from][to] != 0) {
            matrix[from][to] = 0;
            edgeCount--;
        }
        
        if (!isDirected && matrix[to][from] != 0) {
            matrix[to][from] = 0;
        }
    }
    
    @Override
    public boolean hasEdge(int from, int to) {
        if (from < 0 || from >= matrix.length || to < 0 || to >= matrix.length) {
            return false;
        }
        return matrix[from][to] != 0;
    }
    
    @Override
    public List<Integer> getNeighbors(int vertex) {
        List<Integer> neighbors = new ArrayList<>();
        if (vertex < 0 || vertex >= matrix.length) {
            return neighbors;
        }
        
        for (int i = 0; i < matrix.length; i++) {
            if (matrix[vertex][i] != 0) {
                neighbors.add(i);
            }
        }
        return neighbors;
    }
    
    @Override
    public int getVertexCount() {
        return matrix.length;
    }
    
    @Override
    public int getEdgeCount() {
        return edgeCount;
    }
    
    @Override
    public List<Integer> getAllVertices() {
        List<Integer> vertices = new ArrayList<>();
        for (int i = 0; i < matrix.length; i++) {
            vertices.add(i);
        }
        return vertices;
    }
    
    @Override
    public List<Edge> getAllEdges() {
        List<Edge> edges = new ArrayList<>();
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix.length; j++) {
                if (matrix[i][j] != 0) {
                    edges.add(new Edge(i, j, matrix[i][j]));
                }
            }
        }
        return edges;
    }
    
    /**
     * 获取边的权重
     */
    public int getEdgeWeight(int from, int to) {
        if (from < 0 || from >= matrix.length || to < 0 || to >= matrix.length) {
            return 0;
        }
        return matrix[from][to];
    }
    
    /**
     * 打印邻接矩阵
     */
    public void printMatrix() {
        System.out.println("邻接矩阵:");
        System.out.print("  ");
        for (int i = 0; i < matrix.length; i++) {
            System.out.print(i + " ");
        }
        System.out.println();
        
        for (int i = 0; i < matrix.length; i++) {
            System.out.print(i + " ");
            for (int j = 0; j < matrix.length; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
    }
    
    /**
     * 计算顶点的度数
     */
    public int getDegree(int vertex) {
        if (vertex < 0 || vertex >= matrix.length) {
            return 0;
        }
        
        int degree = 0;
        for (int i = 0; i < matrix.length; i++) {
            if (matrix[vertex][i] != 0) {
                degree++;
            }
        }
        return degree;
    }
}
```

## 邻接表实现

```java
/**
 * 邻接表实现
 */
public class AdjacencyListGraph implements Graph {
    private List<List<Integer>> adjList;
    private List<List<Integer>> weights;
    private int vertexCount;
    private int edgeCount;
    private boolean isDirected;
    
    public AdjacencyListGraph(int maxVertices, boolean isDirected) {
        this.adjList = new ArrayList<>();
        this.weights = new ArrayList<>();
        this.vertexCount = maxVertices;
        this.edgeCount = 0;
        this.isDirected = isDirected;
        
        // 初始化邻接表
        for (int i = 0; i < maxVertices; i++) {
            adjList.add(new ArrayList<>());
            weights.add(new ArrayList<>());
        }
    }
    
    @Override
    public void addVertex(int vertex) {
        if (vertex < 0 || vertex >= adjList.size()) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        // 邻接表中顶点是隐式的，不需要特殊处理
    }
    
    @Override
    public void removeVertex(int vertex) {
        if (vertex < 0 || vertex >= adjList.size()) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        // 删除该顶点的所有出边
        int outEdges = adjList.get(vertex).size();
        adjList.get(vertex).clear();
        weights.get(vertex).clear();
        edgeCount -= outEdges;
        
        // 删除指向该顶点的所有入边
        for (int i = 0; i < adjList.size(); i++) {
            List<Integer> neighbors = adjList.get(i);
            List<Integer> weightsList = weights.get(i);
            
            for (int j = neighbors.size() - 1; j >= 0; j--) {
                if (neighbors.get(j) == vertex) {
                    neighbors.remove(j);
                    weightsList.remove(j);
                    edgeCount--;
                }
            }
        }
    }
    
    @Override
    public void addEdge(int from, int to) {
        addEdge(from, to, 1);
    }
    
    @Override
    public void addEdge(int from, int to, int weight) {
        if (from < 0 || from >= adjList.size() || to < 0 || to >= adjList.size()) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        // 检查边是否已存在
        if (!adjList.get(from).contains(to)) {
            adjList.get(from).add(to);
            weights.get(from).add(weight);
            edgeCount++;
        }
        
        // 如果是无向图，添加反向边
        if (!isDirected && !adjList.get(to).contains(from)) {
            adjList.get(to).add(from);
            weights.get(to).add(weight);
        }
    }
    
    @Override
    public void removeEdge(int from, int to) {
        if (from < 0 || from >= adjList.size() || to < 0 || to >= adjList.size()) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        List<Integer> neighbors = adjList.get(from);
        List<Integer> weightsList = weights.get(from);
        
        for (int i = 0; i < neighbors.size(); i++) {
            if (neighbors.get(i) == to) {
                neighbors.remove(i);
                weightsList.remove(i);
                edgeCount--;
                break;
            }
        }
        
        // 如果是无向图，删除反向边
        if (!isDirected) {
            neighbors = adjList.get(to);
            weightsList = weights.get(to);
            
            for (int i = 0; i < neighbors.size(); i++) {
                if (neighbors.get(i) == from) {
                    neighbors.remove(i);
                    weightsList.remove(i);
                    break;
                }
            }
        }
    }
    
    @Override
    public boolean hasEdge(int from, int to) {
        if (from < 0 || from >= adjList.size() || to < 0 || to >= adjList.size()) {
            return false;
        }
        return adjList.get(from).contains(to);
    }
    
    @Override
    public List<Integer> getNeighbors(int vertex) {
        if (vertex < 0 || vertex >= adjList.size()) {
            return new ArrayList<>();
        }
        return new ArrayList<>(adjList.get(vertex));
    }
    
    @Override
    public int getVertexCount() {
        return vertexCount;
    }
    
    @Override
    public int getEdgeCount() {
        return edgeCount;
    }
    
    @Override
    public List<Integer> getAllVertices() {
        List<Integer> vertices = new ArrayList<>();
        for (int i = 0; i < vertexCount; i++) {
            vertices.add(i);
        }
        return vertices;
    }
    
    @Override
    public List<Edge> getAllEdges() {
        List<Edge> edges = new ArrayList<>();
        for (int i = 0; i < adjList.size(); i++) {
            List<Integer> neighbors = adjList.get(i);
            List<Integer> weightsList = weights.get(i);
            
            for (int j = 0; j < neighbors.size(); j++) {
                edges.add(new Edge(i, neighbors.get(j), weightsList.get(j)));
            }
        }
        return edges;
    }
    
    /**
     * 获取边的权重
     */
    public int getEdgeWeight(int from, int to) {
        if (from < 0 || from >= adjList.size() || to < 0 || to >= adjList.size()) {
            return 0;
        }
        
        List<Integer> neighbors = adjList.get(from);
        List<Integer> weightsList = weights.get(from);
        
        for (int i = 0; i < neighbors.size(); i++) {
            if (neighbors.get(i) == to) {
                return weightsList.get(i);
            }
        }
        return 0;
    }
    
    /**
     * 打印邻接表
     */
    public void printAdjacencyList() {
        System.out.println("邻接表:");
        for (int i = 0; i < adjList.size(); i++) {
            System.out.print(i + ": ");
            List<Integer> neighbors = adjList.get(i);
            List<Integer> weightsList = weights.get(i);
            
            for (int j = 0; j < neighbors.size(); j++) {
                System.out.print("(" + neighbors.get(j) + ", " + weightsList.get(j) + ") ");
            }
            System.out.println();
        }
    }
    
    /**
     * 计算顶点的度数
     */
    public int getDegree(int vertex) {
        if (vertex < 0 || vertex >= adjList.size()) {
            return 0;
        }
        return adjList.get(vertex).size();
    }
}
```

## 边集实现

```java
/**
 * 边集实现
 */
public class EdgeListGraph implements Graph {
    private List<Edge> edges;
    private Set<Integer> vertices;
    private boolean isDirected;
    
    public EdgeListGraph(boolean isDirected) {
        this.edges = new ArrayList<>();
        this.vertices = new HashSet<>();
        this.isDirected = isDirected;
    }
    
    @Override
    public void addVertex(int vertex) {
        vertices.add(vertex);
    }
    
    @Override
    public void removeVertex(int vertex) {
        vertices.remove(vertex);
        
        // 删除与该顶点相关的所有边
        edges.removeIf(edge -> edge.from == vertex || edge.to == vertex);
    }
    
    @Override
    public void addEdge(int from, int to) {
        addEdge(from, to, 1);
    }
    
    @Override
    public void addEdge(int from, int to, int weight) {
        // 添加顶点
        vertices.add(from);
        vertices.add(to);
        
        // 检查边是否已存在
        Edge newEdge = new Edge(from, to, weight);
        if (!edges.contains(newEdge)) {
            edges.add(newEdge);
        }
        
        // 如果是无向图，添加反向边
        if (!isDirected) {
            Edge reverseEdge = new Edge(to, from, weight);
            if (!edges.contains(reverseEdge)) {
                edges.add(reverseEdge);
            }
        }
    }
    
    @Override
    public void removeEdge(int from, int to) {
        edges.removeIf(edge -> edge.from == from && edge.to == to);
        
        if (!isDirected) {
            edges.removeIf(edge -> edge.from == to && edge.to == from);
        }
    }
    
    @Override
    public boolean hasEdge(int from, int to) {
        return edges.stream().anyMatch(edge -> edge.from == from && edge.to == to);
    }
    
    @Override
    public List<Integer> getNeighbors(int vertex) {
        List<Integer> neighbors = new ArrayList<>();
        for (Edge edge : edges) {
            if (edge.from == vertex) {
                neighbors.add(edge.to);
            }
        }
        return neighbors;
    }
    
    @Override
    public int getVertexCount() {
        return vertices.size();
    }
    
    @Override
    public int getEdgeCount() {
        return edges.size();
    }
    
    @Override
    public List<Integer> getAllVertices() {
        return new ArrayList<>(vertices);
    }
    
    @Override
    public List<Edge> getAllEdges() {
        return new ArrayList<>(edges);
    }
    
    /**
     * 获取边的权重
     */
    public int getEdgeWeight(int from, int to) {
        for (Edge edge : edges) {
            if (edge.from == from && edge.to == to) {
                return edge.weight;
            }
        }
        return 0;
    }
    
    /**
     * 打印边集
     */
    public void printEdgeList() {
        System.out.println("边集:");
        for (Edge edge : edges) {
            System.out.println(edge);
        }
    }
    
    /**
     * 计算顶点的度数
     */
    public int getDegree(int vertex) {
        int degree = 0;
        for (Edge edge : edges) {
            if (edge.from == vertex) {
                degree++;
            }
        }
        return degree;
    }
}
```

## 前向星实现

```java
/**
 * 前向星实现
 */
public class ForwardStarGraph implements Graph {
    private int[] head;        // 每个顶点的第一条边
    private int[] next;        // 下一条边的索引
    private int[] to;          // 边的终点
    private int[] weight;      // 边的权重
    private int edgeCount;     // 边的数量
    private int vertexCount;    // 顶点数量
    private boolean isDirected;
    
    public ForwardStarGraph(int maxVertices, int maxEdges, boolean isDirected) {
        this.head = new int[maxVertices];
        this.next = new int[maxEdges];
        this.to = new int[maxEdges];
        this.weight = new int[maxEdges];
        this.edgeCount = 0;
        this.vertexCount = maxVertices;
        this.isDirected = isDirected;
        
        // 初始化head数组
        Arrays.fill(head, -1);
    }
    
    @Override
    public void addVertex(int vertex) {
        if (vertex < 0 || vertex >= vertexCount) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        // 前向星中顶点是隐式的，不需要特殊处理
    }
    
    @Override
    public void removeVertex(int vertex) {
        if (vertex < 0 || vertex >= vertexCount) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        // 删除该顶点的所有出边
        int current = head[vertex];
        while (current != -1) {
            int nextEdge = next[current];
            // 标记边为删除状态（这里简化处理）
            current = nextEdge;
        }
        head[vertex] = -1;
        
        // 删除指向该顶点的所有入边
        for (int i = 0; i < vertexCount; i++) {
            if (i == vertex) continue;
            
            int current = head[i];
            int prev = -1;
            
            while (current != -1) {
                if (to[current] == vertex) {
                    if (prev == -1) {
                        head[i] = next[current];
                    } else {
                        next[prev] = next[current];
                    }
                } else {
                    prev = current;
                }
                current = next[current];
            }
        }
    }
    
    @Override
    public void addEdge(int from, int to) {
        addEdge(from, to, 1);
    }
    
    @Override
    public void addEdge(int from, int to, int weight) {
        if (from < 0 || from >= vertexCount || to < 0 || to >= vertexCount) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        if (edgeCount >= this.to.length) {
            throw new IllegalStateException("边数超出限制");
        }
        
        // 添加边
        this.to[edgeCount] = to;
        this.weight[edgeCount] = weight;
        this.next[edgeCount] = head[from];
        head[from] = edgeCount;
        edgeCount++;
        
        // 如果是无向图，添加反向边
        if (!isDirected) {
            this.to[edgeCount] = from;
            this.weight[edgeCount] = weight;
            this.next[edgeCount] = head[to];
            head[to] = edgeCount;
            edgeCount++;
        }
    }
    
    @Override
    public void removeEdge(int from, int to) {
        if (from < 0 || from >= vertexCount || to < 0 || to >= vertexCount) {
            throw new IllegalArgumentException("顶点编号超出范围");
        }
        
        int current = head[from];
        int prev = -1;
        
        while (current != -1) {
            if (this.to[current] == to) {
                if (prev == -1) {
                    head[from] = next[current];
                } else {
                    next[prev] = next[current];
                }
                break;
            }
            prev = current;
            current = next[current];
        }
        
        // 如果是无向图，删除反向边
        if (!isDirected) {
            current = head[to];
            prev = -1;
            
            while (current != -1) {
                if (this.to[current] == from) {
                    if (prev == -1) {
                        head[to] = next[current];
                    } else {
                        next[prev] = next[current];
                    }
                    break;
                }
                prev = current;
                current = next[current];
            }
        }
    }
    
    @Override
    public boolean hasEdge(int from, int to) {
        if (from < 0 || from >= vertexCount || to < 0 || to >= vertexCount) {
            return false;
        }
        
        int current = head[from];
        while (current != -1) {
            if (this.to[current] == to) {
                return true;
            }
            current = next[current];
        }
        return false;
    }
    
    @Override
    public List<Integer> getNeighbors(int vertex) {
        List<Integer> neighbors = new ArrayList<>();
        if (vertex < 0 || vertex >= vertexCount) {
            return neighbors;
        }
        
        int current = head[vertex];
        while (current != -1) {
            neighbors.add(to[current]);
            current = next[current];
        }
        return neighbors;
    }
    
    @Override
    public int getVertexCount() {
        return vertexCount;
    }
    
    @Override
    public int getEdgeCount() {
        return edgeCount;
    }
    
    @Override
    public List<Integer> getAllVertices() {
        List<Integer> vertices = new ArrayList<>();
        for (int i = 0; i < vertexCount; i++) {
            vertices.add(i);
        }
        return vertices;
    }
    
    @Override
    public List<Edge> getAllEdges() {
        List<Edge> edges = new ArrayList<>();
        for (int i = 0; i < vertexCount; i++) {
            int current = head[i];
            while (current != -1) {
                edges.add(new Edge(i, to[current], weight[current]));
                current = next[current];
            }
        }
        return edges;
    }
    
    /**
     * 获取边的权重
     */
    public int getEdgeWeight(int from, int to) {
        if (from < 0 || from >= vertexCount || to < 0 || to >= vertexCount) {
            return 0;
        }
        
        int current = head[from];
        while (current != -1) {
            if (this.to[current] == to) {
                return weight[current];
            }
            current = next[current];
        }
        return 0;
    }
    
    /**
     * 打印前向星结构
     */
    public void printForwardStar() {
        System.out.println("前向星结构:");
        for (int i = 0; i < vertexCount; i++) {
            System.out.print("顶点 " + i + ": ");
            int current = head[i];
            while (current != -1) {
                System.out.print("(" + to[current] + ", " + weight[current] + ") ");
                current = next[current];
            }
            System.out.println();
        }
    }
    
    /**
     * 计算顶点的度数
     */
    public int getDegree(int vertex) {
        if (vertex < 0 || vertex >= vertexCount) {
            return 0;
        }
        
        int degree = 0;
        int current = head[vertex];
        while (current != -1) {
            degree++;
            current = next[current];
        }
        return degree;
    }
}
```

## 图存储比较工具

```java
/**
 * 图存储比较工具
 */
public class GraphStorageComparison {
    
    /**
     * 比较不同存储方式的性能
     */
    public static void comparePerformance(int vertexCount, int edgeCount, boolean isDirected) {
        System.out.println("=== 图存储性能比较 ===");
        System.out.println("顶点数: " + vertexCount + ", 边数: " + edgeCount + ", 有向图: " + isDirected);
        
        // 创建测试图
        List<Edge> testEdges = generateRandomEdges(vertexCount, edgeCount, isDirected);
        
        // 测试邻接矩阵
        long startTime = System.nanoTime();
        AdjacencyMatrixGraph matrixGraph = new AdjacencyMatrixGraph(vertexCount, isDirected);
        for (Edge edge : testEdges) {
            matrixGraph.addEdge(edge.from, edge.to, edge.weight);
        }
        long matrixBuildTime = System.nanoTime() - startTime;
        
        // 测试邻接表
        startTime = System.nanoTime();
        AdjacencyListGraph listGraph = new AdjacencyListGraph(vertexCount, isDirected);
        for (Edge edge : testEdges) {
            listGraph.addEdge(edge.from, edge.to, edge.weight);
        }
        long listBuildTime = System.nanoTime() - startTime;
        
        // 测试边集
        startTime = System.nanoTime();
        EdgeListGraph edgeGraph = new EdgeListGraph(isDirected);
        for (Edge edge : testEdges) {
            edgeGraph.addEdge(edge.from, edge.to, edge.weight);
        }
        long edgeBuildTime = System.nanoTime() - startTime;
        
        // 测试前向星
        startTime = System.nanoTime();
        ForwardStarGraph forwardStarGraph = new ForwardStarGraph(vertexCount, edgeCount * 2, isDirected);
        for (Edge edge : testEdges) {
            forwardStarGraph.addEdge(edge.from, edge.to, edge.weight);
        }
        long forwardStarBuildTime = System.nanoTime() - startTime;
        
        // 输出结果
        System.out.println("构建时间:");
        System.out.println("邻接矩阵: " + matrixBuildTime + " ns");
        System.out.println("邻接表: " + listBuildTime + " ns");
        System.out.println("边集: " + edgeBuildTime + " ns");
        System.out.println("前向星: " + forwardStarBuildTime + " ns");
        
        // 测试查找性能
        testSearchPerformance(matrixGraph, listGraph, edgeGraph, forwardStarGraph, testEdges);
        
        // 测试遍历性能
        testTraversalPerformance(matrixGraph, listGraph, edgeGraph, forwardStarGraph);
        
        System.out.println();
    }
    
    /**
     * 生成随机边
     */
    private static List<Edge> generateRandomEdges(int vertexCount, int edgeCount, boolean isDirected) {
        List<Edge> edges = new ArrayList<>();
        Random random = new Random();
        
        for (int i = 0; i < edgeCount; i++) {
            int from = random.nextInt(vertexCount);
            int to = random.nextInt(vertexCount);
            int weight = random.nextInt(10) + 1;
            
            edges.add(new Edge(from, to, weight));
        }
        
        return edges;
    }
    
    /**
     * 测试查找性能
     */
    private static void testSearchPerformance(AdjacencyMatrixGraph matrixGraph, 
                                            AdjacencyListGraph listGraph,
                                            EdgeListGraph edgeGraph,
                                            ForwardStarGraph forwardStarGraph,
                                            List<Edge> testEdges) {
        System.out.println("查找性能测试:");
        
        // 测试邻接矩阵查找
        long startTime = System.nanoTime();
        for (Edge edge : testEdges) {
            matrixGraph.hasEdge(edge.from, edge.to);
        }
        long matrixSearchTime = System.nanoTime() - startTime;
        
        // 测试邻接表查找
        startTime = System.nanoTime();
        for (Edge edge : testEdges) {
            listGraph.hasEdge(edge.from, edge.to);
        }
        long listSearchTime = System.nanoTime() - startTime;
        
        // 测试边集查找
        startTime = System.nanoTime();
        for (Edge edge : testEdges) {
            edgeGraph.hasEdge(edge.from, edge.to);
        }
        long edgeSearchTime = System.nanoTime() - startTime;
        
        // 测试前向星查找
        startTime = System.nanoTime();
        for (Edge edge : testEdges) {
            forwardStarGraph.hasEdge(edge.from, edge.to);
        }
        long forwardStarSearchTime = System.nanoTime() - startTime;
        
        System.out.println("邻接矩阵: " + matrixSearchTime + " ns");
        System.out.println("邻接表: " + listSearchTime + " ns");
        System.out.println("边集: " + edgeSearchTime + " ns");
        System.out.println("前向星: " + forwardStarSearchTime + " ns");
    }
    
    /**
     * 测试遍历性能
     */
    private static void testTraversalPerformance(AdjacencyMatrixGraph matrixGraph,
                                               AdjacencyListGraph listGraph,
                                               EdgeListGraph edgeGraph,
                                               ForwardStarGraph forwardStarGraph) {
        System.out.println("遍历性能测试:");
        
        // 测试邻接矩阵遍历
        long startTime = System.nanoTime();
        for (int i = 0; i < matrixGraph.getVertexCount(); i++) {
            matrixGraph.getNeighbors(i);
        }
        long matrixTraversalTime = System.nanoTime() - startTime;
        
        // 测试邻接表遍历
        startTime = System.nanoTime();
        for (int i = 0; i < listGraph.getVertexCount(); i++) {
            listGraph.getNeighbors(i);
        }
        long listTraversalTime = System.nanoTime() - startTime;
        
        // 测试边集遍历
        startTime = System.nanoTime();
        for (int i = 0; i < edgeGraph.getVertexCount(); i++) {
            edgeGraph.getNeighbors(i);
        }
        long edgeTraversalTime = System.nanoTime() - startTime;
        
        // 测试前向星遍历
        startTime = System.nanoTime();
        for (int i = 0; i < forwardStarGraph.getVertexCount(); i++) {
            forwardStarGraph.getNeighbors(i);
        }
        long forwardStarTraversalTime = System.nanoTime() - startTime;
        
        System.out.println("邻接矩阵: " + matrixTraversalTime + " ns");
        System.out.println("邻接表: " + listTraversalTime + " ns");
        System.out.println("边集: " + edgeTraversalTime + " ns");
        System.out.println("前向星: " + forwardStarTraversalTime + " ns");
    }
}
```

## 测试代码

```java
/**
 * 图存储测试类
 */
public class GraphStorageTest {
    public static void main(String[] args) {
        System.out.println("=== 图存储实现测试 ===");
        testBasicOperations();
        
        System.out.println("\n=== 图存储性能比较 ===");
        testPerformanceComparison();
        
        System.out.println("\n=== 图存储功能测试 ===");
        testGraphFunctions();
    }
    
    /**
     * 测试基本操作
     */
    public static void testBasicOperations() {
        System.out.println("测试邻接矩阵:");
        testAdjacencyMatrix();
        
        System.out.println("\n测试邻接表:");
        testAdjacencyList();
        
        System.out.println("\n测试边集:");
        testEdgeList();
        
        System.out.println("\n测试前向星:");
        testForwardStar();
    }
    
    /**
     * 测试邻接矩阵
     */
    public static void testAdjacencyMatrix() {
        AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(5, false);
        
        // 添加边
        graph.addEdge(0, 1, 2);
        graph.addEdge(1, 2, 3);
        graph.addEdge(2, 3, 4);
        graph.addEdge(3, 4, 5);
        graph.addEdge(4, 0, 1);
        
        graph.printMatrix();
        
        System.out.println("顶点0的邻居: " + graph.getNeighbors(0));
        System.out.println("顶点0的度数: " + graph.getDegree(0));
        System.out.println("边(0,1)的权重: " + graph.getEdgeWeight(0, 1));
        System.out.println("是否存在边(0,2): " + graph.hasEdge(0, 2));
    }
    
    /**
     * 测试邻接表
     */
    public static void testAdjacencyList() {
        AdjacencyListGraph graph = new AdjacencyListGraph(5, false);
        
        // 添加边
        graph.addEdge(0, 1, 2);
        graph.addEdge(1, 2, 3);
        graph.addEdge(2, 3, 4);
        graph.addEdge(3, 4, 5);
        graph.addEdge(4, 0, 1);
        
        graph.printAdjacencyList();
        
        System.out.println("顶点0的邻居: " + graph.getNeighbors(0));
        System.out.println("顶点0的度数: " + graph.getDegree(0));
        System.out.println("边(0,1)的权重: " + graph.getEdgeWeight(0, 1));
        System.out.println("是否存在边(0,2): " + graph.hasEdge(0, 2));
    }
    
    /**
     * 测试边集
     */
    public static void testEdgeList() {
        EdgeListGraph graph = new EdgeListGraph(false);
        
        // 添加边
        graph.addEdge(0, 1, 2);
        graph.addEdge(1, 2, 3);
        graph.addEdge(2, 3, 4);
        graph.addEdge(3, 4, 5);
        graph.addEdge(4, 0, 1);
        
        graph.printEdgeList();
        
        System.out.println("顶点0的邻居: " + graph.getNeighbors(0));
        System.out.println("顶点0的度数: " + graph.getDegree(0));
        System.out.println("边(0,1)的权重: " + graph.getEdgeWeight(0, 1));
        System.out.println("是否存在边(0,2): " + graph.hasEdge(0, 2));
    }
    
    /**
     * 测试前向星
     */
    public static void testForwardStar() {
        ForwardStarGraph graph = new ForwardStarGraph(5, 20, false);
        
        // 添加边
        graph.addEdge(0, 1, 2);
        graph.addEdge(1, 2, 3);
        graph.addEdge(2, 3, 4);
        graph.addEdge(3, 4, 5);
        graph.addEdge(4, 0, 1);
        
        graph.printForwardStar();
        
        System.out.println("顶点0的邻居: " + graph.getNeighbors(0));
        System.out.println("顶点0的度数: " + graph.getDegree(0));
        System.out.println("边(0,1)的权重: " + graph.getEdgeWeight(0, 1));
        System.out.println("是否存在边(0,2): " + graph.hasEdge(0, 2));
    }
    
    /**
     * 测试性能比较
     */
    public static void testPerformanceComparison() {
        // 测试小规模图
        GraphStorageComparison.comparePerformance(10, 20, false);
        
        // 测试中等规模图
        GraphStorageComparison.comparePerformance(100, 500, false);
        
        // 测试大规模图
        GraphStorageComparison.comparePerformance(1000, 5000, false);
    }
    
    /**
     * 测试图功能
     */
    public static void testGraphFunctions() {
        // 测试有向图
        System.out.println("测试有向图:");
        AdjacencyListGraph directedGraph = new AdjacencyListGraph(4, true);
        directedGraph.addEdge(0, 1);
        directedGraph.addEdge(1, 2);
        directedGraph.addEdge(2, 3);
        directedGraph.addEdge(3, 0);
        
        directedGraph.printAdjacencyList();
        
        // 测试无向图
        System.out.println("\n测试无向图:");
        AdjacencyListGraph undirectedGraph = new AdjacencyListGraph(4, false);
        undirectedGraph.addEdge(0, 1);
        undirectedGraph.addEdge(1, 2);
        undirectedGraph.addEdge(2, 3);
        undirectedGraph.addEdge(3, 0);
        
        undirectedGraph.printAdjacencyList();
        
        // 测试删除操作
        System.out.println("\n测试删除边:");
        undirectedGraph.removeEdge(0, 1);
        undirectedGraph.printAdjacencyList();
        
        // 测试删除顶点
        System.out.println("\n测试删除顶点:");
        undirectedGraph.removeVertex(2);
        undirectedGraph.printAdjacencyList();
    }
}
```
