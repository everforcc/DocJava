# 13.2.1. 数组与矩阵知识点概述 - Java代码示例

## 数组基本操作

```java
/**
 * 数组基本操作类
 */
public class ArrayOperations {
    
    /**
     * 数组遍历
     */
    public static void traverseArray(int[] arr) {
        System.out.print("数组元素: ");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
    
    /**
     * 增强for循环遍历
     */
    public static void traverseArrayEnhanced(int[] arr) {
        System.out.print("数组元素: ");
        for (int element : arr) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
    
    /**
     * 查找元素
     */
    public static int findElement(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1; // 未找到
    }
    
    /**
     * 查找所有匹配元素的位置
     */
    public static List<Integer> findAllElements(int[] arr, int target) {
        List<Integer> positions = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                positions.add(i);
            }
        }
        return positions;
    }
    
    /**
     * 计算数组元素和
     */
    public static int sumArray(int[] arr) {
        int sum = 0;
        for (int element : arr) {
            sum += element;
        }
        return sum;
    }
    
    /**
     * 计算数组平均值
     */
    public static double averageArray(int[] arr) {
        if (arr.length == 0) return 0;
        return (double) sumArray(arr) / arr.length;
    }
    
    /**
     * 查找最大值
     */
    public static int findMax(int[] arr) {
        if (arr.length == 0) throw new IllegalArgumentException("数组为空");
        
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;
    }
    
    /**
     * 查找最小值
     */
    public static int findMin(int[] arr) {
        if (arr.length == 0) throw new IllegalArgumentException("数组为空");
        
        int min = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] < min) {
                min = arr[i];
            }
        }
        return min;
    }
    
    /**
     * 数组反转
     */
    public static void reverseArray(int[] arr) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left < right) {
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
    
    /**
     * 数组排序（冒泡排序）
     */
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
    
    /**
     * 二分查找（要求数组已排序）
     */
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1; // 未找到
    }
}
```

## 矩阵基本操作

```java
/**
 * 矩阵操作类
 */
public class MatrixOperations {
    
    /**
     * 创建矩阵
     */
    public static int[][] createMatrix(int rows, int cols) {
        return new int[rows][cols];
    }
    
    /**
     * 创建并初始化矩阵
     */
    public static int[][] createMatrix(int rows, int cols, int initialValue) {
        int[][] matrix = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                matrix[i][j] = initialValue;
            }
        }
        return matrix;
    }
    
    /**
     * 打印矩阵
     */
    public static void printMatrix(int[][] matrix) {
        for (int[] row : matrix) {
            for (int element : row) {
                System.out.printf("%4d ", element);
            }
            System.out.println();
        }
    }
    
    /**
     * 矩阵转置
     */
    public static int[][] transpose(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[][] transposed = new int[cols][rows];
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                transposed[j][i] = matrix[i][j];
            }
        }
        
        return transposed;
    }
    
    /**
     * 矩阵加法
     */
    public static int[][] addMatrices(int[][] matrix1, int[][] matrix2) {
        int rows = matrix1.length;
        int cols = matrix1[0].length;
        
        if (matrix2.length != rows || matrix2[0].length != cols) {
            throw new IllegalArgumentException("矩阵维度不匹配");
        }
        
        int[][] result = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[i][j] = matrix1[i][j] + matrix2[i][j];
            }
        }
        
        return result;
    }
    
    /**
     * 矩阵乘法
     */
    public static int[][] multiplyMatrices(int[][] matrix1, int[][] matrix2) {
        int rows1 = matrix1.length;
        int cols1 = matrix1[0].length;
        int rows2 = matrix2.length;
        int cols2 = matrix2[0].length;
        
        if (cols1 != rows2) {
            throw new IllegalArgumentException("矩阵维度不匹配，无法相乘");
        }
        
        int[][] result = new int[rows1][cols2];
        for (int i = 0; i < rows1; i++) {
            for (int j = 0; j < cols2; j++) {
                for (int k = 0; k < cols1; k++) {
                    result[i][j] += matrix1[i][k] * matrix2[k][j];
                }
            }
        }
        
        return result;
    }
    
    /**
     * 标量乘法
     */
    public static int[][] scalarMultiply(int[][] matrix, int scalar) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[][] result = new int[rows][cols];
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[i][j] = matrix[i][j] * scalar;
            }
        }
        
        return result;
    }
    
    /**
     * 判断是否为方阵
     */
    public static boolean isSquareMatrix(int[][] matrix) {
        return matrix.length == matrix[0].length;
    }
    
    /**
     * 判断是否为对称矩阵
     */
    public static boolean isSymmetricMatrix(int[][] matrix) {
        if (!isSquareMatrix(matrix)) {
            return false;
        }
        
        int n = matrix.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] != matrix[j][i]) {
                    return false;
                }
            }
        }
        return true;
    }
    
    /**
     * 判断是否为对角矩阵
     */
    public static boolean isDiagonalMatrix(int[][] matrix) {
        if (!isSquareMatrix(matrix)) {
            return false;
        }
        
        int n = matrix.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i != j && matrix[i][j] != 0) {
                    return false;
                }
            }
        }
        return true;
    }
    
    /**
     * 计算矩阵对角线元素和
     */
    public static int diagonalSum(int[][] matrix) {
        if (!isSquareMatrix(matrix)) {
            throw new IllegalArgumentException("不是方阵");
        }
        
        int sum = 0;
        int n = matrix.length;
        for (int i = 0; i < n; i++) {
            sum += matrix[i][i];
        }
        return sum;
    }
}
```

## 特殊矩阵实现

```java
/**
 * 特殊矩阵类
 */
public class SpecialMatrices {
    
    /**
     * 创建单位矩阵
     */
    public static int[][] identityMatrix(int n) {
        int[][] matrix = new int[n][n];
        for (int i = 0; i < n; i++) {
            matrix[i][i] = 1;
        }
        return matrix;
    }
    
    /**
     * 创建对角矩阵
     */
    public static int[][] diagonalMatrix(int[] diagonal) {
        int n = diagonal.length;
        int[][] matrix = new int[n][n];
        for (int i = 0; i < n; i++) {
            matrix[i][i] = diagonal[i];
        }
        return matrix;
    }
    
    /**
     * 创建上三角矩阵
     */
    public static int[][] upperTriangularMatrix(int[][] matrix) {
        int n = matrix.length;
        int[][] result = new int[n][n];
        
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                result[i][j] = matrix[i][j];
            }
        }
        return result;
    }
    
    /**
     * 创建下三角矩阵
     */
    public static int[][] lowerTriangularMatrix(int[][] matrix) {
        int n = matrix.length;
        int[][] result = new int[n][n];
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                result[i][j] = matrix[i][j];
            }
        }
        return result;
    }
    
    /**
     * 稀疏矩阵压缩存储
     */
    public static class SparseMatrix {
        private int rows;
        private int cols;
        private List<Integer> values;
        private List<Integer> rowIndices;
        private List<Integer> colIndices;
        
        public SparseMatrix(int[][] matrix) {
            this.rows = matrix.length;
            this.cols = matrix[0].length;
            this.values = new ArrayList<>();
            this.rowIndices = new ArrayList<>();
            this.colIndices = new ArrayList<>();
            
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    if (matrix[i][j] != 0) {
                        values.add(matrix[i][j]);
                        rowIndices.add(i);
                        colIndices.add(j);
                    }
                }
            }
        }
        
        public int get(int row, int col) {
            for (int i = 0; i < values.size(); i++) {
                if (rowIndices.get(i) == row && colIndices.get(i) == col) {
                    return values.get(i);
                }
            }
            return 0;
        }
        
        public void set(int row, int col, int value) {
            for (int i = 0; i < values.size(); i++) {
                if (rowIndices.get(i) == row && colIndices.get(i) == col) {
                    if (value == 0) {
                        values.remove(i);
                        rowIndices.remove(i);
                        colIndices.remove(i);
                    } else {
                        values.set(i, value);
                    }
                    return;
                }
            }
            
            if (value != 0) {
                values.add(value);
                rowIndices.add(row);
                colIndices.add(col);
            }
        }
        
        public int[][] toDenseMatrix() {
            int[][] matrix = new int[rows][cols];
            for (int i = 0; i < values.size(); i++) {
                matrix[rowIndices.get(i)][colIndices.get(i)] = values.get(i);
            }
            return matrix;
        }
        
        public void print() {
            System.out.println("稀疏矩阵 (行, 列, 值):");
            for (int i = 0; i < values.size(); i++) {
                System.out.printf("(%d, %d, %d) ", 
                    rowIndices.get(i), colIndices.get(i), values.get(i));
            }
            System.out.println();
        }
    }
}
```

## 矩阵算法实现

```java
/**
 * 矩阵算法类
 */
public class MatrixAlgorithms {
    
    /**
     * 高斯消元法求矩阵的行阶梯形式
     */
    public static double[][] gaussianElimination(double[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        double[][] result = new double[rows][cols];
        
        // 复制矩阵
        for (int i = 0; i < rows; i++) {
            System.arraycopy(matrix[i], 0, result[i], 0, cols);
        }
        
        int lead = 0;
        for (int r = 0; r < rows; r++) {
            if (lead >= cols) break;
            
            int i = r;
            while (result[i][lead] == 0) {
                i++;
                if (i == rows) {
                    i = r;
                    lead++;
                    if (lead == cols) return result;
                }
            }
            
            // 交换行
            if (i != r) {
                double[] temp = result[i];
                result[i] = result[r];
                result[r] = temp;
            }
            
            // 归一化
            double div = result[r][lead];
            for (int j = 0; j < cols; j++) {
                result[r][j] /= div;
            }
            
            // 消元
            for (int k = 0; k < rows; k++) {
                if (k != r) {
                    double mult = result[k][lead];
                    for (int j = 0; j < cols; j++) {
                        result[k][j] -= mult * result[r][j];
                    }
                }
            }
            lead++;
        }
        
        return result;
    }
    
    /**
     * 计算矩阵的行列式（仅适用于方阵）
     */
    public static double determinant(double[][] matrix) {
        if (!MatrixOperations.isSquareMatrix(convertToInt(matrix))) {
            throw new IllegalArgumentException("只能计算方阵的行列式");
        }
        
        int n = matrix.length;
        if (n == 1) {
            return matrix[0][0];
        }
        
        if (n == 2) {
            return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
        }
        
        double det = 0;
        for (int j = 0; j < n; j++) {
            double[][] submatrix = new double[n - 1][n - 1];
            for (int i = 1; i < n; i++) {
                for (int k = 0; k < n; k++) {
                    if (k < j) {
                        submatrix[i - 1][k] = matrix[i][k];
                    } else if (k > j) {
                        submatrix[i - 1][k - 1] = matrix[i][k];
                    }
                }
            }
            det += Math.pow(-1, j) * matrix[0][j] * determinant(submatrix);
        }
        
        return det;
    }
    
    /**
     * 矩阵求逆（使用伴随矩阵方法）
     */
    public static double[][] inverse(double[][] matrix) {
        if (!MatrixOperations.isSquareMatrix(convertToInt(matrix))) {
            throw new IllegalArgumentException("只能计算方阵的逆矩阵");
        }
        
        int n = matrix.length;
        double det = determinant(matrix);
        if (Math.abs(det) < 1e-10) {
            throw new IllegalArgumentException("矩阵不可逆");
        }
        
        double[][] adjoint = adjointMatrix(matrix);
        double[][] inverse = new double[n][n];
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                inverse[i][j] = adjoint[i][j] / det;
            }
        }
        
        return inverse;
    }
    
    /**
     * 计算伴随矩阵
     */
    private static double[][] adjointMatrix(double[][] matrix) {
        int n = matrix.length;
        double[][] adjoint = new double[n][n];
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                double[][] submatrix = new double[n - 1][n - 1];
                for (int k = 0; k < n; k++) {
                    for (int l = 0; l < n; l++) {
                        if (k < i && l < j) {
                            submatrix[k][l] = matrix[k][l];
                        } else if (k < i && l > j) {
                            submatrix[k][l - 1] = matrix[k][l];
                        } else if (k > i && l < j) {
                            submatrix[k - 1][l] = matrix[k][l];
                        } else if (k > i && l > j) {
                            submatrix[k - 1][l - 1] = matrix[k][l];
                        }
                    }
                }
                adjoint[j][i] = Math.pow(-1, i + j) * determinant(submatrix);
            }
        }
        
        return adjoint;
    }
    
    /**
     * 辅助方法：将double矩阵转换为int矩阵
     */
    private static int[][] convertToInt(double[][] matrix) {
        int[][] result = new int[matrix.length][matrix[0].length];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                result[i][j] = (int) matrix[i][j];
            }
        }
        return result;
    }
}
```

## 测试代码

```java
/**
 * 数组与矩阵测试类
 */
public class ArrayMatrixTest {
    public static void main(String[] args) {
        System.out.println("=== 数组操作测试 ===");
        testArrayOperations();
        
        System.out.println("\n=== 矩阵操作测试 ===");
        testMatrixOperations();
        
        System.out.println("\n=== 特殊矩阵测试 ===");
        testSpecialMatrices();
        
        System.out.println("\n=== 稀疏矩阵测试 ===");
        testSparseMatrix();
    }
    
    /**
     * 测试数组操作
     */
    public static void testArrayOperations() {
        int[] arr = {5, 2, 8, 1, 9, 3, 7, 4, 6};
        
        System.out.println("原数组:");
        ArrayOperations.traverseArray(arr);
        
        System.out.println("数组和: " + ArrayOperations.sumArray(arr));
        System.out.println("数组平均值: " + ArrayOperations.averageArray(arr));
        System.out.println("最大值: " + ArrayOperations.findMax(arr));
        System.out.println("最小值: " + ArrayOperations.findMin(arr));
        
        int target = 7;
        int index = ArrayOperations.findElement(arr, target);
        System.out.println("查找元素 " + target + " 的位置: " + index);
        
        ArrayOperations.bubbleSort(arr);
        System.out.println("排序后:");
        ArrayOperations.traverseArray(arr);
        
        int searchResult = ArrayOperations.binarySearch(arr, target);
        System.out.println("二分查找元素 " + target + " 的位置: " + searchResult);
    }
    
    /**
     * 测试矩阵操作
     */
    public static void testMatrixOperations() {
        int[][] matrix1 = {{1, 2, 3}, {4, 5, 6}};
        int[][] matrix2 = {{7, 8, 9}, {10, 11, 12}};
        
        System.out.println("矩阵1:");
        MatrixOperations.printMatrix(matrix1);
        
        System.out.println("矩阵2:");
        MatrixOperations.printMatrix(matrix2);
        
        System.out.println("矩阵加法:");
        int[][] sum = MatrixOperations.addMatrices(matrix1, matrix2);
        MatrixOperations.printMatrix(sum);
        
        System.out.println("矩阵转置:");
        int[][] transposed = MatrixOperations.transpose(matrix1);
        MatrixOperations.printMatrix(transposed);
        
        int[][] squareMatrix = {{1, 2}, {3, 4}};
        System.out.println("方阵:");
        MatrixOperations.printMatrix(squareMatrix);
        System.out.println("是否为对称矩阵: " + MatrixOperations.isSymmetricMatrix(squareMatrix));
        System.out.println("是否为对角矩阵: " + MatrixOperations.isDiagonalMatrix(squareMatrix));
        System.out.println("对角线元素和: " + MatrixOperations.diagonalSum(squareMatrix));
    }
    
    /**
     * 测试特殊矩阵
     */
    public static void testSpecialMatrices() {
        System.out.println("单位矩阵:");
        int[][] identity = SpecialMatrices.identityMatrix(3);
        MatrixOperations.printMatrix(identity);
        
        System.out.println("对角矩阵:");
        int[] diagonal = {1, 2, 3};
        int[][] diagMatrix = SpecialMatrices.diagonalMatrix(diagonal);
        MatrixOperations.printMatrix(diagMatrix);
        
        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        System.out.println("原矩阵:");
        MatrixOperations.printMatrix(matrix);
        
        System.out.println("上三角矩阵:");
        int[][] upper = SpecialMatrices.upperTriangularMatrix(matrix);
        MatrixOperations.printMatrix(upper);
        
        System.out.println("下三角矩阵:");
        int[][] lower = SpecialMatrices.lowerTriangularMatrix(matrix);
        MatrixOperations.printMatrix(lower);
    }
    
    /**
     * 测试稀疏矩阵
     */
    public static void testSparseMatrix() {
        int[][] denseMatrix = {
            {1, 0, 0, 0},
            {0, 2, 0, 0},
            {0, 0, 0, 3},
            {0, 0, 0, 0}
        };
        
        System.out.println("稠密矩阵:");
        MatrixOperations.printMatrix(denseMatrix);
        
        SpecialMatrices.SparseMatrix sparse = new SpecialMatrices.SparseMatrix(denseMatrix);
        System.out.println("稀疏矩阵表示:");
        sparse.print();
        
        System.out.println("获取元素(2,3): " + sparse.get(2, 3));
        System.out.println("获取元素(0,1): " + sparse.get(0, 1));
        
        sparse.set(1, 1, 5);
        System.out.println("设置元素(1,1)为5后:");
        sparse.print();
        
        System.out.println("转换回稠密矩阵:");
        MatrixOperations.printMatrix(sparse.toDenseMatrix());
    }
}
```
