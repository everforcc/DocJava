# 13.2.3. 矩阵 - Java代码示例

## 矩阵基本操作实现

```java
/**
 * 矩阵操作类
 */
public class Matrix {
    private double[][] data;
    private int rows;
    private int cols;
    
    /**
     * 构造函数
     */
    public Matrix(int rows, int cols) {
        this.rows = rows;
        this.cols = cols;
        this.data = new double[rows][cols];
    }
    
    /**
     * 构造函数 - 从二维数组创建矩阵
     */
    public Matrix(double[][] data) {
        this.rows = data.length;
        this.cols = data[0].length;
        this.data = new double[rows][cols];
        
        for (int i = 0; i < rows; i++) {
            System.arraycopy(data[i], 0, this.data[i], 0, cols);
        }
    }
    
    /**
     * 获取元素
     */
    public double get(int row, int col) {
        return data[row][col];
    }
    
    /**
     * 设置元素
     */
    public void set(int row, int col, double value) {
        data[row][col] = value;
    }
    
    /**
     * 获取行数
     */
    public int getRows() {
        return rows;
    }
    
    /**
     * 获取列数
     */
    public int getCols() {
        return cols;
    }
    
    /**
     * 矩阵加法
     */
    public Matrix add(Matrix other) {
        if (this.rows != other.rows || this.cols != other.cols) {
            throw new IllegalArgumentException("矩阵维度不匹配");
        }
        
        Matrix result = new Matrix(rows, cols);
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result.data[i][j] = this.data[i][j] + other.data[i][j];
            }
        }
        return result;
    }
    
    /**
     * 矩阵减法
     */
    public Matrix subtract(Matrix other) {
        if (this.rows != other.rows || this.cols != other.cols) {
            throw new IllegalArgumentException("矩阵维度不匹配");
        }
        
        Matrix result = new Matrix(rows, cols);
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result.data[i][j] = this.data[i][j] - other.data[i][j];
            }
        }
        return result;
    }
    
    /**
     * 标量乘法
     */
    public Matrix scalarMultiply(double scalar) {
        Matrix result = new Matrix(rows, cols);
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result.data[i][j] = this.data[i][j] * scalar;
            }
        }
        return result;
    }
    
    /**
     * 矩阵乘法
     */
    public Matrix multiply(Matrix other) {
        if (this.cols != other.rows) {
            throw new IllegalArgumentException("矩阵维度不匹配，无法相乘");
        }
        
        Matrix result = new Matrix(this.rows, other.cols);
        for (int i = 0; i < this.rows; i++) {
            for (int j = 0; j < other.cols; j++) {
                for (int k = 0; k < this.cols; k++) {
                    result.data[i][j] += this.data[i][k] * other.data[k][j];
                }
            }
        }
        return result;
    }
    
    /**
     * 矩阵转置
     */
    public Matrix transpose() {
        Matrix result = new Matrix(cols, rows);
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result.data[j][i] = this.data[i][j];
            }
        }
        return result;
    }
    
    /**
     * 判断是否为方阵
     */
    public boolean isSquare() {
        return rows == cols;
    }
    
    /**
     * 判断是否为对称矩阵
     */
    public boolean isSymmetric() {
        if (!isSquare()) {
            return false;
        }
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (Math.abs(data[i][j] - data[j][i]) > 1e-10) {
                    return false;
                }
            }
        }
        return true;
    }
    
    /**
     * 计算矩阵的迹（主对角线元素之和）
     */
    public double trace() {
        if (!isSquare()) {
            throw new IllegalArgumentException("只有方阵才能计算迹");
        }
        
        double trace = 0;
        for (int i = 0; i < rows; i++) {
            trace += data[i][i];
        }
        return trace;
    }
    
    /**
     * 计算矩阵的行列式
     */
    public double determinant() {
        if (!isSquare()) {
            throw new IllegalArgumentException("只有方阵才能计算行列式");
        }
        
        return determinantRecursive(data);
    }
    
    private double determinantRecursive(double[][] matrix) {
        int n = matrix.length;
        
        if (n == 1) {
            return matrix[0][0];
        }
        
        if (n == 2) {
            return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
        }
        
        double det = 0;
        for (int j = 0; j < n; j++) {
            double[][] submatrix = new double[n - 1][n - 1];
            for (int i = 1; i < n; i++) {
                for (int k = 0; k < n; k++) {
                    if (k < j) {
                        submatrix[i - 1][k] = matrix[i][k];
                    } else if (k > j) {
                        submatrix[i - 1][k - 1] = matrix[i][k];
                    }
                }
            }
            det += Math.pow(-1, j) * matrix[0][j] * determinantRecursive(submatrix);
        }
        
        return det;
    }
    
    /**
     * 计算矩阵的逆
     */
    public Matrix inverse() {
        if (!isSquare()) {
            throw new IllegalArgumentException("只有方阵才能求逆");
        }
        
        double det = determinant();
        if (Math.abs(det) < 1e-10) {
            throw new IllegalArgumentException("矩阵不可逆");
        }
        
        Matrix adjoint = adjoint();
        return adjoint.scalarMultiply(1.0 / det);
    }
    
    /**
     * 计算伴随矩阵
     */
    private Matrix adjoint() {
        Matrix adjoint = new Matrix(rows, cols);
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                double[][] submatrix = new double[rows - 1][cols - 1];
                for (int k = 0; k < rows; k++) {
                    for (int l = 0; l < cols; l++) {
                        if (k < i && l < j) {
                            submatrix[k][l] = data[k][l];
                        } else if (k < i && l > j) {
                            submatrix[k][l - 1] = data[k][l];
                        } else if (k > i && l < j) {
                            submatrix[k - 1][l] = data[k][l];
                        } else if (k > i && l > j) {
                            submatrix[k - 1][l - 1] = data[k][l];
                        }
                    }
                }
                adjoint.data[j][i] = Math.pow(-1, i + j) * determinantRecursive(submatrix);
            }
        }
        
        return adjoint;
    }
    
    /**
     * 打印矩阵
     */
    public void print() {
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                System.out.printf("%8.2f ", data[i][j]);
            }
            System.out.println();
        }
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < rows; i++) {
            sb.append("[");
            for (int j = 0; j < cols; j++) {
                sb.append(String.format("%.2f", data[i][j]));
                if (j < cols - 1) {
                    sb.append(", ");
                }
            }
            sb.append("]");
            if (i < rows - 1) {
                sb.append("\n");
            }
        }
        return sb.toString();
    }
}
```

## 特殊矩阵实现

```java
/**
 * 特殊矩阵工厂类
 */
public class SpecialMatrices {
    
    /**
     * 创建零矩阵
     */
    public static Matrix zeros(int rows, int cols) {
        return new Matrix(rows, cols);
    }
    
    /**
     * 创建单位矩阵
     */
    public static Matrix identity(int n) {
        Matrix matrix = new Matrix(n, n);
        for (int i = 0; i < n; i++) {
            matrix.set(i, i, 1.0);
        }
        return matrix;
    }
    
    /**
     * 创建对角矩阵
     */
    public static Matrix diagonal(double[] diagonal) {
        int n = diagonal.length;
        Matrix matrix = new Matrix(n, n);
        for (int i = 0; i < n; i++) {
            matrix.set(i, i, diagonal[i]);
        }
        return matrix;
    }
    
    /**
     * 创建随机矩阵
     */
    public static Matrix random(int rows, int cols, double min, double max) {
        Matrix matrix = new Matrix(rows, cols);
        Random random = new Random();
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                double value = min + (max - min) * random.nextDouble();
                matrix.set(i, j, value);
            }
        }
        return matrix;
    }
    
    /**
     * 创建上三角矩阵
     */
    public static Matrix upperTriangular(Matrix matrix) {
        if (!matrix.isSquare()) {
            throw new IllegalArgumentException("只有方阵才能创建上三角矩阵");
        }
        
        int n = matrix.getRows();
        Matrix result = new Matrix(n, n);
        
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                result.set(i, j, matrix.get(i, j));
            }
        }
        return result;
    }
    
    /**
     * 创建下三角矩阵
     */
    public static Matrix lowerTriangular(Matrix matrix) {
        if (!matrix.isSquare()) {
            throw new IllegalArgumentException("只有方阵才能创建下三角矩阵");
        }
        
        int n = matrix.getRows();
        Matrix result = new Matrix(n, n);
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                result.set(i, j, matrix.get(i, j));
            }
        }
        return result;
    }
}
```

## 矩阵分解算法

```java
/**
 * 矩阵分解算法类
 */
public class MatrixDecomposition {
    
    /**
     * LU分解
     */
    public static class LUResult {
        public Matrix L;
        public Matrix U;
        public int[] pivot;
        
        public LUResult(Matrix L, Matrix U, int[] pivot) {
            this.L = L;
            this.U = U;
            this.pivot = pivot;
        }
    }
    
    public static LUResult luDecomposition(Matrix matrix) {
        if (!matrix.isSquare()) {
            throw new IllegalArgumentException("只有方阵才能进行LU分解");
        }
        
        int n = matrix.getRows();
        Matrix L = Matrix.identity(n);
        Matrix U = new Matrix(matrix);
        int[] pivot = new int[n];
        
        for (int i = 0; i < n; i++) {
            pivot[i] = i;
        }
        
        for (int k = 0; k < n - 1; k++) {
            // 部分主元选择
            int maxRow = k;
            for (int i = k + 1; i < n; i++) {
                if (Math.abs(U.get(i, k)) > Math.abs(U.get(maxRow, k))) {
                    maxRow = i;
                }
            }
            
            if (maxRow != k) {
                // 交换行
                U.swapRows(k, maxRow);
                L.swapRows(k, maxRow);
                L.swapColumns(k, maxRow);
                
                // 更新置换向量
                int temp = pivot[k];
                pivot[k] = pivot[maxRow];
                pivot[maxRow] = temp;
            }
            
            // 消元
            for (int i = k + 1; i < n; i++) {
                double factor = U.get(i, k) / U.get(k, k);
                L.set(i, k, factor);
                
                for (int j = k; j < n; j++) {
                    double newValue = U.get(i, j) - factor * U.get(k, j);
                    U.set(i, j, newValue);
                }
            }
        }
        
        return new LUResult(L, U, pivot);
    }
    
    /**
     * QR分解（Gram-Schmidt方法）
     */
    public static class QRResult {
        public Matrix Q;
        public Matrix R;
        
        public QRResult(Matrix Q, Matrix R) {
            this.Q = Q;
            this.R = R;
        }
    }
    
    public static QRResult qrDecomposition(Matrix matrix) {
        int m = matrix.getRows();
        int n = matrix.getCols();
        
        Matrix Q = new Matrix(m, n);
        Matrix R = new Matrix(n, n);
        
        // Gram-Schmidt正交化过程
        for (int j = 0; j < n; j++) {
            // 计算Q的第j列
            for (int i = 0; i < m; i++) {
                Q.set(i, j, matrix.get(i, j));
            }
            
            // 减去前面所有列的投影
            for (int k = 0; k < j; k++) {
                double dotProduct = 0;
                for (int i = 0; i < m; i++) {
                    dotProduct += Q.get(i, k) * matrix.get(i, j);
                }
                R.set(k, j, dotProduct);
                
                for (int i = 0; i < m; i++) {
                    double newValue = Q.get(i, j) - dotProduct * Q.get(i, k);
                    Q.set(i, j, newValue);
                }
            }
            
            // 归一化
            double norm = 0;
            for (int i = 0; i < m; i++) {
                norm += Q.get(i, j) * Q.get(i, j);
            }
            norm = Math.sqrt(norm);
            
            if (norm > 1e-10) {
                for (int i = 0; i < m; i++) {
                    Q.set(i, j, Q.get(i, j) / norm);
                }
                R.set(j, j, norm);
            }
        }
        
        return new QRResult(Q, R);
    }
}
```

## 矩阵运算扩展

```java
/**
 * 矩阵运算扩展类
 */
public class MatrixOperations {
    
    /**
     * 矩阵的幂运算
     */
    public static Matrix power(Matrix matrix, int n) {
        if (!matrix.isSquare()) {
            throw new IllegalArgumentException("只有方阵才能进行幂运算");
        }
        
        if (n == 0) {
            return Matrix.identity(matrix.getRows());
        }
        
        if (n == 1) {
            return new Matrix(matrix);
        }
        
        if (n < 0) {
            Matrix inverse = matrix.inverse();
            return power(inverse, -n);
        }
        
        // 快速幂算法
        Matrix result = Matrix.identity(matrix.getRows());
        Matrix base = new Matrix(matrix);
        
        while (n > 0) {
            if (n % 2 == 1) {
                result = result.multiply(base);
            }
            base = base.multiply(base);
            n /= 2;
        }
        
        return result;
    }
    
    /**
     * 矩阵的范数计算
     */
    public static class MatrixNorms {
        
        /**
         * 1-范数（列和的最大值）
         */
        public static double norm1(Matrix matrix) {
            double maxColSum = 0;
            for (int j = 0; j < matrix.getCols(); j++) {
                double colSum = 0;
                for (int i = 0; i < matrix.getRows(); i++) {
                    colSum += Math.abs(matrix.get(i, j));
                }
                maxColSum = Math.max(maxColSum, colSum);
            }
            return maxColSum;
        }
        
        /**
         * 无穷范数（行和的最大值）
         */
        public static double normInf(Matrix matrix) {
            double maxRowSum = 0;
            for (int i = 0; i < matrix.getRows(); i++) {
                double rowSum = 0;
                for (int j = 0; j < matrix.getCols(); j++) {
                    rowSum += Math.abs(matrix.get(i, j));
                }
                maxRowSum = Math.max(maxRowSum, rowSum);
            }
            return maxRowSum;
        }
        
        /**
         * Frobenius范数（所有元素平方和的平方根）
         */
        public static double normFrobenius(Matrix matrix) {
            double sum = 0;
            for (int i = 0; i < matrix.getRows(); i++) {
                for (int j = 0; j < matrix.getCols(); j++) {
                    double value = matrix.get(i, j);
                    sum += value * value;
                }
            }
            return Math.sqrt(sum);
        }
    }
    
    /**
     * 矩阵的条件数
     */
    public static double conditionNumber(Matrix matrix) {
        if (!matrix.isSquare()) {
            throw new IllegalArgumentException("只有方阵才能计算条件数");
        }
        
        try {
            Matrix inverse = matrix.inverse();
            return MatrixNorms.norm1(matrix) * MatrixNorms.norm1(inverse);
        } catch (IllegalArgumentException e) {
            return Double.POSITIVE_INFINITY;
        }
    }
}
```

## 测试代码

```java
/**
 * 矩阵测试类
 */
public class MatrixTest {
    public static void main(String[] args) {
        System.out.println("=== 矩阵基本操作测试 ===");
        testBasicOperations();
        
        System.out.println("\n=== 特殊矩阵测试 ===");
        testSpecialMatrices();
        
        System.out.println("\n=== 矩阵分解测试 ===");
        testMatrixDecomposition();
        
        System.out.println("\n=== 矩阵运算扩展测试 ===");
        testMatrixOperations();
    }
    
    /**
     * 测试基本操作
     */
    public static void testBasicOperations() {
        double[][] data1 = {{1, 2}, {3, 4}};
        double[][] data2 = {{5, 6}, {7, 8}};
        
        Matrix matrix1 = new Matrix(data1);
        Matrix matrix2 = new Matrix(data2);
        
        System.out.println("矩阵1:");
        matrix1.print();
        
        System.out.println("矩阵2:");
        matrix2.print();
        
        System.out.println("矩阵加法:");
        Matrix sum = matrix1.add(matrix2);
        sum.print();
        
        System.out.println("矩阵乘法:");
        Matrix product = matrix1.multiply(matrix2);
        product.print();
        
        System.out.println("矩阵转置:");
        Matrix transpose = matrix1.transpose();
        transpose.print();
        
        System.out.println("矩阵行列式: " + matrix1.determinant());
        System.out.println("矩阵迹: " + matrix1.trace());
        System.out.println("是否对称: " + matrix1.isSymmetric());
    }
    
    /**
     * 测试特殊矩阵
     */
    public static void testSpecialMatrices() {
        System.out.println("单位矩阵:");
        Matrix identity = SpecialMatrices.identity(3);
        identity.print();
        
        System.out.println("对角矩阵:");
        double[] diagonal = {1, 2, 3};
        Matrix diagMatrix = SpecialMatrices.diagonal(diagonal);
        diagMatrix.print();
        
        System.out.println("随机矩阵:");
        Matrix randomMatrix = SpecialMatrices.random(3, 3, 0, 10);
        randomMatrix.print();
    }
    
    /**
     * 测试矩阵分解
     */
    public static void testMatrixDecomposition() {
        double[][] data = {{4, 3}, {6, 3}};
        Matrix matrix = new Matrix(data);
        
        System.out.println("原矩阵:");
        matrix.print();
        
        try {
            System.out.println("LU分解:");
            MatrixDecomposition.LUResult lu = MatrixDecomposition.luDecomposition(matrix);
            System.out.println("L矩阵:");
            lu.L.print();
            System.out.println("U矩阵:");
            lu.U.print();
            
            System.out.println("QR分解:");
            MatrixDecomposition.QRResult qr = MatrixDecomposition.qrDecomposition(matrix);
            System.out.println("Q矩阵:");
            qr.Q.print();
            System.out.println("R矩阵:");
            qr.R.print();
        } catch (Exception e) {
            System.out.println("分解失败: " + e.getMessage());
        }
    }
    
    /**
     * 测试矩阵运算扩展
     */
    public static void testMatrixOperations() {
        double[][] data = {{2, 0}, {0, 2}};
        Matrix matrix = new Matrix(data);
        
        System.out.println("原矩阵:");
        matrix.print();
        
        System.out.println("矩阵的3次幂:");
        Matrix power = MatrixOperations.power(matrix, 3);
        power.print();
        
        System.out.println("矩阵范数:");
        System.out.println("1-范数: " + MatrixOperations.MatrixNorms.norm1(matrix));
        System.out.println("无穷范数: " + MatrixOperations.MatrixNorms.normInf(matrix));
        System.out.println("Frobenius范数: " + MatrixOperations.MatrixNorms.normFrobenius(matrix));
        
        System.out.println("条件数: " + MatrixOperations.conditionNumber(matrix));
    }
}
```
