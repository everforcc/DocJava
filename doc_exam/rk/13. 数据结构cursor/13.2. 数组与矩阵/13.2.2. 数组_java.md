# 13.2.2. 数组 - Java代码示例

## 数组基本操作实现

```java
/**
 * 数组操作工具类
 */
public class ArrayUtils {
    
    /**
     * 创建数组
     */
    public static int[] createArray(int size) {
        return new int[size];
    }
    
    /**
     * 创建并初始化数组
     */
    public static int[] createArray(int size, int initialValue) {
        int[] arr = new int[size];
        Arrays.fill(arr, initialValue);
        return arr;
    }
    
    /**
     * 数组复制
     */
    public static int[] copyArray(int[] original) {
        return Arrays.copyOf(original, original.length);
    }
    
    /**
     * 数组部分复制
     */
    public static int[] copyArray(int[] original, int from, int to) {
        return Arrays.copyOfRange(original, from, to);
    }
    
    /**
     * 数组填充
     */
    public static void fillArray(int[] arr, int value) {
        Arrays.fill(arr, value);
    }
    
    /**
     * 数组部分填充
     */
    public static void fillArray(int[] arr, int from, int to, int value) {
        Arrays.fill(arr, from, to, value);
    }
    
    /**
     * 数组排序
     */
    public static void sortArray(int[] arr) {
        Arrays.sort(arr);
    }
    
    /**
     * 数组部分排序
     */
    public static void sortArray(int[] arr, int from, int to) {
        Arrays.sort(arr, from, to);
    }
    
    /**
     * 二分查找
     */
    public static int binarySearch(int[] arr, int key) {
        return Arrays.binarySearch(arr, key);
    }
    
    /**
     * 数组比较
     */
    public static boolean equals(int[] arr1, int[] arr2) {
        return Arrays.equals(arr1, arr2);
    }
    
    /**
     * 数组转字符串
     */
    public static String toString(int[] arr) {
        return Arrays.toString(arr);
    }
}
```

## 动态数组实现

```java
/**
 * 动态数组实现
 */
public class DynamicArray<T> {
    private Object[] data;
    private int size;
    private int capacity;
    private static final int DEFAULT_CAPACITY = 10;
    
    public DynamicArray() {
        this(DEFAULT_CAPACITY);
    }
    
    public DynamicArray(int initialCapacity) {
        this.capacity = initialCapacity;
        this.data = new Object[capacity];
        this.size = 0;
    }
    
    /**
     * 添加元素
     */
    public void add(T element) {
        if (size >= capacity) {
            resize();
        }
        data[size++] = element;
    }
    
    /**
     * 在指定位置插入元素
     */
    public void add(int index, T element) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        if (size >= capacity) {
            resize();
        }
        
        // 移动元素
        for (int i = size; i > index; i--) {
            data[i] = data[i - 1];
        }
        
        data[index] = element;
        size++;
    }
    
    /**
     * 获取元素
     */
    @SuppressWarnings("unchecked")
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        return (T) data[index];
    }
    
    /**
     * 设置元素
     */
    public void set(int index, T element) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        data[index] = element;
    }
    
    /**
     * 删除元素
     */
    @SuppressWarnings("unchecked")
    public T remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        T element = (T) data[index];
        
        // 移动元素
        for (int i = index; i < size - 1; i++) {
            data[i] = data[i + 1];
        }
        
        size--;
        return element;
    }
    
    /**
     * 查找元素
     */
    public int indexOf(T element) {
        for (int i = 0; i < size; i++) {
            if (Objects.equals(data[i], element)) {
                return i;
            }
        }
        return -1;
    }
    
    /**
     * 判断是否包含元素
     */
    public boolean contains(T element) {
        return indexOf(element) != -1;
    }
    
    /**
     * 获取大小
     */
    public int size() {
        return size;
    }
    
    /**
     * 判断是否为空
     */
    public boolean isEmpty() {
        return size == 0;
    }
    
    /**
     * 清空数组
     */
    public void clear() {
        size = 0;
    }
    
    /**
     * 扩容
     */
    private void resize() {
        capacity *= 2;
        Object[] newData = new Object[capacity];
        System.arraycopy(data, 0, newData, 0, size);
        data = newData;
    }
    
    /**
     * 转换为数组
     */
    @SuppressWarnings("unchecked")
    public T[] toArray() {
        T[] array = (T[]) new Object[size];
        System.arraycopy(data, 0, array, 0, size);
        return array;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        for (int i = 0; i < size; i++) {
            sb.append(data[i]);
            if (i < size - 1) {
                sb.append(", ");
            }
        }
        sb.append("]");
        return sb.toString();
    }
}
```

## 数组算法实现

```java
/**
 * 数组算法类
 */
public class ArrayAlgorithms {
    
    /**
     * 冒泡排序
     */
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                    swapped = true;
                }
            }
            if (!swapped) break; // 优化：如果一轮没有交换，说明已排序
        }
    }
    
    /**
     * 选择排序
     */
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            if (minIndex != i) {
                swap(arr, i, minIndex);
            }
        }
    }
    
    /**
     * 插入排序
     */
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }
    
    /**
     * 快速排序
     */
    public static void quickSort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }
    
    private static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    /**
     * 归并排序
     */
    public static void mergeSort(int[] arr) {
        mergeSort(arr, 0, arr.length - 1);
    }
    
    private static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }
    
    private static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        int[] leftArr = new int[n1];
        int[] rightArr = new int[n2];
        
        System.arraycopy(arr, left, leftArr, 0, n1);
        System.arraycopy(arr, mid + 1, rightArr, 0, n2);
        
        int i = 0, j = 0, k = left;
        
        while (i < n1 && j < n2) {
            if (leftArr[i] <= rightArr[j]) {
                arr[k] = leftArr[i];
                i++;
            } else {
                arr[k] = rightArr[j];
                j++;
            }
            k++;
        }
        
        while (i < n1) {
            arr[k] = leftArr[i];
            i++;
            k++;
        }
        
        while (j < n2) {
            arr[k] = rightArr[j];
            j++;
            k++;
        }
    }
    
    /**
     * 堆排序
     */
    public static void heapSort(int[] arr) {
        int n = arr.length;
        
        // 构建最大堆
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // 逐个提取元素
        for (int i = n - 1; i > 0; i--) {
            swap(arr, 0, i);
            heapify(arr, i, 0);
        }
    }
    
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
    
    /**
     * 交换元素
     */
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    /**
     * 线性查找
     */
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1;
    }
    
    /**
     * 二分查找（要求数组已排序）
     */
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1;
    }
    
    /**
     * 查找第k小的元素
     */
    public static int findKthSmallest(int[] arr, int k) {
        if (k < 1 || k > arr.length) {
            throw new IllegalArgumentException("k值不合法");
        }
        
        int[] copy = Arrays.copyOf(arr, arr.length);
        Arrays.sort(copy);
        return copy[k - 1];
    }
    
    /**
     * 查找最大子数组和（Kadane算法）
     */
    public static int maxSubarraySum(int[] arr) {
        int maxSoFar = arr[0];
        int maxEndingHere = arr[0];
        
        for (int i = 1; i < arr.length; i++) {
            maxEndingHere = Math.max(arr[i], maxEndingHere + arr[i]);
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }
        
        return maxSoFar;
    }
}
```

## 数组应用示例

```java
/**
 * 数组应用示例
 */
public class ArrayApplications {
    
    /**
     * 两数之和
     */
    public static int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }
            map.put(nums[i], i);
        }
        
        throw new IllegalArgumentException("没有找到解");
    }
    
    /**
     * 移动零
     */
    public static void moveZeroes(int[] nums) {
        int writeIndex = 0;
        
        // 将所有非零元素移到前面
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[writeIndex++] = nums[i];
            }
        }
        
        // 将剩余位置填零
        while (writeIndex < nums.length) {
            nums[writeIndex++] = 0;
        }
    }
    
    /**
     * 旋转数组
     */
    public static void rotate(int[] nums, int k) {
        k = k % nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }
    
    private static void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
    
    /**
     * 删除重复元素
     */
    public static int removeDuplicates(int[] nums) {
        if (nums.length == 0) return 0;
        
        int writeIndex = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] != nums[i - 1]) {
                nums[writeIndex++] = nums[i];
            }
        }
        
        return writeIndex;
    }
    
    /**
     * 合并两个有序数组
     */
    public static void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
    
    /**
     * 寻找峰值
     */
    public static int findPeakElement(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        
        return left;
    }
}
```

## 测试代码

```java
/**
 * 数组测试类
 */
public class ArrayTest {
    public static void main(String[] args) {
        System.out.println("=== 数组工具测试 ===");
        testArrayUtils();
        
        System.out.println("\n=== 动态数组测试 ===");
        testDynamicArray();
        
        System.out.println("\n=== 排序算法测试 ===");
        testSortingAlgorithms();
        
        System.out.println("\n=== 查找算法测试 ===");
        testSearchAlgorithms();
        
        System.out.println("\n=== 应用示例测试 ===");
        testApplications();
    }
    
    /**
     * 测试数组工具
     */
    public static void testArrayUtils() {
        int[] arr = {5, 2, 8, 1, 9};
        System.out.println("原数组: " + ArrayUtils.toString(arr));
        
        int[] copy = ArrayUtils.copyArray(arr);
        System.out.println("复制数组: " + ArrayUtils.toString(copy));
        
        ArrayUtils.sortArray(arr);
        System.out.println("排序后: " + ArrayUtils.toString(arr));
        
        int index = ArrayUtils.binarySearch(arr, 8);
        System.out.println("查找8的位置: " + index);
    }
    
    /**
     * 测试动态数组
     */
    public static void testDynamicArray() {
        DynamicArray<Integer> dynamicArray = new DynamicArray<>();
        
        for (int i = 1; i <= 5; i++) {
            dynamicArray.add(i);
        }
        System.out.println("添加元素后: " + dynamicArray);
        
        dynamicArray.add(2, 99);
        System.out.println("在位置2插入99后: " + dynamicArray);
        
        int removed = dynamicArray.remove(3);
        System.out.println("删除位置3的元素: " + removed);
        System.out.println("删除后: " + dynamicArray);
    }
    
    /**
     * 测试排序算法
     */
    public static void testSortingAlgorithms() {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("原数组: " + Arrays.toString(arr));
        
        int[] bubbleArr = arr.clone();
        ArrayAlgorithms.bubbleSort(bubbleArr);
        System.out.println("冒泡排序: " + Arrays.toString(bubbleArr));
        
        int[] quickArr = arr.clone();
        ArrayAlgorithms.quickSort(quickArr);
        System.out.println("快速排序: " + Arrays.toString(quickArr));
        
        int[] mergeArr = arr.clone();
        ArrayAlgorithms.mergeSort(mergeArr);
        System.out.println("归并排序: " + Arrays.toString(mergeArr));
    }
    
    /**
     * 测试查找算法
     */
    public static void testSearchAlgorithms() {
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15};
        int target = 7;
        
        int linearResult = ArrayAlgorithms.linearSearch(arr, target);
        System.out.println("线性查找 " + target + " 的位置: " + linearResult);
        
        int binaryResult = ArrayAlgorithms.binarySearch(arr, target);
        System.out.println("二分查找 " + target + " 的位置: " + binaryResult);
        
        int kth = ArrayAlgorithms.findKthSmallest(arr, 3);
        System.out.println("第3小的元素: " + kth);
    }
    
    /**
     * 测试应用示例
     */
    public static void testApplications() {
        int[] nums = {2, 7, 11, 15};
        int target = 9;
        int[] result = ArrayApplications.twoSum(nums, target);
        System.out.println("两数之和: " + Arrays.toString(result));
        
        int[] zeroNums = {0, 1, 0, 3, 12};
        ArrayApplications.moveZeroes(zeroNums);
        System.out.println("移动零后: " + Arrays.toString(zeroNums));
        
        int[] rotateNums = {1, 2, 3, 4, 5, 6, 7};
        ArrayApplications.rotate(rotateNums, 3);
        System.out.println("旋转3位后: " + Arrays.toString(rotateNums));
    }
}
```
