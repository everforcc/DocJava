# 14.4.1. 查找算法知识点概述 - Java代码示例

## 顺序查找算法

```java
/**
 * 顺序查找算法
 */
public class SequentialSearch {
    
    /**
     * 基本顺序查找
     */
    public static int sequentialSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1; // 未找到
    }
    
    /**
     * 改进的顺序查找（哨兵）
     */
    public static int sequentialSearchWithSentinel(int[] arr, int target) {
        int n = arr.length;
        if (arr[n - 1] == target) {
            return n - 1;
        }
        
        // 设置哨兵
        int temp = arr[n - 1];
        arr[n - 1] = target;
        
        int i = 0;
        while (arr[i] != target) {
            i++;
        }
        
        // 恢复原值
        arr[n - 1] = temp;
        
        if (i < n - 1 || arr[n - 1] == target) {
            return i;
        }
        return -1;
    }
    
    /**
     * 查找所有匹配的元素
     */
    public static List<Integer> findAll(int[] arr, int target) {
        List<Integer> result = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                result.add(i);
            }
        }
        return result;
    }
    
    /**
     * 查找第一个匹配的元素
     */
    public static int findFirst(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1;
    }
    
    /**
     * 查找最后一个匹配的元素
     */
    public static int findLast(int[] arr, int target) {
        for (int i = arr.length - 1; i >= 0; i--) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1;
    }
}
```

## 二分查找算法

```java
/**
 * 二分查找算法
 */
public class BinarySearch {
    
    /**
     * 基本二分查找（递归）
     */
    public static int binarySearchRecursive(int[] arr, int target) {
        return binarySearchRecursive(arr, target, 0, arr.length - 1);
    }
    
    private static int binarySearchRecursive(int[] arr, int target, int left, int right) {
        if (left > right) {
            return -1;
        }
        
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] > target) {
            return binarySearchRecursive(arr, target, left, mid - 1);
        } else {
            return binarySearchRecursive(arr, target, mid + 1, right);
        }
    }
    
    /**
     * 基本二分查找（迭代）
     */
    public static int binarySearchIterative(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        return -1;
    }
    
    /**
     * 查找第一个等于目标值的位置
     */
    public static int findFirstEqual(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                result = mid;
                right = mid - 1; // 继续在左半部分查找
            } else if (arr[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        return result;
    }
    
    /**
     * 查找最后一个等于目标值的位置
     */
    public static int findLastEqual(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                result = mid;
                left = mid + 1; // 继续在右半部分查找
            } else if (arr[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        return result;
    }
    
    /**
     * 查找第一个大于等于目标值的位置
     */
    public static int findFirstGreaterOrEqual(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        int result = arr.length;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] >= target) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        return result;
    }
    
    /**
     * 查找最后一个小于等于目标值的位置
     */
    public static int findLastLessOrEqual(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] <= target) {
                result = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    /**
     * 查找目标值的插入位置
     */
    public static int findInsertPosition(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        return left;
    }
}
```

## 插值查找算法

```java
/**
 * 插值查找算法
 */
public class InterpolationSearch {
    
    /**
     * 插值查找
     */
    public static int interpolationSearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right && target >= arr[left] && target <= arr[right]) {
            if (left == right) {
                if (arr[left] == target) {
                    return left;
                }
                return -1;
            }
            
            // 计算插值位置
            int pos = left + (target - arr[left]) * (right - left) / (arr[right] - arr[left]);
            
            if (arr[pos] == target) {
                return pos;
            } else if (arr[pos] < target) {
                left = pos + 1;
            } else {
                right = pos - 1;
            }
        }
        
        return -1;
    }
    
    /**
     * 插值查找（递归）
     */
    public static int interpolationSearchRecursive(int[] arr, int target) {
        return interpolationSearchRecursive(arr, target, 0, arr.length - 1);
    }
    
    private static int interpolationSearchRecursive(int[] arr, int target, int left, int right) {
        if (left > right || target < arr[left] || target > arr[right]) {
            return -1;
        }
        
        if (left == right) {
            return arr[left] == target ? left : -1;
        }
        
        int pos = left + (target - arr[left]) * (right - left) / (arr[right] - arr[left]);
        
        if (arr[pos] == target) {
            return pos;
        } else if (arr[pos] < target) {
            return interpolationSearchRecursive(arr, target, pos + 1, right);
        } else {
            return interpolationSearchRecursive(arr, target, left, pos - 1);
        }
    }
}
```

## 斐波那契查找算法

```java
/**
 * 斐波那契查找算法
 */
public class FibonacciSearch {
    
    /**
     * 生成斐波那契数列
     */
    private static int[] generateFibonacci(int n) {
        int[] fib = new int[n];
        fib[0] = 0;
        fib[1] = 1;
        
        for (int i = 2; i < n; i++) {
            fib[i] = fib[i - 1] + fib[i - 2];
        }
        
        return fib;
    }
    
    /**
     * 斐波那契查找
     */
    public static int fibonacciSearch(int[] arr, int target) {
        int n = arr.length;
        int[] fib = generateFibonacci(20); // 生成足够大的斐波那契数列
        
        // 找到大于等于n的最小斐波那契数
        int k = 0;
        while (fib[k] < n) {
            k++;
        }
        
        // 扩展数组到斐波那契长度
        int[] temp = new int[fib[k]];
        System.arraycopy(arr, 0, temp, 0, n);
        for (int i = n; i < fib[k]; i++) {
            temp[i] = arr[n - 1]; // 用最后一个元素填充
        }
        
        int left = 0;
        int right = fib[k] - 1;
        
        while (left <= right) {
            int mid = left + fib[k - 1] - 1;
            
            if (target < temp[mid]) {
                right = mid - 1;
                k = k - 1;
            } else if (target > temp[mid]) {
                left = mid + 1;
                k = k - 2;
            } else {
                if (mid < n) {
                    return mid;
                } else {
                    return n - 1;
                }
            }
        }
        
        return -1;
    }
}
```

## 哈希查找算法

```java
/**
 * 哈希查找算法
 */
public class HashSearch {
    
    /**
     * 简单哈希表实现
     */
    public static class SimpleHashTable {
        private int[] table;
        private int size;
        private boolean[] occupied;
        
        public SimpleHashTable(int size) {
            this.size = size;
            this.table = new int[size];
            this.occupied = new boolean[size];
        }
        
        /**
         * 哈希函数
         */
        private int hash(int key) {
            return key % size;
        }
        
        /**
         * 插入元素
         */
        public void insert(int key) {
            int index = hash(key);
            
            // 线性探测解决冲突
            while (occupied[index]) {
                index = (index + 1) % size;
            }
            
            table[index] = key;
            occupied[index] = true;
        }
        
        /**
         * 查找元素
         */
        public int search(int key) {
            int index = hash(key);
            int originalIndex = index;
            
            while (occupied[index]) {
                if (table[index] == key) {
                    return index;
                }
                index = (index + 1) % size;
                
                // 避免无限循环
                if (index == originalIndex) {
                    break;
                }
            }
            
            return -1;
        }
        
        /**
         * 删除元素
         */
        public boolean delete(int key) {
            int index = search(key);
            if (index != -1) {
                occupied[index] = false;
                return true;
            }
            return false;
        }
    }
    
    /**
     * 链地址法哈希表
     */
    public static class ChainedHashTable {
        private List<Integer>[] table;
        private int size;
        
        @SuppressWarnings("unchecked")
        public ChainedHashTable(int size) {
            this.size = size;
            this.table = new List[size];
            for (int i = 0; i < size; i++) {
                table[i] = new ArrayList<>();
            }
        }
        
        /**
         * 哈希函数
         */
        private int hash(int key) {
            return key % size;
        }
        
        /**
         * 插入元素
         */
        public void insert(int key) {
            int index = hash(key);
            table[index].add(key);
        }
        
        /**
         * 查找元素
         */
        public boolean search(int key) {
            int index = hash(key);
            return table[index].contains(key);
        }
        
        /**
         * 删除元素
         */
        public boolean delete(int key) {
            int index = hash(key);
            return table[index].remove(Integer.valueOf(key));
        }
    }
}
```

## 二叉搜索树查找

```java
/**
 * 二叉搜索树查找
 */
public class BSTSearch {
    
    /**
     * 二叉搜索树节点
     */
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        
        public TreeNode(int val) {
            this.val = val;
        }
    }
    
    /**
     * 二叉搜索树查找
     */
    public static TreeNode search(TreeNode root, int target) {
        if (root == null || root.val == target) {
            return root;
        }
        
        if (target < root.val) {
            return search(root.left, target);
        } else {
            return search(root.right, target);
        }
    }
    
    /**
     * 二叉搜索树查找（迭代）
     */
    public static TreeNode searchIterative(TreeNode root, int target) {
        TreeNode current = root;
        
        while (current != null && current.val != target) {
            if (target < current.val) {
                current = current.left;
            } else {
                current = current.right;
            }
        }
        
        return current;
    }
    
    /**
     * 插入节点
     */
    public static TreeNode insert(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }
        
        if (val < root.val) {
            root.left = insert(root.left, val);
        } else if (val > root.val) {
            root.right = insert(root.right, val);
        }
        
        return root;
    }
    
    /**
     * 删除节点
     */
    public static TreeNode delete(TreeNode root, int val) {
        if (root == null) {
            return null;
        }
        
        if (val < root.val) {
            root.left = delete(root.left, val);
        } else if (val > root.val) {
            root.right = delete(root.right, val);
        } else {
            if (root.left == null) {
                return root.right;
            } else if (root.right == null) {
                return root.left;
            } else {
                TreeNode minNode = findMin(root.right);
                root.val = minNode.val;
                root.right = delete(root.right, minNode.val);
            }
        }
        
        return root;
    }
    
    /**
     * 找到最小节点
     */
    private static TreeNode findMin(TreeNode root) {
        while (root.left != null) {
            root = root.left;
        }
        return root;
    }
}
```

## 查找算法性能测试

```java
/**
 * 查找算法性能测试
 */
public class SearchPerformanceTest {
    
    /**
     * 测试查找算法性能
     */
    public static void testSearchPerformance() {
        int[] sizes = {1000, 10000, 100000, 1000000};
        
        for (int size : sizes) {
            System.out.println("=== 测试规模: " + size + " ===");
            
            // 生成测试数据
            int[] arr = generateRandomArray(size);
            int target = arr[size / 2]; // 选择中间元素作为目标
            
            // 测试顺序查找
            long startTime = System.nanoTime();
            SequentialSearch.sequentialSearch(arr, target);
            long endTime = System.nanoTime();
            System.out.println("顺序查找时间: " + (endTime - startTime) + " ns");
            
            // 排序数组用于二分查找
            Arrays.sort(arr);
            
            // 测试二分查找
            startTime = System.nanoTime();
            BinarySearch.binarySearchIterative(arr, target);
            endTime = System.nanoTime();
            System.out.println("二分查找时间: " + (endTime - startTime) + " ns");
            
            // 测试插值查找
            startTime = System.nanoTime();
            InterpolationSearch.interpolationSearch(arr, target);
            endTime = System.nanoTime();
            System.out.println("插值查找时间: " + (endTime - startTime) + " ns");
            
            // 测试斐波那契查找
            startTime = System.nanoTime();
            FibonacciSearch.fibonacciSearch(arr, target);
            endTime = System.nanoTime();
            System.out.println("斐波那契查找时间: " + (endTime - startTime) + " ns");
            
            System.out.println();
        }
    }
    
    /**
     * 生成随机数组
     */
    private static int[] generateRandomArray(int size) {
        int[] arr = new int[size];
        Random random = new Random();
        for (int i = 0; i < size; i++) {
            arr[i] = random.nextInt(size * 10);
        }
        return arr;
    }
    
    /**
     * 测试哈希查找性能
     */
    public static void testHashSearchPerformance() {
        int size = 100000;
        int[] arr = generateRandomArray(size);
        
        // 测试简单哈希表
        HashSearch.SimpleHashTable hashTable = new HashSearch.SimpleHashTable(size);
        for (int num : arr) {
            hashTable.insert(num);
        }
        
        int target = arr[size / 2];
        
        long startTime = System.nanoTime();
        hashTable.search(target);
        long endTime = System.nanoTime();
        System.out.println("哈希查找时间: " + (endTime - startTime) + " ns");
    }
}
```

## 测试代码

```java
/**
 * 查找算法测试类
 */
public class SearchAlgorithmTest {
    public static void main(String[] args) {
        System.out.println("=== 查找算法测试 ===");
        testBasicSearch();
        
        System.out.println("\n=== 二分查找变种测试 ===");
        testBinarySearchVariants();
        
        System.out.println("\n=== 哈希查找测试 ===");
        testHashSearch();
        
        System.out.println("\n=== 二叉搜索树测试 ===");
        testBSTSearch();
        
        System.out.println("\n=== 性能测试 ===");
        SearchPerformanceTest.testSearchPerformance();
        SearchPerformanceTest.testHashSearchPerformance();
    }
    
    /**
     * 测试基本查找算法
     */
    public static void testBasicSearch() {
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
        int target = 11;
        
        System.out.println("测试数组: " + Arrays.toString(arr));
        System.out.println("查找目标: " + target);
        
        System.out.println("顺序查找结果: " + SequentialSearch.sequentialSearch(arr, target));
        System.out.println("哨兵查找结果: " + SequentialSearch.sequentialSearchWithSentinel(arr, target));
        System.out.println("二分查找结果: " + BinarySearch.binarySearchIterative(arr, target));
        System.out.println("插值查找结果: " + InterpolationSearch.interpolationSearch(arr, target));
        System.out.println("斐波那契查找结果: " + FibonacciSearch.fibonacciSearch(arr, target));
    }
    
    /**
     * 测试二分查找变种
     */
    public static void testBinarySearchVariants() {
        int[] arr = {1, 2, 2, 2, 3, 4, 5, 6, 7, 8};
        int target = 2;
        
        System.out.println("测试数组: " + Arrays.toString(arr));
        System.out.println("查找目标: " + target);
        
        System.out.println("第一个等于目标的位置: " + BinarySearch.findFirstEqual(arr, target));
        System.out.println("最后一个等于目标的位置: " + BinarySearch.findLastEqual(arr, target));
        System.out.println("第一个大于等于目标的位置: " + BinarySearch.findFirstGreaterOrEqual(arr, target));
        System.out.println("最后一个小于等于目标的位置: " + BinarySearch.findLastLessOrEqual(arr, target));
        System.out.println("插入位置: " + BinarySearch.findInsertPosition(arr, target));
    }
    
    /**
     * 测试哈希查找
     */
    public static void testHashSearch() {
        HashSearch.SimpleHashTable hashTable = new HashSearch.SimpleHashTable(10);
        
        int[] keys = {1, 11, 21, 31, 41, 51, 61, 71, 81, 91};
        for (int key : keys) {
            hashTable.insert(key);
        }
        
        System.out.println("查找结果: " + hashTable.search(21));
        System.out.println("删除结果: " + hashTable.delete(21));
        System.out.println("删除后查找结果: " + hashTable.search(21));
        
        // 测试链地址法
        HashSearch.ChainedHashTable chainedTable = new HashSearch.ChainedHashTable(10);
        for (int key : keys) {
            chainedTable.insert(key);
        }
        
        System.out.println("链地址法查找结果: " + chainedTable.search(21));
        System.out.println("链地址法删除结果: " + chainedTable.delete(21));
        System.out.println("链地址法删除后查找结果: " + chainedTable.search(21));
    }
    
    /**
     * 测试二叉搜索树
     */
    public static void testBSTSearch() {
        BSTSearch.TreeNode root = null;
        int[] values = {5, 3, 8, 2, 4, 7, 9, 1, 6};
        
        for (int val : values) {
            root = BSTSearch.insert(root, val);
        }
        
        System.out.println("查找结果: " + (BSTSearch.search(root, 4) != null));
        System.out.println("查找结果: " + (BSTSearch.search(root, 10) != null));
        
        root = BSTSearch.delete(root, 4);
        System.out.println("删除后查找结果: " + (BSTSearch.search(root, 4) != null));
    }
}
```
