# 14.4.3. 二分查找

## 一、二分查找的基本概念

### 1. 定义
二分查找（Binary Search）是一种在有序数组中查找特定元素的搜索算法。它通过反复将搜索区间对半分割，将目标值与中间元素比较，从而快速缩小搜索范围。

### 2. 基本思想
- 在有序数组中选择中间元素作为比较对象
- 如果目标值等于中间元素，查找成功
- 如果目标值小于中间元素，在左半部分继续查找
- 如果目标值大于中间元素，在右半部分继续查找
- 重复上述过程直到找到目标或确定不存在

### 3. 适用条件
- **数据有序**：数组必须是排序的
- **随机访问**：支持随机访问的数据结构（如数组）
- **静态数据**：适合查找频繁、修改较少的场景

## 二、算法复杂度分析

### 1. 时间复杂度
- **最好情况**：O(1) - 目标元素就是中间元素
- **最坏情况**：O(log n) - 需要查找到最后一层
- **平均情况**：O(log n)

### 2. 空间复杂度
- **迭代版本**：O(1)
- **递归版本**：O(log n) - 递归调用栈空间

### 3. 性能优势
相比线性查找O(n)，二分查找的O(log n)复杂度在大数据集上有显著优势。

## 三、基本实现

### 1. 迭代实现
```
function binarySearch(arr, target):
    left = 0
    right = arr.length - 1
    
    while left <= right:
        mid = left + (right - left) / 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1  // 未找到
```

### 2. 递归实现
```
function binarySearchRecursive(arr, target, left, right):
    if left > right:
        return -1
    
    mid = left + (right - left) / 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binarySearchRecursive(arr, target, mid + 1, right)
    else:
        return binarySearchRecursive(arr, target, left, mid - 1)
```

## 四、边界处理技巧

### 1. 防止整数溢出
使用 `mid = left + (right - left) / 2` 而不是 `mid = (left + right) / 2`

### 2. 循环不变量
明确循环条件和边界更新规则：
- `left <= right` vs `left < right`
- `right = mid - 1` vs `right = mid`

### 3. 返回值处理
- 找到目标：返回索引
- 未找到：返回-1或插入位置

## 五、二分查找的变种

### 1. 查找第一个等于目标值的位置
```
function findFirst(arr, target):
    left = 0, right = arr.length - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) / 2
        
        if arr[mid] == target:
            result = mid
            right = mid - 1  // 继续向左查找
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result
```

### 2. 查找最后一个等于目标值的位置
```
function findLast(arr, target):
    left = 0, right = arr.length - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) / 2
        
        if arr[mid] == target:
            result = mid
            left = mid + 1  // 继续向右查找
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result
```

### 3. 查找第一个大于等于目标值的位置
```
function findFirstGE(arr, target):
    left = 0, right = arr.length - 1
    result = arr.length
    
    while left <= right:
        mid = left + (right - left) / 2
        
        if arr[mid] >= target:
            result = mid
            right = mid - 1
        else:
            left = mid + 1
    
    return result
```

### 4. 查找最后一个小于等于目标值的位置
```
function findLastLE(arr, target):
    left = 0, right = arr.length - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) / 2
        
        if arr[mid] <= target:
            result = mid
            left = mid + 1
        else:
            right = mid - 1
    
    return result
```

## 六、二分查找的应用场景

### 1. 数组查找
- 在有序数组中查找特定元素
- 查找插入位置
- 统计元素出现次数

### 2. 范围查询
- 查找区间内的元素
- 统计小于某值的元素个数
- 查找最接近目标值的元素

### 3. 答案二分
- 在答案空间中二分查找最优解
- 最小化最大值问题
- 最大化最小值问题

### 4. 浮点数二分
- 求解方程的根
- 优化问题的数值解
- 物理问题的近似解

## 七、二分答案

### 1. 基本思想
当直接求解困难时，可以二分答案的取值范围，对每个可能的答案进行验证。

### 2. 适用条件
- 答案具有单调性
- 可以快速验证某个答案是否可行
- 答案空间有明确的上下界

### 3. 经典问题
- 分割数组的最大值
- 在D天内送达包裹的能力
- 制作m束花所需的最少天数

## 八、常见错误和注意事项

### 1. 常见错误
- **整数溢出**：计算中点时可能溢出
- **死循环**：边界更新错误导致无限循环
- **边界处理**：off-by-one错误
- **有序性假设**：在无序数组上使用二分查找

### 2. 注意事项
- 确保数据有序
- 正确处理边界条件
- 选择合适的循环条件
- 防止整数溢出
- 考虑重复元素的情况

## 九、与其他查找算法的比较

### 1. 二分查找 vs 线性查找
| 特征 | 二分查找 | 线性查找 |
|------|----------|----------|
| 时间复杂度 | O(log n) | O(n) |
| 空间复杂度 | O(1) | O(1) |
| 数据要求 | 有序 | 无要求 |
| 适用场景 | 查找频繁 | 数据规模小 |

### 2. 二分查找 vs 哈希表
| 特征 | 二分查找 | 哈希表 |
|------|----------|--------|
| 查找时间 | O(log n) | O(1)平均 |
| 空间需求 | 原地 | 额外空间 |
| 有序性 | 保持 | 不保持 |
| 范围查询 | 支持 | 不支持 |

## 十、优化技巧

### 1. 插值查找
在均匀分布的有序数组中，可以用插值代替二分：
```
mid = left + (target - arr[left]) / (arr[right] - arr[left]) * (right - left)
```

### 2. 指数查找
当不知道数组大小时，先用指数增长找到范围，再二分查找。

### 3. 三分查找
对于单峰函数，可以使用三分查找找到峰值。

## 十一、实际应用

### 1. 数据库索引
- B树和B+树中的查找
- 索引范围扫描
- 排序合并连接

### 2. 系统设计
- 负载均衡中的服务器选择
- 缓存系统中的数据定位
- 分布式系统中的数据分片

### 3. 算法竞赛
- 答案二分类题目
- 区间查询问题
- 最优化问题

## 十二、高级应用

### 1. 在旋转数组中查找
对于旋转排序数组，可以通过判断哪一半是有序的来进行二分查找。

### 2. 在二维矩阵中查找
对于行列都有序的矩阵，可以从右上角或左下角开始搜索。

### 3. 在无限长数组中查找
先通过指数搜索确定范围，再进行二分查找。

## 十三、总结

二分查找是一种高效的查找算法，具有以下特点：

### 1. 优点
- 时间复杂度低：O(log n)
- 空间复杂度低：O(1)
- 实现相对简单
- 应用场景广泛

### 2. 局限性
- 要求数据有序
- 只适用于静态数据
- 不适合频繁插入删除的场景

### 3. 学习要点
- 掌握基本实现和各种变种
- 理解边界处理的重要性
- 学会应用到实际问题中
- 熟练掌握二分答案的思想

### 4. 实践建议
- 多练习不同类型的二分查找问题
- 注意边界条件的处理
- 理解二分查找的本质是缩小搜索空间
- 学会将问题转化为二分查找问题

二分查找虽然思想简单，但实现细节较多，需要大量练习才能熟练掌握。它是算法设计中的重要工具，在很多高级算法中都有应用。掌握二分查找不仅能提高解题效率，还能培养分治思想和边界处理能力。