# 14.4.3. 二分查找 - Java代码示例

## 一、基本二分查找

```java
/**
 * 基本二分查找实现
 */
public class BinarySearch {
    
    /**
     * 迭代版本的二分查找
     * @param arr 有序数组
     * @param target 目标值
     * @return 目标值的索引，未找到返回-1
     */
    public static int binarySearchIterative(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            // 防止整数溢出
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1; // 未找到
    }
    
    /**
     * 递归版本的二分查找
     */
    public static int binarySearchRecursive(int[] arr, int target) {
        return binarySearchRecursiveHelper(arr, target, 0, arr.length - 1);
    }
    
    private static int binarySearchRecursiveHelper(int[] arr, int target, int left, int right) {
        if (left > right) {
            return -1;
        }
        
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            return binarySearchRecursiveHelper(arr, target, mid + 1, right);
        } else {
            return binarySearchRecursiveHelper(arr, target, left, mid - 1);
        }
    }
    
    /**
     * 测试基本二分查找
     */
    public static void testBasicBinarySearch() {
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
        int target = 7;
        
        System.out.println("数组: " + java.util.Arrays.toString(arr));
        System.out.println("查找目标: " + target);
        
        int result1 = binarySearchIterative(arr, target);
        int result2 = binarySearchRecursive(arr, target);
        
        System.out.println("迭代版本结果: " + result1);
        System.out.println("递归版本结果: " + result2);
    }
}
```

## 二、二分查找变种

```java
/**
 * 二分查找的各种变种实现
 */
public class BinarySearchVariants {
    
    /**
     * 查找第一个等于目标值的位置
     */
    public static int findFirst(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                result = mid;
                right = mid - 1; // 继续向左查找
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    /**
     * 查找最后一个等于目标值的位置
     */
    public static int findLast(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                result = mid;
                left = mid + 1; // 继续向右查找
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    /**
     * 查找第一个大于等于目标值的位置
     */
    public static int findFirstGreaterEqual(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        int result = arr.length; // 如果所有元素都小于target，返回数组长度
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] >= target) {
                result = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        return result;
    }
    
    /**
     * 查找最后一个小于等于目标值的位置
     */
    public static int findLastLessEqual(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        int result = -1; // 如果所有元素都大于target，返回-1
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] <= target) {
                result = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    /**
     * 统计目标值在数组中的出现次数
     */
    public static int countOccurrences(int[] arr, int target) {
        int first = findFirst(arr, target);
        if (first == -1) {
            return 0;
        }
        
        int last = findLast(arr, target);
        return last - first + 1;
    }
    
    /**
     * 查找插入位置（保持数组有序）
     */
    public static int findInsertPosition(int[] arr, int target) {
        return findFirstGreaterEqual(arr, target);
    }
    
    /**
     * 测试二分查找变种
     */
    public static void testBinarySearchVariants() {
        int[] arr = {1, 2, 2, 2, 3, 4, 4, 5, 6, 7};
        int target = 2;
        
        System.out.println("数组: " + java.util.Arrays.toString(arr));
        System.out.println("目标值: " + target);
        
        System.out.println("第一个等于目标值的位置: " + findFirst(arr, target));
        System.out.println("最后一个等于目标值的位置: " + findLast(arr, target));
        System.out.println("第一个大于等于目标值的位置: " + findFirstGreaterEqual(arr, target));
        System.out.println("最后一个小于等于目标值的位置: " + findLastLessEqual(arr, target));
        System.out.println("目标值出现次数: " + countOccurrences(arr, target));
        System.out.println("插入位置: " + findInsertPosition(arr, target));
    }
}
```

## 三、二分答案应用

```java
/**
 * 二分答案的应用示例
 */
public class BinaryAnswerSearch {
    
    /**
     * 问题：在D天内送达包裹的能力
     * 给定包裹重量数组和天数D，求最小的运载能力
     */
    public static int shipWithinDays(int[] weights, int days) {
        // 确定搜索范围
        int left = 0; // 最小能力：最重的包裹
        int right = 0; // 最大能力：所有包裹重量之和
        
        for (int weight : weights) {
            left = Math.max(left, weight);
            right += weight;
        }
        
        // 二分查找最小运载能力
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (canShipInDays(weights, days, mid)) {
                right = mid; // 可以运载，尝试更小的能力
            } else {
                left = mid + 1; // 不能运载，需要更大的能力
            }
        }
        
        return left;
    }
    
    /**
     * 检查给定运载能力是否能在指定天数内完成
     */
    private static boolean canShipInDays(int[] weights, int days, int capacity) {
        int currentLoad = 0;
        int daysNeeded = 1;
        
        for (int weight : weights) {
            if (currentLoad + weight > capacity) {
                daysNeeded++;
                currentLoad = weight;
            } else {
                currentLoad += weight;
            }
        }
        
        return daysNeeded <= days;
    }
    
    /**
     * 问题：分割数组的最大值
     * 将数组分成m个子数组，使得各子数组和的最大值最小
     */
    public static int splitArray(int[] nums, int m) {
        int left = 0; // 最小可能值：数组中的最大元素
        int right = 0; // 最大可能值：所有元素之和
        
        for (int num : nums) {
            left = Math.max(left, num);
            right += num;
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (canSplit(nums, m, mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        
        return left;
    }
    
    /**
     * 检查是否能将数组分成m个子数组，且每个子数组和不超过maxSum
     */
    private static boolean canSplit(int[] nums, int m, int maxSum) {
        int subarrays = 1;
        int currentSum = 0;
        
        for (int num : nums) {
            if (currentSum + num > maxSum) {
                subarrays++;
                currentSum = num;
            } else {
                currentSum += num;
            }
        }
        
        return subarrays <= m;
    }
    
    /**
     * 测试二分答案
     */
    public static void testBinaryAnswerSearch() {
        System.out.println("二分答案应用测试:");
        System.out.println("================");
        
        // 测试包裹运载问题
        int[] weights = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int days = 5;
        int capacity = shipWithinDays(weights, days);
        System.out.println("包裹重量: " + java.util.Arrays.toString(weights));
        System.out.println("天数: " + days);
        System.out.println("最小运载能力: " + capacity);
        
        // 测试分割数组问题
        int[] nums = {7, 2, 5, 10, 8};
        int m = 2;
        int result = splitArray(nums, m);
        System.out.println("\n数组: " + java.util.Arrays.toString(nums));
        System.out.println("分割数: " + m);
        System.out.println("各子数组和的最大值的最小值: " + result);
    }
}
```

## 四、浮点数二分查找

```java
/**
 * 浮点数二分查找
 */
public class FloatingPointBinarySearch {
    
    private static final double EPSILON = 1e-9; // 精度
    
    /**
     * 求解方程 x^3 = target 的根
     */
    public static double cubeRoot(double target) {
        double left = target < 0 ? target : 0;
        double right = target < 0 ? 0 : target;
        
        // 特殊情况处理
        if (Math.abs(target) < 1) {
            left = target < 0 ? -1 : 0;
            right = target < 0 ? 0 : 1;
        }
        
        while (right - left > EPSILON) {
            double mid = left + (right - left) / 2;
            double cube = mid * mid * mid;
            
            if (cube < target) {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        return left + (right - left) / 2;
    }
    
    /**
     * 求解方程 sqrt(x) = target 的根
     */
    public static double squareRoot(double target) {
        if (target < 0) {
            throw new IllegalArgumentException("负数没有实数平方根");
        }
        
        if (target == 0 || target == 1) {
            return target;
        }
        
        double left = 0;
        double right = target > 1 ? target : 1;
        
        while (right - left > EPSILON) {
            double mid = left + (right - left) / 2;
            double square = mid * mid;
            
            if (square < target) {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        return left + (right - left) / 2;
    }
    
    /**
     * 测试浮点数二分查找
     */
    public static void testFloatingPointBinarySearch() {
        System.out.println("浮点数二分查找测试:");
        System.out.println("==================");
        
        double target1 = 27;
        double cubeRoot = cubeRoot(target1);
        System.out.printf("%.0f 的立方根: %.6f (验证: %.6f)\n", 
                         target1, cubeRoot, cubeRoot * cubeRoot * cubeRoot);
        
        double target2 = 16;
        double squareRoot = squareRoot(target2);
        System.out.printf("%.0f 的平方根: %.6f (验证: %.6f)\n", 
                         target2, squareRoot, squareRoot * squareRoot);
    }
}
```

## 五、在旋转数组中的应用

```java
/**
 * 在旋转排序数组中的二分查找
 */
public class RotatedArrayBinarySearch {
    
    /**
     * 在旋转排序数组中查找目标值
     */
    public static int searchInRotatedArray(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid;
            }
            
            // 判断左半部分是否有序
            if (nums[left] <= nums[mid]) {
                // 左半部分有序
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                // 右半部分有序
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        
        return -1;
    }
    
    /**
     * 查找旋转排序数组中的最小值
     */
    public static int findMinInRotatedArray(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] > nums[right]) {
                // 最小值在右半部分
                left = mid + 1;
            } else {
                // 最小值在左半部分（包括mid）
                right = mid;
            }
        }
        
        return nums[left];
    }
    
    /**
     * 测试旋转数组中的二分查找
     */
    public static void testRotatedArrayBinarySearch() {
        System.out.println("旋转数组二分查找测试:");
        System.out.println("==================");
        
        int[] rotatedArray = {4, 5, 6, 7, 0, 1, 2};
        int target = 0;
        
        System.out.println("旋转数组: " + java.util.Arrays.toString(rotatedArray));
        System.out.println("查找目标: " + target);
        
        int index = searchInRotatedArray(rotatedArray, target);
        System.out.println("目标位置: " + index);
        
        int min = findMinInRotatedArray(rotatedArray);
        System.out.println("最小值: " + min);
    }
}
```

## 六、综合测试类

```java
/**
 * 二分查找综合测试
 */
public class BinarySearchTest {
    
    public static void main(String[] args) {
        System.out.println("二分查找 - Java代码演示");
        System.out.println("======================");
        
        // 测试基本二分查找
        System.out.println("1. 基本二分查找:");
        System.out.println("------------------");
        BinarySearch.testBasicBinarySearch();
        
        // 测试二分查找变种
        System.out.println("\n2. 二分查找变种:");
        System.out.println("------------------");
        BinarySearchVariants.testBinarySearchVariants();
        
        // 测试二分答案
        System.out.println("\n3. 二分答案应用:");
        System.out.println("------------------");
        BinaryAnswerSearch.testBinaryAnswerSearch();
        
        // 测试浮点数二分查找
        System.out.println("\n4. 浮点数二分查找:");
        System.out.println("------------------");
        FloatingPointBinarySearch.testFloatingPointBinarySearch();
        
        // 测试旋转数组中的二分查找
        System.out.println("\n5. 旋转数组二分查找:");
        System.out.println("------------------");
        RotatedArrayBinarySearch.testRotatedArrayBinarySearch();
        
        // 性能测试
        performanceTest();
    }
    
    /**
     * 性能测试
     */
    public static void performanceTest() {
        System.out.println("\n6. 性能测试:");
        System.out.println("-------------");
        
        // 创建大数组
        int size = 1000000;
        int[] largeArray = new int[size];
        for (int i = 0; i < size; i++) {
            largeArray[i] = i * 2;
        }
        
        int target = 999998;
        
        // 测试二分查找
        long startTime = System.nanoTime();
        int result = BinarySearch.binarySearchIterative(largeArray, target);
        long endTime = System.nanoTime();
        
        System.out.printf("数组大小: %d\n", size);
        System.out.printf("查找目标: %d\n", target);
        System.out.printf("查找结果: %d\n", result);
        System.out.printf("二分查找耗时: %d ns\n", endTime - startTime);
        
        // 对比线性查找
        startTime = System.nanoTime();
        int linearResult = linearSearch(largeArray, target);
        endTime = System.nanoTime();
        
        System.out.printf("线性查找结果: %d\n", linearResult);
        System.out.printf("线性查找耗时: %d ns\n", endTime - startTime);
    }
    
    /**
     * 线性查找（用于性能对比）
     */
    private static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1;
    }
}
```

## 七、编译和运行

### 1. 编译命令
```bash
javac BinarySearch.java
javac BinarySearchVariants.java
javac BinaryAnswerSearch.java
javac FloatingPointBinarySearch.java
javac RotatedArrayBinarySearch.java
javac BinarySearchTest.java
```

### 2. 运行命令
```bash
java BinarySearchTest
```

## 八、学习要点

1. **理解原理**：掌握二分查找的基本思想和适用条件
2. **边界处理**：正确处理各种边界情况
3. **变种应用**：熟练掌握各种二分查找变种
4. **二分答案**：学会将问题转化为二分答案求解
5. **性能分析**：理解时间复杂度和空间复杂度
6. **实际应用**：能够应用到实际问题的解决中
