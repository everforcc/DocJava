# 14.4.2. 顺序查找 - Java代码示例

## 一、基本顺序查找

```java
/**
 * 基本顺序查找实现
 */
public class SequentialSearch {
    
    /**
     * 基本线性查找
     * @param arr 数组
     * @param target 目标值
     * @return 目标值的索引，未找到返回-1
     */
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1; // 未找到
    }
    
    /**
     * 带哨兵的线性查找
     */
    public static int linearSearchWithSentinel(int[] arr, int target) {
        if (arr.length == 0) return -1;
        
        // 保存最后一个元素
        int last = arr[arr.length - 1];
        
        // 设置哨兵
        arr[arr.length - 1] = target;
        
        int i = 0;
        while (arr[i] != target) {
            i++;
        }
        
        // 恢复最后一个元素
        arr[arr.length - 1] = last;
        
        // 判断是否真的找到了
        if (i < arr.length - 1 || last == target) {
            return i;
        }
        
        return -1;
    }
    
    /**
     * 查找所有匹配的位置
     */
    public static java.util.List<Integer> findAllOccurrences(int[] arr, int target) {
        java.util.List<Integer> positions = new java.util.ArrayList<>();
        
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                positions.add(i);
            }
        }
        
        return positions;
    }
    
    /**
     * 统计目标值出现次数
     */
    public static int countOccurrences(int[] arr, int target) {
        int count = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                count++;
            }
        }
        return count;
    }
    
    /**
     * 递归实现的线性查找
     */
    public static int linearSearchRecursive(int[] arr, int target, int index) {
        if (index >= arr.length) {
            return -1; // 未找到
        }
        
        if (arr[index] == target) {
            return index;
        }
        
        return linearSearchRecursive(arr, target, index + 1);
    }
    
    public static int linearSearchRecursive(int[] arr, int target) {
        return linearSearchRecursive(arr, target, 0);
    }
}
```

## 二、优化版本的顺序查找

```java
/**
 * 优化版本的顺序查找
 */
public class OptimizedSequentialSearch {
    
    /**
     * 双向查找 - 从两端同时查找
     */
    public static int bidirectionalSearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            if (arr[left] == target) {
                return left;
            }
            if (arr[right] == target) {
                return right;
            }
            left++;
            right--;
        }
        
        return -1;
    }
    
    /**
     * 跳跃查找 - 以固定步长跳跃查找
     */
    public static int jumpSearch(int[] arr, int target) {
        int n = arr.length;
        int step = (int) Math.sqrt(n); // 最优步长为√n
        int prev = 0;
        
        // 跳跃查找确定范围
        while (arr[Math.min(step, n) - 1] < target) {
            prev = step;
            step += (int) Math.sqrt(n);
            if (prev >= n) {
                return -1;
            }
        }
        
        // 在确定范围内线性查找
        while (arr[prev] < target) {
            prev++;
            if (prev == Math.min(step, n)) {
                return -1;
            }
        }
        
        if (arr[prev] == target) {
            return prev;
        }
        
        return -1;
    }
    
    /**
     * 自适应查找 - 根据查找历史调整元素位置
     */
    public static class AdaptiveSearch {
        private int[] arr;
        private int[] frequency; // 访问频率统计
        
        public AdaptiveSearch(int[] arr) {
            this.arr = arr.clone();
            this.frequency = new int[arr.length];
        }
        
        /**
         * 自适应查找（移动到前端策略）
         */
        public int searchMTF(int target) {
            for (int i = 0; i < arr.length; i++) {
                if (arr[i] == target) {
                    frequency[i]++;
                    
                    // 将找到的元素移动到前端
                    if (i > 0) {
                        int temp = arr[i];
                        System.arraycopy(arr, 0, arr, 1, i);
                        arr[0] = temp;
                        
                        // 调整频率数组
                        int tempFreq = frequency[i];
                        System.arraycopy(frequency, 0, frequency, 1, i);
                        frequency[0] = tempFreq;
                        
                        return 0; // 现在在位置0
                    }
                    return i;
                }
            }
            return -1;
        }
        
        /**
         * 自适应查找（转置策略）
         */
        public int searchTranspose(int target) {
            for (int i = 0; i < arr.length; i++) {
                if (arr[i] == target) {
                    frequency[i]++;
                    
                    // 与前一个元素交换
                    if (i > 0) {
                        // 交换元素
                        int temp = arr[i];
                        arr[i] = arr[i-1];
                        arr[i-1] = temp;
                        
                        // 交换频率
                        int tempFreq = frequency[i];
                        frequency[i] = frequency[i-1];
                        frequency[i-1] = tempFreq;
                        
                        return i - 1;
                    }
                    return i;
                }
            }
            return -1;
        }
        
        public int[] getArray() {
            return arr.clone();
        }
        
        public int[] getFrequency() {
            return frequency.clone();
        }
    }
    
    /**
     * 概率排序优化
     */
    public static class ProbabilityBasedSearch {
        private int[] arr;
        private double[] probabilities;
        
        public ProbabilityBasedSearch(int[] arr, double[] probabilities) {
            // 按概率降序排序
            Integer[] indices = new Integer[arr.length];
            for (int i = 0; i < arr.length; i++) {
                indices[i] = i;
            }
            
            java.util.Arrays.sort(indices, (a, b) -> 
                Double.compare(probabilities[b], probabilities[a]));
            
            this.arr = new int[arr.length];
            this.probabilities = new double[arr.length];
            
            for (int i = 0; i < arr.length; i++) {
                this.arr[i] = arr[indices[i]];
                this.probabilities[i] = probabilities[indices[i]];
            }
        }
        
        public int search(int target) {
            for (int i = 0; i < arr.length; i++) {
                if (arr[i] == target) {
                    return i;
                }
            }
            return -1;
        }
        
        public double getExpectedComparisons() {
            double expected = 0.0;
            for (int i = 0; i < probabilities.length; i++) {
                expected += (i + 1) * probabilities[i];
            }
            return expected;
        }
    }
}
```

## 三、链表中的顺序查找

```java
/**
 * 链表中的顺序查找实现
 */
public class LinkedListSequentialSearch {
    
    static class ListNode {
        int val;
        ListNode next;
        
        public ListNode(int val) {
            this.val = val;
        }
        
        @Override
        public String toString() {
            return String.valueOf(val);
        }
    }
    
    /**
     * 链表中的线性查找
     */
    public static ListNode searchInLinkedList(ListNode head, int target) {
        ListNode current = head;
        
        while (current != null) {
            if (current.val == target) {
                return current;
            }
            current = current.next;
        }
        
        return null; // 未找到
    }
    
    /**
     * 查找并返回位置索引
     */
    public static int searchIndexInLinkedList(ListNode head, int target) {
        ListNode current = head;
        int index = 0;
        
        while (current != null) {
            if (current.val == target) {
                return index;
            }
            current = current.next;
            index++;
        }
        
        return -1; // 未找到
    }
    
    /**
     * 自组织链表 - 移动到前端策略
     */
    public static class SelfOrganizingList {
        private ListNode head;
        
        public SelfOrganizingList() {
            this.head = null;
        }
        
        public void insert(int val) {
            ListNode newNode = new ListNode(val);
            newNode.next = head;
            head = newNode;
        }
        
        /**
         * 查找并移动到前端
         */
        public boolean searchMTF(int target) {
            if (head == null) return false;
            
            // 如果目标就是第一个节点
            if (head.val == target) {
                return true;
            }
            
            ListNode prev = head;
            ListNode current = head.next;
            
            while (current != null) {
                if (current.val == target) {
                    // 将找到的节点移动到前端
                    prev.next = current.next;
                    current.next = head;
                    head = current;
                    return true;
                }
                prev = current;
                current = current.next;
            }
            
            return false;
        }
        
        /**
         * 查找并转置
         */
        public boolean searchTranspose(int target) {
            if (head == null) return false;
            
            // 如果目标是第一个或第二个节点
            if (head.val == target) {
                return true;
            }
            if (head.next != null && head.next.val == target) {
                // 与第一个节点交换
                ListNode second = head.next;
                head.next = second.next;
                second.next = head;
                head = second;
                return true;
            }
            
            ListNode prev = head;
            ListNode current = head.next;
            
            while (current != null && current.next != null) {
                if (current.next.val == target) {
                    // 与前一个节点交换
                    ListNode target_node = current.next;
                    current.next = target_node.next;
                    target_node.next = current;
                    prev.next = target_node;
                    return true;
                }
                prev = current;
                current = current.next;
            }
            
            return false;
        }
        
        public void printList() {
            ListNode current = head;
            while (current != null) {
                System.out.print(current.val + " ");
                current = current.next;
            }
            System.out.println();
        }
    }
}
```

## 四、性能测试类

```java
/**
 * 顺序查找性能测试
 */
public class SequentialSearchPerformanceTest {
    
    public static void performanceTest() {
        int[] sizes = {1000, 5000, 10000, 50000};
        
        for (int size : sizes) {
            System.out.println("\n数组大小: " + size);
            System.out.println("==================");
            
            // 生成测试数据
            int[] arr = generateRandomArray(size);
            int target = arr[size / 2]; // 选择中间位置的元素作为目标
            
            // 测试基本线性查找
            long startTime = System.nanoTime();
            int result1 = SequentialSearch.linearSearch(arr, target);
            long time1 = System.nanoTime() - startTime;
            
            // 测试带哨兵的线性查找
            startTime = System.nanoTime();
            int result2 = SequentialSearch.linearSearchWithSentinel(arr.clone(), target);
            long time2 = System.nanoTime() - startTime;
            
            // 测试双向查找
            startTime = System.nanoTime();
            int result3 = OptimizedSequentialSearch.bidirectionalSearch(arr, target);
            long time3 = System.nanoTime() - startTime;
            
            System.out.printf("基本线性查找: %d ns, 结果: %d\n", time1, result1);
            System.out.printf("哨兵线性查找: %d ns, 结果: %d\n", time2, result2);
            System.out.printf("双向查找: %d ns, 结果: %d\n", time3, result3);
            
            // 对比二分查找（需要先排序）
            int[] sortedArr = arr.clone();
            java.util.Arrays.sort(sortedArr);
            
            startTime = System.nanoTime();
            int binaryResult = java.util.Arrays.binarySearch(sortedArr, target);
            long binaryTime = System.nanoTime() - startTime;
            
            System.out.printf("二分查找: %d ns, 结果: %d\n", binaryTime, binaryResult);
        }
    }
    
    /**
     * 自适应查找测试
     */
    public static void testAdaptiveSearch() {
        System.out.println("\n自适应查找测试:");
        System.out.println("================");
        
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        
        // 测试MTF策略
        OptimizedSequentialSearch.AdaptiveSearch mtfSearch = 
            new OptimizedSequentialSearch.AdaptiveSearch(arr);
        
        System.out.println("MTF策略测试:");
        System.out.println("初始数组: " + java.util.Arrays.toString(mtfSearch.getArray()));
        
        // 多次查找同一个元素
        for (int i = 0; i < 3; i++) {
            int pos = mtfSearch.searchMTF(7);
            System.out.println("第" + (i+1) + "次查找7，位置: " + pos + 
                             ", 数组: " + java.util.Arrays.toString(mtfSearch.getArray()));
        }
        
        // 测试转置策略
        OptimizedSequentialSearch.AdaptiveSearch transposeSearch = 
            new OptimizedSequentialSearch.AdaptiveSearch(arr);
        
        System.out.println("\n转置策略测试:");
        System.out.println("初始数组: " + java.util.Arrays.toString(transposeSearch.getArray()));
        
        for (int i = 0; i < 3; i++) {
            int pos = transposeSearch.searchTranspose(7);
            System.out.println("第" + (i+1) + "次查找7，位置: " + pos + 
                             ", 数组: " + java.util.Arrays.toString(transposeSearch.getArray()));
        }
    }
    
    /**
     * 概率查找测试
     */
    public static void testProbabilityBasedSearch() {
        System.out.println("\n概率查找测试:");
        System.out.println("================");
        
        int[] arr = {1, 2, 3, 4, 5};
        double[] probs = {0.1, 0.4, 0.3, 0.15, 0.05}; // 访问概率
        
        OptimizedSequentialSearch.ProbabilityBasedSearch probSearch = 
            new OptimizedSequentialSearch.ProbabilityBasedSearch(arr, probs);
        
        System.out.println("原始数组: " + java.util.Arrays.toString(arr));
        System.out.println("访问概率: " + java.util.Arrays.toString(probs));
        System.out.println("期望比较次数: " + probSearch.getExpectedComparisons());
    }
    
    private static int[] generateRandomArray(int size) {
        int[] arr = new int[size];
        java.util.Random random = new java.util.Random();
        
        for (int i = 0; i < size; i++) {
            arr[i] = random.nextInt(size * 10);
        }
        
        return arr;
    }
}
```

## 五、字符串顺序查找

```java
/**
 * 字符串中的顺序查找
 */
public class StringSequentialSearch {
    
    /**
     * 在字符串中查找子串（暴力匹配）
     */
    public static int bruteForceSearch(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        for (int i = 0; i <= n - m; i++) {
            int j;
            for (j = 0; j < m; j++) {
                if (text.charAt(i + j) != pattern.charAt(j)) {
                    break;
                }
            }
            if (j == m) {
                return i; // 找到匹配
            }
        }
        
        return -1; // 未找到
    }
    
    /**
     * 查找所有匹配位置
     */
    public static java.util.List<Integer> findAllMatches(String text, String pattern) {
        java.util.List<Integer> matches = new java.util.ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        for (int i = 0; i <= n - m; i++) {
            int j;
            for (j = 0; j < m; j++) {
                if (text.charAt(i + j) != pattern.charAt(j)) {
                    break;
                }
            }
            if (j == m) {
                matches.add(i);
            }
        }
        
        return matches;
    }
    
    /**
     * 忽略大小写的字符串查找
     */
    public static int caseInsensitiveSearch(String text, String pattern) {
        String lowerText = text.toLowerCase();
        String lowerPattern = pattern.toLowerCase();
        
        return bruteForceSearch(lowerText, lowerPattern);
    }
    
    /**
     * 模糊匹配查找（允许k个字符不同）
     */
    public static int fuzzySearch(String text, String pattern, int k) {
        int n = text.length();
        int m = pattern.length();
        
        for (int i = 0; i <= n - m; i++) {
            int mismatches = 0;
            for (int j = 0; j < m; j++) {
                if (text.charAt(i + j) != pattern.charAt(j)) {
                    mismatches++;
                    if (mismatches > k) {
                        break;
                    }
                }
            }
            if (mismatches <= k) {
                return i;
            }
        }
        
        return -1;
    }
}
```

## 六、综合测试类

```java
/**
 * 顺序查找综合测试
 */
public class SequentialSearchTest {
    
    public static void main(String[] args) {
        System.out.println("顺序查找 - Java代码演示");
        System.out.println("======================");
        
        // 基本功能测试
        testBasicFunctionality();
        
        // 优化算法测试
        testOptimizedAlgorithms();
        
        // 字符串查找测试
        testStringSearch();
        
        // 性能测试
        SequentialSearchPerformanceTest.performanceTest();
        
        // 自适应查找测试
        SequentialSearchPerformanceTest.testAdaptiveSearch();
        
        // 概率查找测试
        SequentialSearchPerformanceTest.testProbabilityBasedSearch();
    }
    
    public static void testBasicFunctionality() {
        System.out.println("1. 基本功能测试:");
        System.out.println("------------------");
        
        int[] arr = {64, 34, 25, 12, 22, 11, 90, 22, 11};
        int target = 22;
        
        System.out.println("数组: " + java.util.Arrays.toString(arr));
        System.out.println("查找目标: " + target);
        
        int index = SequentialSearch.linearSearch(arr, target);
        System.out.println("第一次出现位置: " + index);
        
        java.util.List<Integer> allPositions = SequentialSearch.findAllOccurrences(arr, target);
        System.out.println("所有出现位置: " + allPositions);
        
        int count = SequentialSearch.countOccurrences(arr, target);
        System.out.println("出现次数: " + count);
    }
    
    public static void testOptimizedAlgorithms() {
        System.out.println("\n2. 优化算法测试:");
        System.out.println("------------------");
        
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
        int target = 13;
        
        System.out.println("数组: " + java.util.Arrays.toString(arr));
        System.out.println("查找目标: " + target);
        
        int result1 = OptimizedSequentialSearch.bidirectionalSearch(arr, target);
        System.out.println("双向查找结果: " + result1);
        
        int result2 = OptimizedSequentialSearch.jumpSearch(arr, target);
        System.out.println("跳跃查找结果: " + result2);
    }
    
    public static void testStringSearch() {
        System.out.println("\n3. 字符串查找测试:");
        System.out.println("--------------------");
        
        String text = "Hello World, this is a test string for searching.";
        String pattern = "test";
        
        System.out.println("文本: " + text);
        System.out.println("模式: " + pattern);
        
        int position = StringSequentialSearch.bruteForceSearch(text, pattern);
        System.out.println("匹配位置: " + position);
        
        java.util.List<Integer> allMatches = StringSequentialSearch.findAllMatches(text, "is");
        System.out.println("'is'的所有匹配位置: " + allMatches);
        
        int fuzzyMatch = StringSequentialSearch.fuzzySearch(text, "tast", 1);
        System.out.println("模糊匹配'tast'(允许1个差异): " + fuzzyMatch);
    }
}
```

## 七、学习要点

1. **理解基本概念**：掌握顺序查找的基本思想和实现
2. **分析复杂度**：理解时间空间复杂度的计算方法
3. **掌握优化技巧**：哨兵、双向查找、自适应等优化方法
4. **实际应用**：了解在不同数据结构中的应用
5. **性能比较**：与其他查找算法的性能对比
6. **选择策略**：学会根据场景选择合适的查找算法
