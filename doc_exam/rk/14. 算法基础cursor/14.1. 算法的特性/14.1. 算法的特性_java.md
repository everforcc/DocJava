# 14.1. 算法的特性 - Java代码示例

## 算法特性示例

```java
/**
 * 算法特性演示类
 */
public class AlgorithmCharacteristics {
    
    /**
     * 有穷性示例：计算阶乘
     * 特性：算法在有限步骤内结束
     */
    public static long factorial(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("n不能为负数");
        }
        
        long result = 1;
        for (int i = 1; i <= n; i++) {  // 有限次循环
            result *= i;
        }
        return result;  // 有限步骤内结束
    }
    
    /**
     * 确定性示例：判断是否为质数
     * 特性：相同输入总是产生相同输出
     */
    public static boolean isPrime(int n) {
        if (n < 2) {
            return false;  // 明确的结果
        }
        
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) {
                return false;  // 明确的结果
            }
        }
        return true;  // 明确的结果
    }
    
    /**
     * 可行性示例：二分查找
     * 特性：每一步都是可执行的
     */
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;  // 可执行的操作
            
            if (arr[mid] == target) {
                return mid;  // 可执行的操作
            } else if (arr[mid] < target) {
                left = mid + 1;  // 可执行的操作
            } else {
                right = mid - 1;  // 可执行的操作
            }
        }
        
        return -1;  // 可执行的操作
    }
    
    /**
     * 输入输出示例：数组排序
     * 特性：有明确的输入和输出
     */
    public static void selectionSort(int[] arr) {  // 输入：未排序数组
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            
            // 找到最小元素的索引
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            
            // 交换元素
            if (minIndex != i) {
                swap(arr, i, minIndex);
            }
        }
        // 输出：排序后的数组（通过引用传递）
    }
    
    /**
     * 辅助方法：交换数组元素
     */
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 算法设计原则示例

```java
/**
 * 算法设计原则演示类
 */
public class AlgorithmDesignPrinciples {
    
    /**
     * 正确性示例：计算最大公约数（欧几里得算法）
     * 原则：算法必须正确解决问题
     */
    public static int gcd(int a, int b) {
        if (a < 0) a = -a;
        if (b < 0) b = -b;
        
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    
    /**
     * 效率性示例：快速幂算法
     * 原则：算法应该具有合理的时间复杂度
     */
    public static long fastPower(long base, long exponent, long mod) {
        long result = 1;
        base = base % mod;
        
        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % mod;
            }
            exponent = exponent >> 1;
            base = (base * base) % mod;
        }
        
        return result;
    }
    
    /**
     * 可读性示例：冒泡排序
     * 原则：算法应该易于理解和实现
     */
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        boolean swapped;
        
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            
            // 比较相邻元素
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换元素
                    swap(arr, j, j + 1);
                    swapped = true;
                }
            }
            
            // 如果没有交换，说明数组已经排序
            if (!swapped) {
                break;
            }
        }
    }
    
    /**
     * 健壮性示例：安全的数组访问
     * 原则：算法应该能够处理异常情况
     */
    public static int safeArrayAccess(int[] arr, int index) {
        if (arr == null) {
            throw new IllegalArgumentException("数组不能为null");
        }
        
        if (index < 0 || index >= arr.length) {
            throw new IndexOutOfBoundsException("索引越界: " + index);
        }
        
        return arr[index];
    }
    
    /**
     * 通用性示例：泛型查找算法
     * 原则：算法应该适用于一类问题
     */
    public static <T> int linearSearch(T[] arr, T target) {
        if (arr == null || target == null) {
            return -1;
        }
        
        for (int i = 0; i < arr.length; i++) {
            if (Objects.equals(arr[i], target)) {
                return i;
            }
        }
        
        return -1;
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 算法分类示例

```java
/**
 * 算法分类演示类
 */
public class AlgorithmClassification {
    
    /**
     * 数值算法示例：计算斐波那契数列
     */
    public static long fibonacci(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("n不能为负数");
        }
        
        if (n <= 1) {
            return n;
        }
        
        long a = 0, b = 1;
        for (int i = 2; i <= n; i++) {
            long temp = a + b;
            a = b;
            b = temp;
        }
        
        return b;
    }
    
    /**
     * 分治法示例：归并排序
     */
    public static void mergeSort(int[] arr) {
        if (arr.length <= 1) {
            return;
        }
        
        int mid = arr.length / 2;
        int[] left = Arrays.copyOfRange(arr, 0, mid);
        int[] right = Arrays.copyOfRange(arr, mid, arr.length);
        
        mergeSort(left);   // 递归排序左半部分
        mergeSort(right);  // 递归排序右半部分
        merge(arr, left, right);  // 合并两个有序数组
    }
    
    private static void merge(int[] arr, int[] left, int[] right) {
        int i = 0, j = 0, k = 0;
        
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                arr[k++] = left[i++];
            } else {
                arr[k++] = right[j++];
            }
        }
        
        while (i < left.length) {
            arr[k++] = left[i++];
        }
        
        while (j < right.length) {
            arr[k++] = right[j++];
        }
    }
    
    /**
     * 动态规划示例：计算最长公共子序列
     */
    public static int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }
    
    /**
     * 贪心法示例：活动选择问题
     */
    public static List<int[]> activitySelection(int[] start, int[] end) {
        int n = start.length;
        List<int[]> activities = new ArrayList<>();
        
        // 创建活动列表
        for (int i = 0; i < n; i++) {
            activities.add(new int[]{start[i], end[i], i});
        }
        
        // 按结束时间排序
        activities.sort((a, b) -> Integer.compare(a[1], b[1]));
        
        List<int[]> selected = new ArrayList<>();
        int lastEndTime = 0;
        
        for (int[] activity : activities) {
            if (activity[0] >= lastEndTime) {
                selected.add(activity);
                lastEndTime = activity[1];
            }
        }
        
        return selected;
    }
    
    /**
     * 回溯法示例：N皇后问题
     */
    public static List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        int[] queens = new int[n];
        Arrays.fill(queens, -1);
        
        backtrack(result, queens, 0, n);
        return result;
    }
    
    private static void backtrack(List<List<String>> result, int[] queens, int row, int n) {
        if (row == n) {
            result.add(generateBoard(queens, n));
            return;
        }
        
        for (int col = 0; col < n; col++) {
            if (isValid(queens, row, col)) {
                queens[row] = col;
                backtrack(result, queens, row + 1, n);
                queens[row] = -1;
            }
        }
    }
    
    private static boolean isValid(int[] queens, int row, int col) {
        for (int i = 0; i < row; i++) {
            if (queens[i] == col || Math.abs(queens[i] - col) == Math.abs(i - row)) {
                return false;
            }
        }
        return true;
    }
    
    private static List<String> generateBoard(int[] queens, int n) {
        List<String> board = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            char[] row = new char[n];
            Arrays.fill(row, '.');
            row[queens[i]] = 'Q';
            board.add(new String(row));
        }
        return board;
    }
}
```

## 算法复杂度分析示例

```java
/**
 * 算法复杂度分析演示类
 */
public class AlgorithmComplexity {
    
    /**
     * 常数时间 O(1)
     */
    public static int getFirstElement(int[] arr) {
        if (arr.length == 0) {
            throw new IllegalArgumentException("数组为空");
        }
        return arr[0];  // O(1)
    }
    
    /**
     * 对数时间 O(log n)
     */
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1;  // O(log n)
    }
    
    /**
     * 线性时间 O(n)
     */
    public static int findMax(int[] arr) {
        if (arr.length == 0) {
            throw new IllegalArgumentException("数组为空");
        }
        
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;  // O(n)
    }
    
    /**
     * 线性对数时间 O(n log n)
     */
    public static void heapSort(int[] arr) {
        int n = arr.length;
        
        // 构建最大堆 O(n)
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // 逐个提取元素 O(n log n)
        for (int i = n - 1; i > 0; i--) {
            swap(arr, 0, i);
            heapify(arr, i, 0);
        }
    }
    
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
    
    /**
     * 平方时间 O(n²)
     */
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                }
            }
        }  // O(n²)
    }
    
    /**
     * 指数时间 O(2^n)
     */
    public static int fibonacciRecursive(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);  // O(2^n)
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 测试代码

```java
/**
 * 算法特性测试类
 */
public class AlgorithmCharacteristicsTest {
    public static void main(String[] args) {
        System.out.println("=== 算法特性测试 ===");
        testAlgorithmCharacteristics();
        
        System.out.println("\n=== 算法设计原则测试 ===");
        testAlgorithmDesignPrinciples();
        
        System.out.println("\n=== 算法分类测试 ===");
        testAlgorithmClassification();
        
        System.out.println("\n=== 算法复杂度测试 ===");
        testAlgorithmComplexity();
    }
    
    /**
     * 测试算法特性
     */
    public static void testAlgorithmCharacteristics() {
        // 有穷性测试
        System.out.println("5的阶乘: " + AlgorithmCharacteristics.factorial(5));
        
        // 确定性测试
        System.out.println("17是质数: " + AlgorithmCharacteristics.isPrime(17));
        System.out.println("18是质数: " + AlgorithmCharacteristics.isPrime(18));
        
        // 可行性测试
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15};
        int index = AlgorithmCharacteristics.binarySearch(arr, 7);
        System.out.println("二分查找7的位置: " + index);
        
        // 输入输出测试
        int[] unsorted = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("排序前: " + Arrays.toString(unsorted));
        AlgorithmCharacteristics.selectionSort(unsorted);
        System.out.println("排序后: " + Arrays.toString(unsorted));
    }
    
    /**
     * 测试算法设计原则
     */
    public static void testAlgorithmDesignPrinciples() {
        // 正确性测试
        System.out.println("gcd(48, 18): " + AlgorithmDesignPrinciples.gcd(48, 18));
        
        // 效率性测试
        long result = AlgorithmDesignPrinciples.fastPower(2, 10, 1000);
        System.out.println("2^10 mod 1000: " + result);
        
        // 可读性测试
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        AlgorithmDesignPrinciples.bubbleSort(arr);
        System.out.println("冒泡排序结果: " + Arrays.toString(arr));
        
        // 健壮性测试
        try {
            int value = AlgorithmDesignPrinciples.safeArrayAccess(arr, 10);
            System.out.println("访问结果: " + value);
        } catch (IndexOutOfBoundsException e) {
            System.out.println("捕获异常: " + e.getMessage());
        }
        
        // 通用性测试
        String[] strArr = {"apple", "banana", "cherry", "date"};
        int strIndex = AlgorithmDesignPrinciples.linearSearch(strArr, "cherry");
        System.out.println("查找cherry的位置: " + strIndex);
    }
    
    /**
     * 测试算法分类
     */
    public static void testAlgorithmClassification() {
        // 数值算法测试
        System.out.println("斐波那契数列第10项: " + AlgorithmClassification.fibonacci(10));
        
        // 分治法测试
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        AlgorithmClassification.mergeSort(arr);
        System.out.println("归并排序结果: " + Arrays.toString(arr));
        
        // 动态规划测试
        String text1 = "abcde";
        String text2 = "ace";
        int lcs = AlgorithmClassification.longestCommonSubsequence(text1, text2);
        System.out.println("最长公共子序列长度: " + lcs);
        
        // 贪心法测试
        int[] start = {1, 3, 0, 5, 8, 5};
        int[] end = {2, 4, 6, 7, 9, 9};
        List<int[]> selected = AlgorithmClassification.activitySelection(start, end);
        System.out.println("选择的活动数量: " + selected.size());
        
        // 回溯法测试
        List<List<String>> solutions = AlgorithmClassification.solveNQueens(4);
        System.out.println("4皇后问题的解数量: " + solutions.size());
    }
    
    /**
     * 测试算法复杂度
     */
    public static void testAlgorithmComplexity() {
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15};
        
        // 常数时间测试
        int first = AlgorithmComplexity.getFirstElement(arr);
        System.out.println("第一个元素: " + first);
        
        // 对数时间测试
        int index = AlgorithmComplexity.binarySearch(arr, 7);
        System.out.println("二分查找7的位置: " + index);
        
        // 线性时间测试
        int max = AlgorithmComplexity.findMax(arr);
        System.out.println("最大值: " + max);
        
        // 线性对数时间测试
        int[] heapArr = {64, 34, 25, 12, 22, 11, 90};
        AlgorithmComplexity.heapSort(heapArr);
        System.out.println("堆排序结果: " + Arrays.toString(heapArr));
        
        // 平方时间测试
        int[] bubbleArr = {64, 34, 25, 12, 22, 11, 90};
        AlgorithmComplexity.bubbleSort(bubbleArr);
        System.out.println("冒泡排序结果: " + Arrays.toString(bubbleArr));
        
        // 指数时间测试（小数值）
        int fib = AlgorithmComplexity.fibonacciRecursive(10);
        System.out.println("递归斐波那契第10项: " + fib);
    }
}
```
