# 14.3.3. 分治法 - Java代码示例

## 分治法基础接口

```java
/**
 * 分治法基础接口
 */
public interface DivideAndConquer<T> {
    /**
     * 分解问题
     */
    List<T> divide(T problem);
    
    /**
     * 解决子问题
     */
    T conquer(T subProblem);
    
    /**
     * 合并结果
     */
    T combine(List<T> solutions);
    
    /**
     * 判断是否可以直接求解
     */
    boolean isBaseCase(T problem);
    
    /**
     * 分治法主方法
     */
    T solve(T problem);
}
```

## 归并排序实现

```java
/**
 * 归并排序 - 分治法实现
 */
public class MergeSort implements DivideAndConquer<int[]> {
    
    @Override
    public List<int[]> divide(int[] array) {
        if (array.length <= 1) {
            return Arrays.asList(array);
        }
        
        int mid = array.length / 2;
        int[] left = Arrays.copyOfRange(array, 0, mid);
        int[] right = Arrays.copyOfRange(array, mid, array.length);
        
        return Arrays.asList(left, right);
    }
    
    @Override
    public int[] conquer(int[] subArray) {
        if (subArray.length <= 1) {
            return subArray;
        }
        
        // 递归排序
        return solve(subArray);
    }
    
    @Override
    public int[] combine(List<int[]> solutions) {
        if (solutions.size() == 1) {
            return solutions.get(0);
        }
        
        int[] left = solutions.get(0);
        int[] right = solutions.get(1);
        
        return merge(left, right);
    }
    
    @Override
    public boolean isBaseCase(int[] array) {
        return array.length <= 1;
    }
    
    @Override
    public int[] solve(int[] array) {
        if (isBaseCase(array)) {
            return array;
        }
        
        List<int[]> subProblems = divide(array);
        List<int[]> solutions = new ArrayList<>();
        
        for (int[] subProblem : subProblems) {
            solutions.add(conquer(subProblem));
        }
        
        return combine(solutions);
    }
    
    /**
     * 合并两个已排序的数组
     */
    private int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0, j = 0, k = 0;
        
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                result[k++] = left[i++];
            } else {
                result[k++] = right[j++];
            }
        }
        
        while (i < left.length) {
            result[k++] = left[i++];
        }
        
        while (j < right.length) {
            result[k++] = right[j++];
        }
        
        return result;
    }
    
    /**
     * 原地归并排序（优化版本）
     */
    public void mergeSortInPlace(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }
        
        int[] temp = new int[array.length];
        mergeSortInPlace(array, temp, 0, array.length - 1);
    }
    
    private void mergeSortInPlace(int[] array, int[] temp, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            mergeSortInPlace(array, temp, left, mid);
            mergeSortInPlace(array, temp, mid + 1, right);
            
            mergeInPlace(array, temp, left, mid, right);
        }
    }
    
    private void mergeInPlace(int[] array, int[] temp, int left, int mid, int right) {
        // 复制到临时数组
        for (int i = left; i <= right; i++) {
            temp[i] = array[i];
        }
        
        int i = left, j = mid + 1, k = left;
        
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                array[k++] = temp[i++];
            } else {
                array[k++] = temp[j++];
            }
        }
        
        while (i <= mid) {
            array[k++] = temp[i++];
        }
        
        while (j <= right) {
            array[k++] = temp[j++];
        }
    }
}
```

## 快速排序实现

```java
/**
 * 快速排序 - 分治法实现
 */
public class QuickSort implements DivideAndConquer<int[]> {
    
    @Override
    public List<int[]> divide(int[] array) {
        if (array.length <= 1) {
            return Arrays.asList(array);
        }
        
        int pivotIndex = partition(array);
        int[] left = Arrays.copyOfRange(array, 0, pivotIndex);
        int[] right = Arrays.copyOfRange(array, pivotIndex + 1, array.length);
        
        return Arrays.asList(left, right);
    }
    
    @Override
    public int[] conquer(int[] subArray) {
        if (subArray.length <= 1) {
            return subArray;
        }
        
        return solve(subArray);
    }
    
    @Override
    public int[] combine(List<int[]> solutions) {
        if (solutions.size() == 1) {
            return solutions.get(0);
        }
        
        int[] left = solutions.get(0);
        int[] right = solutions.get(1);
        
        // 快速排序不需要合并，因为排序是原地进行的
        int[] result = new int[left.length + right.length + 1];
        System.arraycopy(left, 0, result, 0, left.length);
        System.arraycopy(right, 0, result, left.length, right.length);
        
        return result;
    }
    
    @Override
    public boolean isBaseCase(int[] array) {
        return array.length <= 1;
    }
    
    @Override
    public int[] solve(int[] array) {
        if (isBaseCase(array)) {
            return array;
        }
        
        List<int[]> subProblems = divide(array);
        List<int[]> solutions = new ArrayList<>();
        
        for (int[] subProblem : subProblems) {
            solutions.add(conquer(subProblem));
        }
        
        return combine(solutions);
    }
    
    /**
     * 分区操作
     */
    private int partition(int[] array) {
        int pivot = array[array.length - 1];
        int i = -1;
        
        for (int j = 0; j < array.length - 1; j++) {
            if (array[j] <= pivot) {
                i++;
                swap(array, i, j);
            }
        }
        
        swap(array, i + 1, array.length - 1);
        return i + 1;
    }
    
    /**
     * 交换数组元素
     */
    private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    
    /**
     * 原地快速排序（优化版本）
     */
    public void quickSortInPlace(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }
        
        quickSortInPlace(array, 0, array.length - 1);
    }
    
    private void quickSortInPlace(int[] array, int low, int high) {
        if (low < high) {
            int pivotIndex = partitionInPlace(array, low, high);
            
            quickSortInPlace(array, low, pivotIndex - 1);
            quickSortInPlace(array, pivotIndex + 1, high);
        }
    }
    
    private int partitionInPlace(int[] array, int low, int high) {
        int pivot = array[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (array[j] <= pivot) {
                i++;
                swap(array, i, j);
            }
        }
        
        swap(array, i + 1, high);
        return i + 1;
    }
    
    /**
     * 三路快速排序（处理重复元素）
     */
    public void quickSort3Way(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }
        
        quickSort3Way(array, 0, array.length - 1);
    }
    
    private void quickSort3Way(int[] array, int low, int high) {
        if (low >= high) {
            return;
        }
        
        int pivot = array[low];
        int lt = low, gt = high, i = low + 1;
        
        while (i <= gt) {
            if (array[i] < pivot) {
                swap(array, lt++, i++);
            } else if (array[i] > pivot) {
                swap(array, i, gt--);
            } else {
                i++;
            }
        }
        
        quickSort3Way(array, low, lt - 1);
        quickSort3Way(array, gt + 1, high);
    }
}
```

## 二分查找实现

```java
/**
 * 二分查找 - 分治法实现
 */
public class BinarySearch implements DivideAndConquer<SearchProblem> {
    
    @Override
    public List<SearchProblem> divide(SearchProblem problem) {
        int[] array = problem.array;
        int target = problem.target;
        int left = problem.left;
        int right = problem.right;
        
        if (left > right) {
            return Arrays.asList();
        }
        
        int mid = left + (right - left) / 2;
        
        if (array[mid] == target) {
            return Arrays.asList(new SearchProblem(array, target, mid, mid));
        } else if (array[mid] < target) {
            return Arrays.asList(new SearchProblem(array, target, mid + 1, right));
        } else {
            return Arrays.asList(new SearchProblem(array, target, left, mid - 1));
        }
    }
    
    @Override
    public SearchProblem conquer(SearchProblem subProblem) {
        if (subProblem.left > subProblem.right) {
            return new SearchProblem(subProblem.array, subProblem.target, -1, -1);
        }
        
        return solve(subProblem);
    }
    
    @Override
    public SearchProblem combine(List<SearchProblem> solutions) {
        if (solutions.isEmpty()) {
            return new SearchProblem(null, 0, -1, -1);
        }
        
        return solutions.get(0);
    }
    
    @Override
    public boolean isBaseCase(SearchProblem problem) {
        return problem.left > problem.right || 
               (problem.left == problem.right && 
                problem.array[problem.left] == problem.target);
    }
    
    @Override
    public SearchProblem solve(SearchProblem problem) {
        if (isBaseCase(problem)) {
            if (problem.left <= problem.right && 
                problem.array[problem.left] == problem.target) {
                return new SearchProblem(problem.array, problem.target, problem.left, problem.left);
            } else {
                return new SearchProblem(problem.array, problem.target, -1, -1);
            }
        }
        
        List<SearchProblem> subProblems = divide(problem);
        List<SearchProblem> solutions = new ArrayList<>();
        
        for (SearchProblem subProblem : subProblems) {
            solutions.add(conquer(subProblem));
        }
        
        return combine(solutions);
    }
    
    /**
     * 搜索问题类
     */
    public static class SearchProblem {
        public int[] array;
        public int target;
        public int left;
        public int right;
        
        public SearchProblem(int[] array, int target, int left, int right) {
            this.array = array;
            this.target = target;
            this.left = left;
            this.right = right;
        }
        
        public int getResult() {
            return left;
        }
    }
    
    /**
     * 标准二分查找实现
     */
    public int binarySearch(int[] array, int target) {
        int left = 0, right = array.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (array[mid] == target) {
                return mid;
            } else if (array[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1;
    }
    
    /**
     * 查找第一个等于目标值的位置
     */
    public int findFirst(int[] array, int target) {
        int left = 0, right = array.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (array[mid] == target) {
                result = mid;
                right = mid - 1;
            } else if (array[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    /**
     * 查找最后一个等于目标值的位置
     */
    public int findLast(int[] array, int target) {
        int left = 0, right = array.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (array[mid] == target) {
                result = mid;
                left = mid + 1;
            } else if (array[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    /**
     * 查找插入位置
     */
    public int findInsertPosition(int[] array, int target) {
        int left = 0, right = array.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (array[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return left;
    }
}
```

## 大整数乘法实现

```java
/**
 * 大整数乘法 - 分治法实现
 */
public class BigIntegerMultiplication implements DivideAndConquer<BigInteger> {
    
    @Override
    public List<BigInteger> divide(BigInteger number) {
        String numStr = number.toString();
        int len = numStr.length();
        
        if (len <= 1) {
            return Arrays.asList(number);
        }
        
        int mid = len / 2;
        String leftStr = numStr.substring(0, mid);
        String rightStr = numStr.substring(mid);
        
        BigInteger left = new BigInteger(leftStr);
        BigInteger right = new BigInteger(rightStr);
        
        return Arrays.asList(left, right);
    }
    
    @Override
    public BigInteger conquer(BigInteger subNumber) {
        if (subNumber.toString().length() <= 1) {
            return subNumber;
        }
        
        return solve(subNumber);
    }
    
    @Override
    public BigInteger combine(List<BigInteger> solutions) {
        if (solutions.size() == 1) {
            return solutions.get(0);
        }
        
        BigInteger left = solutions.get(0);
        BigInteger right = solutions.get(1);
        
        // 这里简化处理，实际应该实现Karatsuba算法
        return left.multiply(right);
    }
    
    @Override
    public boolean isBaseCase(BigInteger number) {
        return number.toString().length() <= 1;
    }
    
    @Override
    public BigInteger solve(BigInteger number) {
        if (isBaseCase(number)) {
            return number;
        }
        
        List<BigInteger> subProblems = divide(number);
        List<BigInteger> solutions = new ArrayList<>();
        
        for (BigInteger subProblem : subProblems) {
            solutions.add(conquer(subProblem));
        }
        
        return combine(solutions);
    }
    
    /**
     * Karatsuba算法实现
     */
    public BigInteger karatsubaMultiply(BigInteger x, BigInteger y) {
        int n = Math.max(x.bitLength(), y.bitLength());
        
        if (n <= 2000) {
            return x.multiply(y);
        }
        
        n = (n / 2) + (n % 2);
        
        BigInteger b = x.shiftRight(n);
        BigInteger a = x.subtract(b.shiftLeft(n));
        BigInteger d = y.shiftRight(n);
        BigInteger c = y.subtract(d.shiftLeft(n));
        
        BigInteger ac = karatsubaMultiply(a, c);
        BigInteger bd = karatsubaMultiply(b, d);
        BigInteger abcd = karatsubaMultiply(a.add(b), c.add(d));
        
        return ac.add(abcd.subtract(ac).subtract(bd).shiftLeft(n)).add(bd.shiftLeft(2 * n));
    }
}
```

## 分治法工具类

```java
/**
 * 分治法工具类
 */
public class DivideAndConquerUtils {
    
    /**
     * 分析分治法复杂度
     */
    public static void analyzeComplexity(int n, int a, int b, int c) {
        System.out.println("=== 分治法复杂度分析 ===");
        System.out.println("问题规模: " + n);
        System.out.println("子问题数量: " + a);
        System.out.println("子问题规模比例: " + b);
        System.out.println("分解合并复杂度: O(n^" + c + ")");
        
        double log_b_a = Math.log(a) / Math.log(b);
        
        if (c < log_b_a) {
            System.out.println("情况1: T(n) = Θ(n^" + String.format("%.2f", log_b_a) + ")");
        } else if (c == log_b_a) {
            System.out.println("情况2: T(n) = Θ(n^" + c + " log n)");
        } else {
            System.out.println("情况3: T(n) = Θ(n^" + c + ")");
        }
        
        System.out.println();
    }
    
    /**
     * 比较分治法与暴力法
     */
    public static void compareWithBruteForce(String algorithm, int[] sizes) {
        System.out.println("=== " + algorithm + " 性能比较 ===");
        
        for (int size : sizes) {
            int[] array = generateRandomArray(size);
            
            // 分治法
            long startTime = System.nanoTime();
            if (algorithm.equals("归并排序")) {
                MergeSort mergeSort = new MergeSort();
                mergeSort.mergeSortInPlace(array.clone());
            } else if (algorithm.equals("快速排序")) {
                QuickSort quickSort = new QuickSort();
                quickSort.quickSortInPlace(array.clone());
            }
            long divideConquerTime = System.nanoTime() - startTime;
            
            // 暴力法（选择排序）
            startTime = System.nanoTime();
            selectionSort(array.clone());
            long bruteForceTime = System.nanoTime() - startTime;
            
            System.out.println("规模 " + size + ":");
            System.out.println("  分治法: " + divideConquerTime + " ns");
            System.out.println("  暴力法: " + bruteForceTime + " ns");
            System.out.println("  加速比: " + String.format("%.2f", (double) bruteForceTime / divideConquerTime));
        }
        
        System.out.println();
    }
    
    /**
     * 生成随机数组
     */
    private static int[] generateRandomArray(int size) {
        int[] array = new int[size];
        Random random = new Random();
        
        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt(1000);
        }
        
        return array;
    }
    
    /**
     * 选择排序（暴力法）
     */
    private static void selectionSort(int[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < array.length; j++) {
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            
            if (minIndex != i) {
                int temp = array[i];
                array[i] = array[minIndex];
                array[minIndex] = temp;
            }
        }
    }
    
    /**
     * 测试分治法正确性
     */
    public static void testCorrectness() {
        System.out.println("=== 分治法正确性测试 ===");
        
        // 测试归并排序
        int[] array1 = {64, 34, 25, 12, 22, 11, 90};
        MergeSort mergeSort = new MergeSort();
        int[] sorted1 = mergeSort.solve(array1);
        System.out.println("归并排序: " + Arrays.toString(array1) + " -> " + Arrays.toString(sorted1));
        
        // 测试快速排序
        int[] array2 = {64, 34, 25, 12, 22, 11, 90};
        QuickSort quickSort = new QuickSort();
        int[] sorted2 = quickSort.solve(array2);
        System.out.println("快速排序: " + Arrays.toString(array2) + " -> " + Arrays.toString(sorted2));
        
        // 测试二分查找
        int[] sortedArray = {1, 3, 5, 7, 9, 11, 13, 15};
        BinarySearch binarySearch = new BinarySearch();
        int index = binarySearch.binarySearch(sortedArray, 7);
        System.out.println("二分查找: 在 " + Arrays.toString(sortedArray) + " 中查找 7，位置: " + index);
        
        System.out.println();
    }
}
```

## 测试代码

```java
/**
 * 分治法测试类
 */
public class DivideAndConquerTest {
    public static void main(String[] args) {
        System.out.println("=== 分治法基本功能测试 ===");
        testBasicFunctionality();
        
        System.out.println("\n=== 分治法性能测试 ===");
        testPerformance();
        
        System.out.println("\n=== 分治法复杂度分析 ===");
        testComplexityAnalysis();
        
        System.out.println("\n=== 分治法应用测试 ===");
        testApplications();
    }
    
    /**
     * 测试基本功能
     */
    public static void testBasicFunctionality() {
        // 测试归并排序
        int[] array1 = {64, 34, 25, 12, 22, 11, 90};
        MergeSort mergeSort = new MergeSort();
        int[] sorted1 = mergeSort.solve(array1);
        System.out.println("归并排序: " + Arrays.toString(array1) + " -> " + Arrays.toString(sorted1));
        
        // 测试快速排序
        int[] array2 = {64, 34, 25, 12, 22, 11, 90};
        QuickSort quickSort = new QuickSort();
        int[] sorted2 = quickSort.solve(array2);
        System.out.println("快速排序: " + Arrays.toString(array2) + " -> " + Arrays.toString(sorted2));
        
        // 测试二分查找
        int[] sortedArray = {1, 3, 5, 7, 9, 11, 13, 15};
        BinarySearch binarySearch = new BinarySearch();
        int index = binarySearch.binarySearch(sortedArray, 7);
        System.out.println("二分查找: 在 " + Arrays.toString(sortedArray) + " 中查找 7，位置: " + index);
        
        // 测试大整数乘法
        BigInteger x = new BigInteger("123456789");
        BigInteger y = new BigInteger("987654321");
        BigIntegerMultiplication bigIntMult = new BigIntegerMultiplication();
        BigInteger result = bigIntMult.karatsubaMultiply(x, y);
        System.out.println("大整数乘法: " + x + " × " + y + " = " + result);
        
        System.out.println();
    }
    
    /**
     * 测试性能
     */
    public static void testPerformance() {
        int[] sizes = {1000, 5000, 10000};
        
        for (int size : sizes) {
            System.out.println("规模: " + size);
            
            int[] array = generateRandomArray(size);
            
            // 测试归并排序性能
            long startTime = System.nanoTime();
            MergeSort mergeSort = new MergeSort();
            mergeSort.mergeSortInPlace(array.clone());
            long mergeSortTime = System.nanoTime() - startTime;
            
            // 测试快速排序性能
            startTime = System.nanoTime();
            QuickSort quickSort = new QuickSort();
            quickSort.quickSortInPlace(array.clone());
            long quickSortTime = System.nanoTime() - startTime;
            
            // 测试二分查找性能
            startTime = System.nanoTime();
            BinarySearch binarySearch = new BinarySearch();
            for (int i = 0; i < 1000; i++) {
                binarySearch.binarySearch(array, array[i % array.length]);
            }
            long binarySearchTime = System.nanoTime() - startTime;
            
            System.out.println("  归并排序: " + mergeSortTime + " ns");
            System.out.println("  快速排序: " + quickSortTime + " ns");
            System.out.println("  二分查找: " + binarySearchTime + " ns");
            System.out.println();
        }
    }
    
    /**
     * 测试复杂度分析
     */
    public static void testComplexityAnalysis() {
        // 分析归并排序复杂度
        DivideAndConquerUtils.analyzeComplexity(1000, 2, 2, 1); // T(n) = 2T(n/2) + O(n)
        
        // 分析快速排序复杂度
        DivideAndConquerUtils.analyzeComplexity(1000, 2, 2, 1); // T(n) = 2T(n/2) + O(n)
        
        // 分析二分查找复杂度
        DivideAndConquerUtils.analyzeComplexity(1000, 1, 2, 0); // T(n) = T(n/2) + O(1)
        
        // 分析大整数乘法复杂度
        DivideAndConquerUtils.analyzeComplexity(1000, 3, 2, 1); // T(n) = 3T(n/2) + O(n)
    }
    
    /**
     * 测试应用
     */
    public static void testApplications() {
        // 测试排序算法比较
        DivideAndConquerUtils.compareWithBruteForce("归并排序", new int[]{100, 500, 1000});
        DivideAndConquerUtils.compareWithBruteForce("快速排序", new int[]{100, 500, 1000});
        
        // 测试正确性
        DivideAndConquerUtils.testCorrectness();
        
        // 测试二分查找变种
        int[] array = {1, 2, 2, 2, 3, 4, 5};
        BinarySearch binarySearch = new BinarySearch();
        
        System.out.println("=== 二分查找变种测试 ===");
        System.out.println("数组: " + Arrays.toString(array));
        System.out.println("查找2的第一个位置: " + binarySearch.findFirst(array, 2));
        System.out.println("查找2的最后一个位置: " + binarySearch.findLast(array, 2));
        System.out.println("插入2的位置: " + binarySearch.findInsertPosition(array, 2));
        System.out.println();
    }
    
    /**
     * 生成随机数组
     */
    private static int[] generateRandomArray(int size) {
        int[] array = new int[size];
        Random random = new Random();
        
        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt(1000);
        }
        
        return array;
    }
}
```

