# 14.3.5. 动态规划法

## 一、动态规划的基本概念

### 1. 定义
动态规划（Dynamic Programming，DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。它将复杂问题分解成子问题求解，避免了重复计算，提高了算法效率。

### 2. 基本思想
- 将原问题分解为若干个子问题
- 先求解子问题，再由子问题的解构造原问题的解
- 保存已解决的子问题答案，避免重复计算
- 自底向上或自顶向下求解

### 3. 核心特征
- **最优子结构**：问题的最优解包含子问题的最优解
- **重叠子问题**：在求解过程中，同一个子问题会被多次求解
- **无后效性**：子问题的解一旦确定，就不再改变

## 二、动态规划的适用条件

### 1. 最优子结构性质
问题的最优解包含其子问题的最优解。如果问题具有最优子结构，那么我们可以通过组合子问题的最优解来构造原问题的最优解。

### 2. 重叠子问题性质
在用递归算法自顶向下求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。

### 3. 无后效性
即某阶段状态一旦确定，就不受这个状态以后决策的影响。

## 三、动态规划的设计步骤

### 1. 分析问题结构
- 确定问题是否具有最优子结构
- 识别重叠子问题
- 定义状态和状态转移

### 2. 建立状态转移方程
- 确定状态变量
- 建立递推关系
- 确定边界条件

### 3. 确定计算顺序
- 自底向上：从小规模问题开始
- 自顶向下：使用记忆化递归

### 4. 优化空间复杂度
- 分析状态依赖关系
- 使用滚动数组等技巧

## 四、经典动态规划问题

### 1. 斐波那契数列
**问题**：计算斐波那契数列第n项
**状态转移方程**：dp[i] = dp[i-1] + dp[i-2]
**时间复杂度**：O(n)
**空间复杂度**：O(1)

### 2. 最长公共子序列（LCS）
**问题**：找两个序列的最长公共子序列
**状态转移方程**：
- 如果 s1[i] == s2[j]：dp[i][j] = dp[i-1][j-1] + 1
- 否则：dp[i][j] = max(dp[i-1][j], dp[i][j-1])

### 3. 0-1背包问题
**问题**：在容量限制下选择物品使价值最大
**状态转移方程**：
- dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])

### 4. 最长递增子序列（LIS）
**问题**：找数组中最长的递增子序列
**状态转移方程**：dp[i] = max(dp[j] + 1) for all j < i where arr[j] < arr[i]

## 五、动态规划的实现方式

### 1. 自顶向下（记忆化递归）
```
function dp(state):
    if state in memo:
        return memo[state]
    
    if base_case(state):
        return base_value
    
    result = recurrence_relation(state)
    memo[state] = result
    return result
```

### 2. 自底向上（迭代）
```
// 初始化dp数组
dp[base_case] = base_value

// 按顺序填表
for each state in order:
    dp[state] = recurrence_relation(state)

return dp[target_state]
```

## 六、状态设计技巧

### 1. 一维状态
适用于序列类问题：
- dp[i] 表示以第i个元素结尾的某种性质

### 2. 二维状态
适用于双序列或背包类问题：
- dp[i][j] 表示考虑前i个元素，某种约束为j的情况

### 3. 多维状态
适用于复杂约束问题：
- dp[i][j][k] 表示多个维度的状态

### 4. 状态压缩
使用位运算压缩状态空间

## 七、空间优化技巧

### 1. 滚动数组
当前状态只依赖前一行状态时，可以用两行数组交替使用。

### 2. 一维数组优化
当状态转移只依赖前面有限个状态时，可以降维。

### 3. 状态压缩
使用位运算压缩状态表示。

## 八、动态规划 vs 其他算法

### 1. 动态规划 vs 分治法
| 特征 | 动态规划 | 分治法 |
|------|----------|--------|
| 子问题性质 | 重叠 | 独立 |
| 计算方式 | 保存结果 | 重复计算 |
| 适用场景 | 最优化问题 | 分解问题 |

### 2. 动态规划 vs 贪心法
| 特征 | 动态规划 | 贪心法 |
|------|----------|--------|
| 选择方式 | 全局考虑 | 局部最优 |
| 最优性 | 保证 | 不保证 |
| 复杂度 | 较高 | 较低 |

## 九、常见的DP问题类型

### 1. 线性DP
- 最长上升子序列
- 最大子数组和
- 编辑距离

### 2. 区间DP
- 矩阵链乘法
- 回文子串
- 括号匹配

### 3. 背包DP
- 0-1背包
- 完全背包
- 多重背包

### 4. 树形DP
- 树的直径
- 树上最大独立集
- 树的重心

### 5. 状态机DP
- 股票买卖
- 打家劫舍
- 状态转换

### 6. 数位DP
- 数字计数
- 数字游戏
- 约束条件下的计数

## 十、动态规划的优化技巧

### 1. 单调队列优化
用于优化具有单调性的状态转移，将O(n²)优化到O(n)。

### 2. 单调栈优化
适用于需要找到左边或右边第一个满足某条件元素的情况。

### 3. 矩阵快速幂
用于优化线性递推关系，将O(n)优化到O(log n)。

### 4. 四边形不等式优化
用于满足四边形不等式的区间DP问题。

## 十一、常见错误和注意事项

### 1. 常见错误
- **状态定义不清**：没有明确状态的含义
- **转移方程错误**：逻辑错误或边界处理不当
- **初始化错误**：基础情况设置错误
- **计算顺序错误**：依赖关系处理不当

### 2. 注意事项
- 仔细分析问题的最优子结构
- 正确识别重叠子问题
- 合理设计状态表示
- 注意边界条件的处理
- 考虑空间优化的可能性

## 十二、动态规划的应用领域

### 1. 算法竞赛
- ACM/ICPC竞赛中的经典题型
- 各种在线判题系统的DP题目

### 2. 实际工程
- 最优化问题求解
- 资源分配问题
- 路径规划问题

### 3. 机器学习
- 序列标注问题
- 结构化预测
- 强化学习中的价值函数

### 4. 生物信息学
- 序列比对
- 基因预测
- 蛋白质折叠

## 十三、高级动态规划技巧

### 1. 概率DP
处理概率相关的问题，状态表示概率值。

### 2. 期望DP
计算数学期望值的动态规划。

### 3. 博弈DP
处理两人博弈问题的动态规划。

### 4. 插头DP
处理网格图上路径问题的高级技巧。

## 十四、动态规划的设计模式

### 1. 最值型DP
求解最大值或最小值问题。

### 2. 计数型DP
统计满足条件的方案数。

### 3. 存在型DP
判断是否存在满足条件的方案。

### 4. 区间型DP
在区间上定义状态的动态规划。

## 十五、实战技巧

### 1. 状态设计原则
- 状态要能表示子问题
- 状态转移要无后效性
- 状态空间要可枚举

### 2. 调试技巧
- 手工验证小规模样例
- 检查边界条件处理
- 验证状态转移正确性

### 3. 优化策略
- 分析时间空间复杂度
- 考虑状态压缩可能
- 利用问题特殊性质

## 十六、总结

动态规划是解决最优化问题的重要方法，其核心思想是通过保存子问题的解来避免重复计算。掌握动态规划需要：

### 1. 理解核心概念
- 最优子结构、重叠子问题、无后效性
- 状态定义、转移方程、边界条件

### 2. 掌握设计方法
- 分析问题结构
- 设计状态表示
- 建立转移关系

### 3. 熟练常见类型
- 线性DP、区间DP、背包DP等
- 各种优化技巧和变种

### 4. 培养解题思维
- 从简单问题入手
- 逐步增加问题复杂度
- 多练习不同类型题目

### 5. 实际应用能力
- 将实际问题抽象为DP模型
- 选择合适的算法和优化策略
- 分析和改进算法性能

动态规划虽然学习曲线较陡峭，但一旦掌握，就能解决很多复杂的优化问题，是算法设计中不可或缺的重要工具。通过大量练习和思考，可以培养出敏锐的DP直觉和强大的问题解决能力。