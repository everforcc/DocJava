# 14.3.6. 回溯法 - Java代码示例

## 一、N皇后问题

```java
import java.util.*;

/**
 * N皇后问题 - 回溯法经典应用
 */
public class NQueens {
    
    /**
     * 求解N皇后问题的所有解
     * @param n 棋盘大小
     * @return 所有可能的解
     */
    public static List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        int[] queens = new int[n]; // queens[i]表示第i行皇后所在的列
        Arrays.fill(queens, -1);
        
        backtrack(result, queens, 0, n);
        return result;
    }
    
    /**
     * 回溯搜索
     */
    private static void backtrack(List<List<String>> result, int[] queens, int row, int n) {
        if (row == n) {
            // 找到一个解
            result.add(generateBoard(queens, n));
            return;
        }
        
        for (int col = 0; col < n; col++) {
            if (isValid(queens, row, col)) {
                queens[row] = col;           // 做选择
                backtrack(result, queens, row + 1, n);  // 递归
                queens[row] = -1;            // 撤销选择
            }
        }
    }
    
    /**
     * 检查在(row, col)放置皇后是否有效
     */
    private static boolean isValid(int[] queens, int row, int col) {
        for (int i = 0; i < row; i++) {
            // 检查列冲突
            if (queens[i] == col) {
                return false;
            }
            // 检查对角线冲突
            if (Math.abs(queens[i] - col) == Math.abs(i - row)) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * 根据皇后位置生成棋盘
     */
    private static List<String> generateBoard(int[] queens, int n) {
        List<String> board = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            StringBuilder row = new StringBuilder();
            for (int j = 0; j < n; j++) {
                row.append(queens[i] == j ? 'Q' : '.');
            }
            board.add(row.toString());
        }
        return board;
    }
    
    /**
     * 统计N皇后问题的解的数量（优化版本）
     */
    public static int totalNQueens(int n) {
        return backtrackCount(0, 0, 0, 0, n);
    }
    
    /**
     * 使用位运算优化的回溯计数
     */
    private static int backtrackCount(int row, int cols, int diag1, int diag2, int n) {
        if (row == n) {
            return 1;
        }
        
        int count = 0;
        int availablePositions = ((1 << n) - 1) & (~(cols | diag1 | diag2));
        
        while (availablePositions != 0) {
            int position = availablePositions & (-availablePositions);
            availablePositions &= (availablePositions - 1);
            
            count += backtrackCount(row + 1, 
                                   cols | position,
                                   (diag1 | position) << 1,
                                   (diag2 | position) >> 1,
                                   n);
        }
        
        return count;
    }
}
```

## 二、数独求解

```java
/**
 * 数独求解 - 回溯法应用
 */
public class SudokuSolver {
    
    /**
     * 求解数独
     * @param board 9x9的数独棋盘，空格用'.'表示
     */
    public static void solveSudoku(char[][] board) {
        backtrack(board, 0, 0);
    }
    
    /**
     * 回溯求解
     */
    private static boolean backtrack(char[][] board, int row, int col) {
        // 找到下一个空格
        int[] next = findNextEmpty(board, row, col);
        if (next == null) {
            return true; // 所有格子都填完了
        }
        
        row = next[0];
        col = next[1];
        
        // 尝试数字1-9
        for (char num = '1'; num <= '9'; num++) {
            if (isValid(board, row, col, num)) {
                board[row][col] = num;      // 做选择
                
                if (backtrack(board, row, col)) {
                    return true;
                }
                
                board[row][col] = '.';      // 撤销选择
            }
        }
        
        return false;
    }
    
    /**
     * 找到下一个空格
     */
    private static int[] findNextEmpty(char[][] board, int startRow, int startCol) {
        for (int i = startRow; i < 9; i++) {
            int j = (i == startRow) ? startCol : 0;
            for (; j < 9; j++) {
                if (board[i][j] == '.') {
                    return new int[]{i, j};
                }
            }
        }
        return null;
    }
    
    /**
     * 检查在(row, col)填入num是否有效
     */
    private static boolean isValid(char[][] board, int row, int col, char num) {
        // 检查行
        for (int j = 0; j < 9; j++) {
            if (board[row][j] == num) {
                return false;
            }
        }
        
        // 检查列
        for (int i = 0; i < 9; i++) {
            if (board[i][col] == num) {
                return false;
            }
        }
        
        // 检查3x3宫
        int boxRow = (row / 3) * 3;
        int boxCol = (col / 3) * 3;
        for (int i = boxRow; i < boxRow + 3; i++) {
            for (int j = boxCol; j < boxCol + 3; j++) {
                if (board[i][j] == num) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    /**
     * 打印数独棋盘
     */
    public static void printBoard(char[][] board) {
        for (int i = 0; i < 9; i++) {
            if (i % 3 == 0 && i != 0) {
                System.out.println("------+-------+------");
            }
            for (int j = 0; j < 9; j++) {
                if (j % 3 == 0 && j != 0) {
                    System.out.print("| ");
                }
                System.out.print(board[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

## 三、全排列生成

```java
/**
 * 全排列生成 - 回溯法应用
 */
public class Permutations {
    
    /**
     * 生成数组的所有排列
     */
    public static List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> current = new ArrayList<>();
        boolean[] used = new boolean[nums.length];
        
        backtrack(result, current, nums, used);
        return result;
    }
    
    /**
     * 回溯生成排列
     */
    private static void backtrack(List<List<Integer>> result, List<Integer> current, 
                                 int[] nums, boolean[] used) {
        if (current.size() == nums.length) {
            result.add(new ArrayList<>(current));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            if (!used[i]) {
                current.add(nums[i]);       // 做选择
                used[i] = true;
                
                backtrack(result, current, nums, used);  // 递归
                
                current.remove(current.size() - 1);     // 撤销选择
                used[i] = false;
            }
        }
    }
    
    /**
     * 生成有重复元素数组的排列（去重）
     */
    public static List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> current = new ArrayList<>();
        boolean[] used = new boolean[nums.length];
        
        Arrays.sort(nums); // 排序以便去重
        backtrackUnique(result, current, nums, used);
        return result;
    }
    
    /**
     * 回溯生成去重排列
     */
    private static void backtrackUnique(List<List<Integer>> result, List<Integer> current,
                                       int[] nums, boolean[] used) {
        if (current.size() == nums.length) {
            result.add(new ArrayList<>(current));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            
            // 去重：相同元素，前一个未使用时跳过当前元素
            if (i > 0 && nums[i] == nums[i-1] && !used[i-1]) {
                continue;
            }
            
            current.add(nums[i]);
            used[i] = true;
            
            backtrackUnique(result, current, nums, used);
            
            current.remove(current.size() - 1);
            used[i] = false;
        }
    }
}
```

## 四、组合生成

```java
/**
 * 组合生成 - 回溯法应用
 */
public class Combinations {
    
    /**
     * 生成从1到n中选择k个数的所有组合
     */
    public static List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> current = new ArrayList<>();
        
        backtrack(result, current, 1, n, k);
        return result;
    }
    
    /**
     * 回溯生成组合
     */
    private static void backtrack(List<List<Integer>> result, List<Integer> current,
                                 int start, int n, int k) {
        if (current.size() == k) {
            result.add(new ArrayList<>(current));
            return;
        }
        
        // 剪枝：如果剩余元素不足以构成k个数的组合，直接返回
        int remaining = k - current.size();
        for (int i = start; i <= n - remaining + 1; i++) {
            current.add(i);                    // 做选择
            backtrack(result, current, i + 1, n, k);  // 递归
            current.remove(current.size() - 1); // 撤销选择
        }
    }
    
    /**
     * 生成数组的所有子集
     */
    public static List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> current = new ArrayList<>();
        
        backtrackSubsets(result, current, nums, 0);
        return result;
    }
    
    /**
     * 回溯生成子集
     */
    private static void backtrackSubsets(List<List<Integer>> result, List<Integer> current,
                                        int[] nums, int start) {
        result.add(new ArrayList<>(current)); // 每个状态都是一个有效子集
        
        for (int i = start; i < nums.length; i++) {
            current.add(nums[i]);
            backtrackSubsets(result, current, nums, i + 1);
            current.remove(current.size() - 1);
        }
    }
}
```

## 五、子集和问题

```java
/**
 * 子集和问题 - 回溯法应用
 */
public class SubsetSum {
    
    /**
     * 找到所有和为目标值的子集
     */
    public static List<List<Integer>> findSubsets(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> current = new ArrayList<>();
        
        Arrays.sort(nums); // 排序以便剪枝
        backtrack(result, current, nums, target, 0);
        return result;
    }
    
    /**
     * 回溯搜索
     */
    private static void backtrack(List<List<Integer>> result, List<Integer> current,
                                 int[] nums, int target, int start) {
        if (target == 0) {
            result.add(new ArrayList<>(current));
            return;
        }
        
        for (int i = start; i < nums.length; i++) {
            // 剪枝：如果当前数字大于目标值，后面的数字也不可能满足
            if (nums[i] > target) {
                break;
            }
            
            current.add(nums[i]);
            backtrack(result, current, nums, target - nums[i], i + 1);
            current.remove(current.size() - 1);
        }
    }
    
    /**
     * 判断是否存在和为目标值的子集
     */
    public static boolean canPartition(int[] nums, int target) {
        Arrays.sort(nums);
        return backtrackExists(nums, target, 0);
    }
    
    /**
     * 回溯判断存在性（一旦找到解就返回）
     */
    private static boolean backtrackExists(int[] nums, int target, int start) {
        if (target == 0) {
            return true;
        }
        
        for (int i = start; i < nums.length; i++) {
            if (nums[i] > target) {
                break;
            }
            
            if (backtrackExists(nums, target - nums[i], i + 1)) {
                return true;
            }
        }
        
        return false;
    }
}
```

## 六、图的着色问题

```java
/**
 * 图的着色问题 - 回溯法应用
 */
public class GraphColoring {
    
    /**
     * 图的邻接矩阵表示
     */
    private int[][] graph;
    private int vertices;
    
    public GraphColoring(int[][] graph) {
        this.graph = graph;
        this.vertices = graph.length;
    }
    
    /**
     * 用m种颜色给图着色
     */
    public boolean colorGraph(int m) {
        int[] colors = new int[vertices];
        Arrays.fill(colors, -1);
        
        return backtrack(colors, 0, m);
    }
    
    /**
     * 回溯着色
     */
    private boolean backtrack(int[] colors, int vertex, int m) {
        if (vertex == vertices) {
            return true; // 所有顶点都着色完成
        }
        
        for (int color = 0; color < m; color++) {
            if (isSafe(colors, vertex, color)) {
                colors[vertex] = color;          // 做选择
                
                if (backtrack(colors, vertex + 1, m)) {
                    return true;
                }
                
                colors[vertex] = -1;             // 撤销选择
            }
        }
        
        return false;
    }
    
    /**
     * 检查给顶点着色是否安全
     */
    private boolean isSafe(int[] colors, int vertex, int color) {
        for (int i = 0; i < vertices; i++) {
            if (graph[vertex][i] == 1 && colors[i] == color) {
                return false; // 相邻顶点有相同颜色
            }
        }
        return true;
    }
    
    /**
     * 打印着色结果
     */
    public void printColoring(int[] colors) {
        System.out.println("图的着色结果:");
        for (int i = 0; i < colors.length; i++) {
            System.out.println("顶点 " + i + " -> 颜色 " + colors[i]);
        }
    }
}
```

## 七、综合测试类

```java
/**
 * 回溯法综合测试
 */
public class BacktrackingTest {
    
    public static void main(String[] args) {
        System.out.println("回溯法 - Java代码演示");
        System.out.println("====================");
        
        // 测试N皇后问题
        testNQueens();
        
        // 测试数独求解
        testSudoku();
        
        // 测试全排列
        testPermutations();
        
        // 测试组合生成
        testCombinations();
        
        // 测试子集和问题
        testSubsetSum();
        
        // 测试图着色
        testGraphColoring();
    }
    
    public static void testNQueens() {
        System.out.println("\n1. N皇后问题:");
        System.out.println("------------------");
        
        int n = 4;
        List<List<String>> solutions = NQueens.solveNQueens(n);
        System.out.println(n + "皇后问题的解的数量: " + solutions.size());
        
        if (!solutions.isEmpty()) {
            System.out.println("第一个解:");
            for (String row : solutions.get(0)) {
                System.out.println(row);
            }
        }
        
        System.out.println("8皇后问题的解的数量: " + NQueens.totalNQueens(8));
    }
    
    public static void testSudoku() {
        System.out.println("\n2. 数独求解:");
        System.out.println("------------------");
        
        char[][] board = {
            {'5','3','.','.','7','.','.','.','.'},
            {'6','.','.','1','9','5','.','.','.'},
            {'.','9','8','.','.','.','.','6','.'},
            {'8','.','.','.','6','.','.','.','3'},
            {'4','.','.','8','.','3','.','.','1'},
            {'7','.','.','.','2','.','.','.','6'},
            {'.','6','.','.','.','.','2','8','.'},
            {'.','.','.','4','1','9','.','.','5'},
            {'.','.','.','.','8','.','.','7','9'}
        };
        
        System.out.println("原始数独:");
        SudokuSolver.printBoard(board);
        
        SudokuSolver.solveSudoku(board);
        
        System.out.println("\n求解后:");
        SudokuSolver.printBoard(board);
    }
    
    public static void testPermutations() {
        System.out.println("\n3. 全排列生成:");
        System.out.println("------------------");
        
        int[] nums = {1, 2, 3};
        List<List<Integer>> perms = Permutations.permute(nums);
        
        System.out.println("数组 " + Arrays.toString(nums) + " 的所有排列:");
        for (List<Integer> perm : perms) {
            System.out.println(perm);
        }
    }
    
    public static void testCombinations() {
        System.out.println("\n4. 组合生成:");
        System.out.println("------------------");
        
        int n = 4, k = 2;
        List<List<Integer>> combinations = Combinations.combine(n, k);
        
        System.out.println("从1到" + n + "中选择" + k + "个数的所有组合:");
        for (List<Integer> combination : combinations) {
            System.out.println(combination);
        }
        
        int[] nums = {1, 2, 3};
        List<List<Integer>> subsets = Combinations.subsets(nums);
        System.out.println("\n数组 " + Arrays.toString(nums) + " 的所有子集:");
        for (List<Integer> subset : subsets) {
            System.out.println(subset);
        }
    }
    
    public static void testSubsetSum() {
        System.out.println("\n5. 子集和问题:");
        System.out.println("------------------");
        
        int[] nums = {2, 3, 6, 7};
        int target = 7;
        
        List<List<Integer>> subsets = SubsetSum.findSubsets(nums, target);
        System.out.println("数组 " + Arrays.toString(nums) + " 中和为 " + target + " 的子集:");
        for (List<Integer> subset : subsets) {
            System.out.println(subset);
        }
    }
    
    public static void testGraphColoring() {
        System.out.println("\n6. 图着色问题:");
        System.out.println("------------------");
        
        int[][] graph = {
            {0, 1, 1, 1},
            {1, 0, 1, 0},
            {1, 1, 0, 1},
            {1, 0, 1, 0}
        };
        
        GraphColoring gc = new GraphColoring(graph);
        int m = 3; // 使用3种颜色
        
        System.out.println("尝试用 " + m + " 种颜色给图着色:");
        if (gc.colorGraph(m)) {
            System.out.println("着色成功！");
        } else {
            System.out.println("无法用 " + m + " 种颜色着色");
        }
    }
}
```

## 八、编译和运行

### 1. 编译命令
```bash
javac NQueens.java
javac SudokuSolver.java
javac Permutations.java
javac Combinations.java
javac SubsetSum.java
javac GraphColoring.java
javac BacktrackingTest.java
```

### 2. 运行命令
```bash
java BacktrackingTest
```

## 九、学习要点

1. **理解回溯思想**：试探 + 回退的搜索策略
2. **掌握模板框架**：做选择 → 递归 → 撤销选择
3. **学会剪枝优化**：通过约束条件减少搜索空间
4. **熟练经典问题**：N皇后、数独、排列组合等
5. **分析复杂度**：理解指数级时间复杂度的特点
6. **实际应用**：能够将实际问题转化为回溯搜索问题
