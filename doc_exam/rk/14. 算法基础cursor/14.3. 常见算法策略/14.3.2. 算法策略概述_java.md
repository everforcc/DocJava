# 14.3.2. 算法策略概述 - Java代码示例

## 一、算法策略演示类

```java
/**
 * 算法策略概述 - 演示不同算法策略的基本思想
 * @author DocJava项目组
 * @version 1.0
 */
public class AlgorithmStrategyDemo {
    
    /**
     * 分治法示例 - 计算数组最大值
     * @param arr 输入数组
     * @param left 左边界
     * @param right 右边界
     * @return 最大值
     */
    public static int divideAndConquerMax(int[] arr, int left, int right) {
        // 基本情况：只有一个元素
        if (left == right) {
            return arr[left];
        }
        
        // 分治：分解为两个子问题
        int mid = (left + right) / 2;
        int leftMax = divideAndConquerMax(arr, left, mid);
        int rightMax = divideAndConquerMax(arr, mid + 1, right);
        
        // 合并：返回两个子问题的最优解
        return Math.max(leftMax, rightMax);
    }
    
    /**
     * 贪心法示例 - 找零钱问题（假设有面额1,5,10,25）
     * @param amount 需要找零的金额
     * @return 使用的硬币数组
     */
    public static int[] greedyChange(int amount) {
        int[] coins = {25, 10, 5, 1}; // 面额从大到小
        int[] result = new int[4]; // 记录每种面额使用的数量
        
        for (int i = 0; i < coins.length; i++) {
            result[i] = amount / coins[i]; // 贪心选择：尽可能多用大面额
            amount %= coins[i];
        }
        
        return result;
    }
    
    /**
     * 动态规划示例 - 斐波那契数列
     * @param n 第n项
     * @return 斐波那契数列第n项的值
     */
    public static long dynamicProgrammingFib(int n) {
        if (n <= 1) return n;
        
        // dp数组存储子问题的解
        long[] dp = new long[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        
        // 自底向上计算，避免重复计算
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        
        return dp[n];
    }
    
    /**
     * 回溯法示例 - 生成所有子集
     * @param nums 输入数组
     * @return 所有子集的列表
     */
    public static java.util.List<java.util.List<Integer>> backtrackingSubsets(int[] nums) {
        java.util.List<java.util.List<Integer>> result = new java.util.ArrayList<>();
        java.util.List<Integer> current = new java.util.ArrayList<>();
        backtrack(nums, 0, current, result);
        return result;
    }
    
    /**
     * 回溯递归函数
     */
    private static void backtrack(int[] nums, int start, 
                                java.util.List<Integer> current, 
                                java.util.List<java.util.List<Integer>> result) {
        // 添加当前子集到结果中
        result.add(new java.util.ArrayList<>(current));
        
        // 尝试添加后续元素
        for (int i = start; i < nums.length; i++) {
            current.add(nums[i]); // 选择
            backtrack(nums, i + 1, current, result); // 递归
            current.remove(current.size() - 1); // 回溯
        }
    }
}
```

## 二、算法策略性能比较

```java
/**
 * 算法策略性能比较
 */
public class AlgorithmStrategyComparison {
    
    /**
     * 测试不同策略的性能
     */
    public static void performanceTest() {
        int[] testData = generateTestData(1000);
        
        System.out.println("算法策略性能测试:");
        System.out.println("================");
        
        // 测试分治法
        long startTime = System.nanoTime();
        int maxValue = AlgorithmStrategyDemo.divideAndConquerMax(testData, 0, testData.length - 1);
        long endTime = System.nanoTime();
        System.out.println("分治法求最大值: " + maxValue + ", 耗时: " + (endTime - startTime) + "ns");
        
        // 测试贪心法
        startTime = System.nanoTime();
        int[] change = AlgorithmStrategyDemo.greedyChange(67);
        endTime = System.nanoTime();
        System.out.println("贪心法找零: " + java.util.Arrays.toString(change) + 
                          ", 耗时: " + (endTime - startTime) + "ns");
        
        // 测试动态规划
        startTime = System.nanoTime();
        long fibResult = AlgorithmStrategyDemo.dynamicProgrammingFib(20);
        endTime = System.nanoTime();
        System.out.println("动态规划斐波那契: " + fibResult + 
                          ", 耗时: " + (endTime - startTime) + "ns");
        
        // 测试回溯法（小数据量）
        int[] smallData = {1, 2, 3};
        startTime = System.nanoTime();
        java.util.List<java.util.List<Integer>> subsets = 
            AlgorithmStrategyDemo.backtrackingSubsets(smallData);
        endTime = System.nanoTime();
        System.out.println("回溯法生成子集数量: " + subsets.size() + 
                          ", 耗时: " + (endTime - startTime) + "ns");
    }
    
    /**
     * 生成测试数据
     */
    private static int[] generateTestData(int size) {
        int[] data = new int[size];
        java.util.Random random = new java.util.Random();
        for (int i = 0; i < size; i++) {
            data[i] = random.nextInt(1000);
        }
        return data;
    }
}
```

## 三、综合测试类

```java
/**
 * 算法策略概述测试类
 */
public class AlgorithmStrategyTest {
    
    public static void main(String[] args) {
        System.out.println("算法策略概述 - Java代码演示");
        System.out.println("============================");
        
        // 演示不同算法策略
        demonstrateStrategies();
        
        // 性能测试
        AlgorithmStrategyComparison.performanceTest();
    }
    
    /**
     * 演示不同算法策略
     */
    public static void demonstrateStrategies() {
        System.out.println("\n1. 算法策略演示:");
        System.out.println("-----------------");
        
        // 分治法演示
        int[] arr = {3, 7, 1, 9, 4, 6, 2, 8, 5};
        int max = AlgorithmStrategyDemo.divideAndConquerMax(arr, 0, arr.length - 1);
        System.out.println("分治法求最大值: " + max);
        
        // 贪心法演示
        int[] change = AlgorithmStrategyDemo.greedyChange(67);
        System.out.println("贪心法找零67分: 25分×" + change[0] + 
                          ", 10分×" + change[1] + ", 5分×" + change[2] + 
                          ", 1分×" + change[3]);
        
        // 动态规划演示
        long fib = AlgorithmStrategyDemo.dynamicProgrammingFib(10);
        System.out.println("动态规划计算第10项斐波那契数: " + fib);
        
        // 回溯法演示
        int[] nums = {1, 2};
        java.util.List<java.util.List<Integer>> subsets = 
            AlgorithmStrategyDemo.backtrackingSubsets(nums);
        System.out.println("回溯法生成{1,2}的所有子集: " + subsets);
    }
}
```

## 四、学习要点

1. **理解各策略特点**：掌握分治、贪心、动态规划、回溯的基本思想
2. **分析问题特征**：根据数据规模、最优性要求选择策略
3. **权衡时空复杂度**：在时间和空间之间找到平衡点
4. **实践应用**：通过具体例子理解各策略的适用场景
5. **性能测试**：通过实际测试比较不同策略的性能表现