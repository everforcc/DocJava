# 14.3.5. 动态规划法 - Java代码示例

## 一、斐波那契数列

```java
/**
 * 斐波那契数列 - 动态规划经典入门问题
 */
public class Fibonacci {
    
    /**
     * 暴力递归解法（效率低）
     */
    public static long fibonacciRecursive(int n) {
        if (n <= 1) return n;
        return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
    }
    
    /**
     * 动态规划解法 - 自底向上
     */
    public static long fibonacciDP(int n) {
        if (n <= 1) return n;
        
        long[] dp = new long[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        return dp[n];
    }
    
    /**
     * 空间优化版本
     */
    public static long fibonacciOptimized(int n) {
        if (n <= 1) return n;
        
        long prev2 = 0, prev1 = 1;
        for (int i = 2; i <= n; i++) {
            long current = prev1 + prev2;
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1;
    }
    
    /**
     * 记忆化递归解法
     */
    public static long fibonacciMemo(int n) {
        long[] memo = new long[n + 1];
        return fibonacciMemoHelper(n, memo);
    }
    
    private static long fibonacciMemoHelper(int n, long[] memo) {
        if (n <= 1) return n;
        
        if (memo[n] != 0) return memo[n];
        
        memo[n] = fibonacciMemoHelper(n - 1, memo) + fibonacciMemoHelper(n - 2, memo);
        return memo[n];
    }
}
```

## 二、0-1背包问题

```java
/**
 * 0-1背包问题 - 动态规划经典应用
 */
public class Knapsack01 {
    
    /**
     * 物品类
     */
    static class Item {
        int weight;
        int value;
        
        public Item(int weight, int value) {
            this.weight = weight;
            this.value = value;
        }
        
        @Override
        public String toString() {
            return String.format("Item(w=%d, v=%d)", weight, value);
        }
    }
    
    /**
     * 0-1背包问题求解
     * dp[i][w] 表示前i个物品，背包容量为w时的最大价值
     */
    public static int knapsack01(Item[] items, int capacity) {
        int n = items.length;
        int[][] dp = new int[n + 1][capacity + 1];
        
        // 填充DP表
        for (int i = 1; i <= n; i++) {
            for (int w = 1; w <= capacity; w++) {
                // 不选择第i个物品
                dp[i][w] = dp[i - 1][w];
                
                // 如果能装下第i个物品，考虑选择它
                if (items[i - 1].weight <= w) {
                    int valueWithItem = dp[i - 1][w - items[i - 1].weight] + items[i - 1].value;
                    dp[i][w] = Math.max(dp[i][w], valueWithItem);
                }
            }
        }
        
        return dp[n][capacity];
    }
    
    /**
     * 空间优化版本 - 使用一维数组
     */
    public static int knapsack01Optimized(Item[] items, int capacity) {
        int[] dp = new int[capacity + 1];
        
        for (Item item : items) {
            // 从后往前更新，避免重复使用
            for (int w = capacity; w >= item.weight; w--) {
                dp[w] = Math.max(dp[w], dp[w - item.weight] + item.value);
            }
        }
        
        return dp[capacity];
    }
    
    /**
     * 获取选择的物品
     */
    public static java.util.List<Item> getSelectedItems(Item[] items, int capacity) {
        int n = items.length;
        int[][] dp = new int[n + 1][capacity + 1];
        
        // 填充DP表
        for (int i = 1; i <= n; i++) {
            for (int w = 1; w <= capacity; w++) {
                dp[i][w] = dp[i - 1][w];
                if (items[i - 1].weight <= w) {
                    int valueWithItem = dp[i - 1][w - items[i - 1].weight] + items[i - 1].value;
                    dp[i][w] = Math.max(dp[i][w], valueWithItem);
                }
            }
        }
        
        // 回溯找出选择的物品
        java.util.List<Item> selected = new java.util.ArrayList<>();
        int w = capacity;
        for (int i = n; i > 0; i--) {
            if (dp[i][w] != dp[i - 1][w]) {
                selected.add(items[i - 1]);
                w -= items[i - 1].weight;
            }
        }
        
        return selected;
    }
}
```

## 三、最长公共子序列（LCS）

```java
/**
 * 最长公共子序列问题
 */
public class LongestCommonSubsequence {
    
    /**
     * 计算两个字符串的最长公共子序列长度
     */
    public static int lcsLength(String str1, String str2) {
        int m = str1.length();
        int n = str2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }
    
    /**
     * 获取最长公共子序列
     */
    public static String getLCS(String str1, String str2) {
        int m = str1.length();
        int n = str2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        // 填充DP表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        // 回溯构造LCS
        StringBuilder lcs = new StringBuilder();
        int i = m, j = n;
        while (i > 0 && j > 0) {
            if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                lcs.append(str1.charAt(i - 1));
                i--;
                j--;
            } else if (dp[i - 1][j] > dp[i][j - 1]) {
                i--;
            } else {
                j--;
            }
        }
        
        return lcs.reverse().toString();
    }
    
    /**
     * 空间优化版本
     */
    public static int lcsLengthOptimized(String str1, String str2) {
        int m = str1.length();
        int n = str2.length();
        
        // 确保str2是较短的字符串
        if (m < n) {
            return lcsLengthOptimized(str2, str1);
        }
        
        int[] prev = new int[n + 1];
        int[] curr = new int[n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    curr[j] = prev[j - 1] + 1;
                } else {
                    curr[j] = Math.max(prev[j], curr[j - 1]);
                }
            }
            // 交换数组
            int[] temp = prev;
            prev = curr;
            curr = temp;
        }
        
        return prev[n];
    }
}
```

## 四、最长递增子序列（LIS）

```java
/**
 * 最长递增子序列问题
 */
public class LongestIncreasingSubsequence {
    
    /**
     * 动态规划解法 O(n²)
     */
    public static int lisLength(int[] nums) {
        if (nums.length == 0) return 0;
        
        int[] dp = new int[nums.length];
        java.util.Arrays.fill(dp, 1);
        
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        
        return java.util.Arrays.stream(dp).max().orElse(0);
    }
    
    /**
     * 获取最长递增子序列
     */
    public static java.util.List<Integer> getLIS(int[] nums) {
        if (nums.length == 0) return new java.util.ArrayList<>();
        
        int[] dp = new int[nums.length];
        int[] parent = new int[nums.length];
        java.util.Arrays.fill(dp, 1);
        java.util.Arrays.fill(parent, -1);
        
        int maxLength = 1;
        int maxIndex = 0;
        
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i] && dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                    parent[i] = j;
                }
            }
            if (dp[i] > maxLength) {
                maxLength = dp[i];
                maxIndex = i;
            }
        }
        
        // 回溯构造LIS
        java.util.List<Integer> lis = new java.util.ArrayList<>();
        int current = maxIndex;
        while (current != -1) {
            lis.add(nums[current]);
            current = parent[current];
        }
        
        java.util.Collections.reverse(lis);
        return lis;
    }
    
    /**
     * 二分查找优化版本 O(n log n)
     */
    public static int lisLengthOptimized(int[] nums) {
        if (nums.length == 0) return 0;
        
        java.util.List<Integer> tails = new java.util.ArrayList<>();
        
        for (int num : nums) {
            int pos = binarySearch(tails, num);
            if (pos == tails.size()) {
                tails.add(num);
            } else {
                tails.set(pos, num);
            }
        }
        
        return tails.size();
    }
    
    private static int binarySearch(java.util.List<Integer> tails, int target) {
        int left = 0, right = tails.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (tails.get(mid) < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
```

## 五、编辑距离

```java
/**
 * 编辑距离问题（Levenshtein距离）
 */
public class EditDistance {
    
    /**
     * 计算两个字符串的编辑距离
     */
    public static int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        // 初始化边界条件
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }
        
        // 填充DP表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + Math.min(Math.min(
                        dp[i - 1][j],     // 删除
                        dp[i][j - 1]),    // 插入
                        dp[i - 1][j - 1]  // 替换
                    );
                }
            }
        }
        
        return dp[m][n];
    }
    
    /**
     * 空间优化版本
     */
    public static int minDistanceOptimized(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        
        // 确保word2是较短的字符串
        if (m < n) {
            return minDistanceOptimized(word2, word1);
        }
        
        int[] prev = new int[n + 1];
        int[] curr = new int[n + 1];
        
        // 初始化
        for (int j = 0; j <= n; j++) {
            prev[j] = j;
        }
        
        for (int i = 1; i <= m; i++) {
            curr[0] = i;
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    curr[j] = prev[j - 1];
                } else {
                    curr[j] = 1 + Math.min(Math.min(prev[j], curr[j - 1]), prev[j - 1]);
                }
            }
            // 交换数组
            int[] temp = prev;
            prev = curr;
            curr = temp;
        }
        
        return prev[n];
    }
}
```

## 六、综合测试类

```java
/**
 * 动态规划综合测试
 */
public class DynamicProgrammingTest {
    
    public static void main(String[] args) {
        System.out.println("动态规划法 - Java代码演示");
        System.out.println("========================");
        
        // 测试斐波那契数列
        testFibonacci();
        
        // 测试0-1背包问题
        testKnapsack();
        
        // 测试最长公共子序列
        testLCS();
        
        // 测试最长递增子序列
        testLIS();
        
        // 测试编辑距离
        testEditDistance();
    }
    
    public static void testFibonacci() {
        System.out.println("\n1. 斐波那契数列:");
        System.out.println("------------------");
        
        int n = 10;
        long startTime, endTime;
        
        startTime = System.nanoTime();
        long result1 = Fibonacci.fibonacciDP(n);
        endTime = System.nanoTime();
        System.out.printf("DP解法: fib(%d) = %d, 耗时: %d ns\n", n, result1, endTime - startTime);
        
        startTime = System.nanoTime();
        long result2 = Fibonacci.fibonacciOptimized(n);
        endTime = System.nanoTime();
        System.out.printf("优化解法: fib(%d) = %d, 耗时: %d ns\n", n, result2, endTime - startTime);
    }
    
    public static void testKnapsack() {
        System.out.println("\n2. 0-1背包问题:");
        System.out.println("------------------");
        
        Knapsack01.Item[] items = {
            new Knapsack01.Item(10, 60),
            new Knapsack01.Item(20, 100),
            new Knapsack01.Item(30, 120)
        };
        int capacity = 50;
        
        int maxValue = Knapsack01.knapsack01(items, capacity);
        System.out.println("最大价值: " + maxValue);
        
        java.util.List<Knapsack01.Item> selected = Knapsack01.getSelectedItems(items, capacity);
        System.out.println("选择的物品: " + selected);
    }
    
    public static void testLCS() {
        System.out.println("\n3. 最长公共子序列:");
        System.out.println("--------------------");
        
        String str1 = "ABCDGH";
        String str2 = "AEDFHR";
        
        int length = LongestCommonSubsequence.lcsLength(str1, str2);
        String lcs = LongestCommonSubsequence.getLCS(str1, str2);
        
        System.out.println("字符串1: " + str1);
        System.out.println("字符串2: " + str2);
        System.out.println("LCS长度: " + length);
        System.out.println("LCS: " + lcs);
    }
    
    public static void testLIS() {
        System.out.println("\n4. 最长递增子序列:");
        System.out.println("--------------------");
        
        int[] nums = {10, 9, 2, 5, 3, 7, 101, 18};
        
        int length = LongestIncreasingSubsequence.lisLength(nums);
        java.util.List<Integer> lis = LongestIncreasingSubsequence.getLIS(nums);
        
        System.out.println("数组: " + java.util.Arrays.toString(nums));
        System.out.println("LIS长度: " + length);
        System.out.println("LIS: " + lis);
    }
    
    public static void testEditDistance() {
        System.out.println("\n5. 编辑距离:");
        System.out.println("--------------");
        
        String word1 = "horse";
        String word2 = "ros";
        
        int distance = EditDistance.minDistance(word1, word2);
        
        System.out.println("单词1: " + word1);
        System.out.println("单词2: " + word2);
        System.out.println("编辑距离: " + distance);
    }
}
```

## 七、学习要点

1. **状态定义**：正确定义DP状态是解题关键
2. **状态转移**：找到状态间的递推关系
3. **边界条件**：正确处理初始状态
4. **空间优化**：利用状态依赖关系优化空间
5. **时间复杂度**：分析算法的时间复杂度
6. **实际应用**：理解DP在实际问题中的应用
