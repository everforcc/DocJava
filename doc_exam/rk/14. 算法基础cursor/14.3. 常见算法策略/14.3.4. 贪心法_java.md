# 14.3.4. 贪心法 - Java代码示例

## 一、活动选择问题

```java
import java.util.*;

/**
 * 活动选择问题 - 贪心法经典应用
 */
public class ActivitySelection {
    
    static class Activity {
        int start;
        int end;
        int id;
        
        public Activity(int id, int start, int end) {
            this.id = id;
            this.start = start;
            this.end = end;
        }
        
        @Override
        public String toString() {
            return "Activity" + id + "(" + start + "-" + end + ")";
        }
    }
    
    /**
     * 贪心法解决活动选择问题
     * 策略：每次选择结束时间最早的活动
     */
    public static List<Activity> selectActivities(Activity[] activities) {
        // 按结束时间排序
        Arrays.sort(activities, Comparator.comparingInt(a -> a.end));
        
        List<Activity> selected = new ArrayList<>();
        selected.add(activities[0]); // 选择第一个活动
        
        int lastEnd = activities[0].end;
        
        // 贪心选择：选择结束时间最早且不冲突的活动
        for (int i = 1; i < activities.length; i++) {
            if (activities[i].start >= lastEnd) {
                selected.add(activities[i]);
                lastEnd = activities[i].end;
            }
        }
        
        return selected;
    }
}
```

## 二、分数背包问题

```java
/**
 * 分数背包问题 - 贪心法应用
 */
public class FractionalKnapsack {
    
    static class Item {
        int weight;
        int value;
        double ratio; // 价值密度
        
        public Item(int weight, int value) {
            this.weight = weight;
            this.value = value;
            this.ratio = (double) value / weight;
        }
        
        @Override
        public String toString() {
            return String.format("Item(w=%d, v=%d, r=%.2f)", weight, value, ratio);
        }
    }
    
    /**
     * 贪心法解决分数背包问题
     * 策略：按价值密度从高到低选择物品
     */
    public static double fractionalKnapsack(Item[] items, int capacity) {
        // 按价值密度降序排序
        Arrays.sort(items, (a, b) -> Double.compare(b.ratio, a.ratio));
        
        double totalValue = 0.0;
        int remainingCapacity = capacity;
        
        for (Item item : items) {
            if (remainingCapacity >= item.weight) {
                // 完全装入
                totalValue += item.value;
                remainingCapacity -= item.weight;
            } else if (remainingCapacity > 0) {
                // 部分装入
                double fraction = (double) remainingCapacity / item.weight;
                totalValue += item.value * fraction;
                remainingCapacity = 0;
                break;
            }
        }
        
        return totalValue;
    }
}
```

## 三、哈夫曼编码

```java
/**
 * 哈夫曼编码 - 贪心法在编码中的应用
 */
public class HuffmanCoding {
    
    static class HuffmanNode implements Comparable<HuffmanNode> {
        char character;
        int frequency;
        HuffmanNode left;
        HuffmanNode right;
        
        public HuffmanNode(char character, int frequency) {
            this.character = character;
            this.frequency = frequency;
        }
        
        public HuffmanNode(int frequency) {
            this.frequency = frequency;
        }
        
        public boolean isLeaf() {
            return left == null && right == null;
        }
        
        @Override
        public int compareTo(HuffmanNode other) {
            return Integer.compare(this.frequency, other.frequency);
        }
    }
    
    /**
     * 构建哈夫曼树
     * 贪心策略：每次合并频率最小的两个节点
     */
    public static HuffmanNode buildHuffmanTree(Map<Character, Integer> frequencies) {
        PriorityQueue<HuffmanNode> heap = new PriorityQueue<>();
        
        // 为每个字符创建叶子节点
        for (Map.Entry<Character, Integer> entry : frequencies.entrySet()) {
            heap.offer(new HuffmanNode(entry.getKey(), entry.getValue()));
        }
        
        // 贪心合并：每次选择频率最小的两个节点
        while (heap.size() > 1) {
            HuffmanNode left = heap.poll();
            HuffmanNode right = heap.poll();
            
            HuffmanNode merged = new HuffmanNode(left.frequency + right.frequency);
            merged.left = left;
            merged.right = right;
            
            heap.offer(merged);
        }
        
        return heap.poll();
    }
    
    /**
     * 生成哈夫曼编码
     */
    public static Map<Character, String> generateCodes(HuffmanNode root) {
        Map<Character, String> codes = new HashMap<>();
        if (root != null) {
            generateCodes(root, "", codes);
        }
        return codes;
    }
    
    private static void generateCodes(HuffmanNode node, String code, Map<Character, String> codes) {
        if (node.isLeaf()) {
            codes.put(node.character, code.isEmpty() ? "0" : code);
        } else {
            generateCodes(node.left, code + "0", codes);
            generateCodes(node.right, code + "1", codes);
        }
    }
}
```

## 四、最小生成树（Kruskal算法）

```java
/**
 * Kruskal算法实现最小生成树
 */
public class KruskalMST {
    
    static class Edge implements Comparable<Edge> {
        int src, dest, weight;
        
        public Edge(int src, int dest, int weight) {
            this.src = src;
            this.dest = dest;
            this.weight = weight;
        }
        
        @Override
        public int compareTo(Edge other) {
            return Integer.compare(this.weight, other.weight);
        }
        
        @Override
        public String toString() {
            return String.format("(%d-%d, %d)", src, dest, weight);
        }
    }
    
    /**
     * 并查集实现
     */
    static class UnionFind {
        private int[] parent;
        private int[] rank;
        
        public UnionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
        }
        
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]); // 路径压缩
            }
            return parent[x];
        }
        
        public boolean union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            
            if (rootX == rootY) {
                return false; // 已经在同一个集合中
            }
            
            // 按秩合并
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
            
            return true;
        }
    }
    
    /**
     * Kruskal算法求最小生成树
     * 贪心策略：每次选择权重最小且不构成环的边
     */
    public static List<Edge> kruskalMST(int vertices, List<Edge> edges) {
        // 按权重排序
        Collections.sort(edges);
        
        List<Edge> mst = new ArrayList<>();
        UnionFind uf = new UnionFind(vertices);
        
        for (Edge edge : edges) {
            if (uf.union(edge.src, edge.dest)) {
                mst.add(edge);
                if (mst.size() == vertices - 1) {
                    break; // MST完成
                }
            }
        }
        
        return mst;
    }
}
```

## 五、单源最短路径（Dijkstra算法）

```java
/**
 * Dijkstra算法实现单源最短路径
 */
public class DijkstraShortestPath {
    
    static class Edge {
        int dest;
        int weight;
        
        public Edge(int dest, int weight) {
            this.dest = dest;
            this.weight = weight;
        }
    }
    
    static class Node implements Comparable<Node> {
        int vertex;
        int distance;
        
        public Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }
        
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.distance, other.distance);
        }
    }
    
    /**
     * Dijkstra算法求单源最短路径
     * 贪心策略：每次选择距离源点最近的未访问顶点
     */
    public static int[] dijkstra(List<List<Edge>> graph, int source) {
        int n = graph.size();
        int[] dist = new int[n];
        boolean[] visited = new boolean[n];
        
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[source] = 0;
        
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.offer(new Node(source, 0));
        
        while (!pq.isEmpty()) {
            Node current = pq.poll();
            int u = current.vertex;
            
            if (visited[u]) {
                continue;
            }
            
            visited[u] = true;
            
            // 更新邻接顶点的距离
            for (Edge edge : graph.get(u)) {
                int v = edge.dest;
                int weight = edge.weight;
                
                if (!visited[v] && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    pq.offer(new Node(v, dist[v]));
                }
            }
        }
        
        return dist;
    }
}
```

## 六、区间调度问题

```java
/**
 * 区间调度问题 - 贪心法应用
 */
public class IntervalScheduling {
    
    static class Interval {
        int start;
        int end;
        
        public Interval(int start, int end) {
            this.start = start;
            this.end = end;
        }
        
        @Override
        public String toString() {
            return "[" + start + ", " + end + "]";
        }
    }
    
    /**
     * 区间调度 - 选择最多的不重叠区间
     * 贪心策略：按结束时间排序，每次选择结束最早的区间
     */
    public static List<Interval> scheduleIntervals(Interval[] intervals) {
        // 按结束时间排序
        Arrays.sort(intervals, Comparator.comparingInt(i -> i.end));
        
        List<Interval> scheduled = new ArrayList<>();
        scheduled.add(intervals[0]);
        
        int lastEnd = intervals[0].end;
        
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i].start >= lastEnd) {
                scheduled.add(intervals[i]);
                lastEnd = intervals[i].end;
            }
        }
        
        return scheduled;
    }
    
    /**
     * 最少会议室数量
     * 贪心策略：按开始时间排序，维护会议室结束时间的最小堆
     */
    public static int minMeetingRooms(Interval[] intervals) {
        if (intervals.length == 0) return 0;
        
        // 按开始时间排序
        Arrays.sort(intervals, Comparator.comparingInt(i -> i.start));
        
        // 最小堆存储会议室的结束时间
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        
        for (Interval interval : intervals) {
            // 如果有会议室空闲，重用它
            if (!heap.isEmpty() && heap.peek() <= interval.start) {
                heap.poll();
            }
            
            // 分配会议室
            heap.offer(interval.end);
        }
        
        return heap.size();
    }
}
```

## 七、综合测试类

```java
/**
 * 贪心法综合测试
 */
public class GreedyAlgorithmTest {
    
    public static void main(String[] args) {
        System.out.println("贪心法 - Java代码演示");
        System.out.println("====================");
        
        // 测试活动选择问题
        testActivitySelection();
        
        // 测试分数背包问题
        testFractionalKnapsack();
        
        // 测试哈夫曼编码
        testHuffmanCoding();
        
        // 测试最小生成树
        testKruskalMST();
        
        // 测试最短路径
        testDijkstra();
        
        // 测试区间调度
        testIntervalScheduling();
    }
    
    public static void testActivitySelection() {
        System.out.println("\n1. 活动选择问题:");
        System.out.println("------------------");
        
        ActivitySelection.Activity[] activities = {
            new ActivitySelection.Activity(1, 1, 4),
            new ActivitySelection.Activity(2, 3, 5),
            new ActivitySelection.Activity(3, 0, 6),
            new ActivitySelection.Activity(4, 5, 7),
            new ActivitySelection.Activity(5, 3, 9),
            new ActivitySelection.Activity(6, 5, 9),
            new ActivitySelection.Activity(7, 6, 10),
            new ActivitySelection.Activity(8, 8, 11)
        };
        
        List<ActivitySelection.Activity> result = ActivitySelection.selectActivities(activities);
        System.out.println("选择的活动: " + result);
        System.out.println("总共选择了 " + result.size() + " 个活动");
    }
    
    public static void testFractionalKnapsack() {
        System.out.println("\n2. 分数背包问题:");
        System.out.println("------------------");
        
        FractionalKnapsack.Item[] items = {
            new FractionalKnapsack.Item(10, 60),
            new FractionalKnapsack.Item(20, 100),
            new FractionalKnapsack.Item(30, 120)
        };
        int capacity = 50;
        
        double maxValue = FractionalKnapsack.fractionalKnapsack(items, capacity);
        System.out.println("背包容量: " + capacity);
        System.out.println("最大价值: " + maxValue);
    }
    
    public static void testHuffmanCoding() {
        System.out.println("\n3. 哈夫曼编码:");
        System.out.println("---------------");
        
        Map<Character, Integer> frequencies = new HashMap<>();
        frequencies.put('a', 45);
        frequencies.put('b', 13);
        frequencies.put('c', 12);
        frequencies.put('d', 16);
        frequencies.put('e', 9);
        frequencies.put('f', 5);
        
        HuffmanCoding.HuffmanNode root = HuffmanCoding.buildHuffmanTree(frequencies);
        Map<Character, String> codes = HuffmanCoding.generateCodes(root);
        
        System.out.println("哈夫曼编码:");
        codes.forEach((ch, code) -> System.out.println(ch + ": " + code));
    }
    
    public static void testKruskalMST() {
        System.out.println("\n4. 最小生成树:");
        System.out.println("----------------");
        
        List<KruskalMST.Edge> edges = Arrays.asList(
            new KruskalMST.Edge(0, 1, 10),
            new KruskalMST.Edge(0, 2, 6),
            new KruskalMST.Edge(0, 3, 5),
            new KruskalMST.Edge(1, 3, 15),
            new KruskalMST.Edge(2, 3, 4)
        );
        
        List<KruskalMST.Edge> mst = KruskalMST.kruskalMST(4, edges);
        System.out.println("最小生成树的边:");
        mst.forEach(System.out::println);
        
        int totalWeight = mst.stream().mapToInt(e -> e.weight).sum();
        System.out.println("总权重: " + totalWeight);
    }
    
    public static void testDijkstra() {
        System.out.println("\n5. 最短路径:");
        System.out.println("--------------");
        
        // 构建图
        List<List<DijkstraShortestPath.Edge>> graph = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            graph.add(new ArrayList<>());
        }
        
        graph.get(0).add(new DijkstraShortestPath.Edge(1, 10));
        graph.get(0).add(new DijkstraShortestPath.Edge(4, 5));
        graph.get(1).add(new DijkstraShortestPath.Edge(2, 1));
        graph.get(1).add(new DijkstraShortestPath.Edge(4, 2));
        graph.get(2).add(new DijkstraShortestPath.Edge(3, 4));
        graph.get(3).add(new DijkstraShortestPath.Edge(2, 6));
        graph.get(4).add(new DijkstraShortestPath.Edge(1, 3));
        graph.get(4).add(new DijkstraShortestPath.Edge(2, 9));
        graph.get(4).add(new DijkstraShortestPath.Edge(3, 2));
        
        int[] distances = DijkstraShortestPath.dijkstra(graph, 0);
        System.out.println("从顶点0到各顶点的最短距离:");
        for (int i = 0; i < distances.length; i++) {
            System.out.println("到顶点" + i + ": " + distances[i]);
        }
    }
    
    public static void testIntervalScheduling() {
        System.out.println("\n6. 区间调度:");
        System.out.println("-------------");
        
        IntervalScheduling.Interval[] intervals = {
            new IntervalScheduling.Interval(1, 3),
            new IntervalScheduling.Interval(2, 4),
            new IntervalScheduling.Interval(3, 6),
            new IntervalScheduling.Interval(5, 7),
            new IntervalScheduling.Interval(8, 9)
        };
        
        List<IntervalScheduling.Interval> scheduled = 
            IntervalScheduling.scheduleIntervals(intervals);
        System.out.println("调度的区间: " + scheduled);
        
        int meetingRooms = IntervalScheduling.minMeetingRooms(intervals);
        System.out.println("最少需要会议室数量: " + meetingRooms);
    }
}
```

## 八、学习要点

1. **理解贪心策略**：每个问题都有特定的贪心选择标准
2. **验证正确性**：贪心法不总是最优，需要证明其正确性
3. **排序的重要性**：大多数贪心算法都需要先排序
4. **时间复杂度分析**：通常由排序步骤决定
5. **实际应用**：掌握经典问题的解法和变形