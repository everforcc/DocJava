# 14.3.1. 算法策略知识点概述 - Java代码示例

## 分治法示例

```java
/**
 * 分治法示例类
 */
public class DivideAndConquer {
    
    /**
     * 归并排序 - 分治法典型应用
     */
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            // 分解：递归排序左右两部分
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            
            // 合并：合并两个有序数组
            merge(arr, left, mid, right);
        }
    }
    
    private static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        int[] leftArr = new int[n1];
        int[] rightArr = new int[n2];
        
        System.arraycopy(arr, left, leftArr, 0, n1);
        System.arraycopy(arr, mid + 1, rightArr, 0, n2);
        
        int i = 0, j = 0, k = left;
        
        while (i < n1 && j < n2) {
            if (leftArr[i] <= rightArr[j]) {
                arr[k++] = leftArr[i++];
            } else {
                arr[k++] = rightArr[j++];
            }
        }
        
        while (i < n1) {
            arr[k++] = leftArr[i++];
        }
        
        while (j < n2) {
            arr[k++] = rightArr[j++];
        }
    }
    
    /**
     * 快速排序 - 分治法应用
     */
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // 分解：选择基准元素并分区
            int pivotIndex = partition(arr, low, high);
            
            // 递归排序左右两部分
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    /**
     * 二分查找 - 分治法应用
     */
    public static int binarySearch(int[] arr, int target, int left, int right) {
        if (left > right) {
            return -1;
        }
        
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] > target) {
            return binarySearch(arr, target, left, mid - 1);
        } else {
            return binarySearch(arr, target, mid + 1, right);
        }
    }
    
    /**
     * 最大子数组和 - 分治法应用
     */
    public static int maxSubarraySum(int[] arr, int left, int right) {
        if (left == right) {
            return arr[left];
        }
        
        int mid = left + (right - left) / 2;
        
        // 递归求解左右两部分的最大子数组和
        int leftMax = maxSubarraySum(arr, left, mid);
        int rightMax = maxSubarraySum(arr, mid + 1, right);
        
        // 求解跨越中点的最大子数组和
        int crossMax = maxCrossingSum(arr, left, mid, right);
        
        return Math.max(Math.max(leftMax, rightMax), crossMax);
    }
    
    private static int maxCrossingSum(int[] arr, int left, int mid, int right) {
        int leftSum = Integer.MIN_VALUE;
        int sum = 0;
        
        for (int i = mid; i >= left; i--) {
            sum += arr[i];
            leftSum = Math.max(leftSum, sum);
        }
        
        int rightSum = Integer.MIN_VALUE;
        sum = 0;
        
        for (int i = mid + 1; i <= right; i++) {
            sum += arr[i];
            rightSum = Math.max(rightSum, sum);
        }
        
        return leftSum + rightSum;
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 动态规划法示例

```java
/**
 * 动态规划法示例类
 */
public class DynamicProgramming {
    
    /**
     * 斐波那契数列 - 动态规划
     */
    public static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        return dp[n];
    }
    
    /**
     * 最长公共子序列 - 动态规划
     */
    public static int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }
    
    /**
     * 最长递增子序列 - 动态规划
     */
    public static int longestIncreasingSubsequence(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        
        int maxLength = 1;
        
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLength = Math.max(maxLength, dp[i]);
        }
        
        return maxLength;
    }
    
    /**
     * 0-1背包问题 - 动态规划
     */
    public static int knapsack(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[][] dp = new int[n + 1][capacity + 1];
        
        for (int i = 1; i <= n; i++) {
            for (int w = 1; w <= capacity; w++) {
                if (weights[i - 1] <= w) {
                    dp[i][w] = Math.max(
                        dp[i - 1][w],  // 不选择第i个物品
                        dp[i - 1][w - weights[i - 1]] + values[i - 1]  // 选择第i个物品
                    );
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        
        return dp[n][capacity];
    }
    
    /**
     * 编辑距离 - 动态规划
     */
    public static int editDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        // 初始化
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(
                        Math.min(dp[i - 1][j], dp[i][j - 1]),  // 删除或插入
                        dp[i - 1][j - 1]  // 替换
                    ) + 1;
                }
            }
        }
        
        return dp[m][n];
    }
}
```

## 贪心法示例

```java
/**
 * 贪心法示例类
 */
public class GreedyAlgorithm {
    
    /**
     * 活动选择问题 - 贪心法
     */
    public static List<int[]> activitySelection(int[] start, int[] end) {
        int n = start.length;
        List<int[]> activities = new ArrayList<>();
        
        // 创建活动列表
        for (int i = 0; i < n; i++) {
            activities.add(new int[]{start[i], end[i], i});
        }
        
        // 按结束时间排序
        activities.sort((a, b) -> Integer.compare(a[1], b[1]));
        
        List<int[]> selected = new ArrayList<>();
        int lastEndTime = 0;
        
        for (int[] activity : activities) {
            if (activity[0] >= lastEndTime) {
                selected.add(activity);
                lastEndTime = activity[1];
            }
        }
        
        return selected;
    }
    
    /**
     * 找零钱问题 - 贪心法
     */
    public static List<Integer> coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        List<Integer> result = new ArrayList<>();
        
        for (int i = coins.length - 1; i >= 0; i--) {
            while (amount >= coins[i]) {
                result.add(coins[i]);
                amount -= coins[i];
            }
        }
        
        return amount == 0 ? result : new ArrayList<>();
    }
    
    /**
     * 最小生成树 - Kruskal算法（贪心法）
     */
    public static class Edge {
        int src, dest, weight;
        
        public Edge(int src, int dest, int weight) {
            this.src = src;
            this.dest = dest;
            this.weight = weight;
        }
    }
    
    public static List<Edge> kruskalMST(List<Edge> edges, int vertices) {
        // 按权重排序
        edges.sort((a, b) -> Integer.compare(a.weight, b.weight));
        
        List<Edge> mst = new ArrayList<>();
        int[] parent = new int[vertices];
        
        // 初始化并查集
        for (int i = 0; i < vertices; i++) {
            parent[i] = i;
        }
        
        for (Edge edge : edges) {
            int srcRoot = find(parent, edge.src);
            int destRoot = find(parent, edge.dest);
            
            if (srcRoot != destRoot) {
                mst.add(edge);
                union(parent, srcRoot, destRoot);
            }
        }
        
        return mst;
    }
    
    private static int find(int[] parent, int x) {
        if (parent[x] != x) {
            parent[x] = find(parent, parent[x]);
        }
        return parent[x];
    }
    
    private static void union(int[] parent, int x, int y) {
        parent[x] = y;
    }
    
    /**
     * 哈夫曼编码 - 贪心法
     */
    public static class HuffmanNode {
        char data;
        int frequency;
        HuffmanNode left, right;
        
        public HuffmanNode(char data, int frequency) {
            this.data = data;
            this.frequency = frequency;
        }
    }
    
    public static Map<Character, String> huffmanEncoding(String text) {
        Map<Character, Integer> frequency = new HashMap<>();
        for (char c : text.toCharArray()) {
            frequency.put(c, frequency.getOrDefault(c, 0) + 1);
        }
        
        PriorityQueue<HuffmanNode> pq = new PriorityQueue<>((a, b) -> a.frequency - b.frequency);
        
        for (Map.Entry<Character, Integer> entry : frequency.entrySet()) {
            pq.offer(new HuffmanNode(entry.getKey(), entry.getValue()));
        }
        
        while (pq.size() > 1) {
            HuffmanNode left = pq.poll();
            HuffmanNode right = pq.poll();
            
            HuffmanNode merged = new HuffmanNode('\0', left.frequency + right.frequency);
            merged.left = left;
            merged.right = right;
            
            pq.offer(merged);
        }
        
        Map<Character, String> codes = new HashMap<>();
        generateCodes(pq.poll(), "", codes);
        
        return codes;
    }
    
    private static void generateCodes(HuffmanNode root, String code, Map<Character, String> codes) {
        if (root == null) {
            return;
        }
        
        if (root.data != '\0') {
            codes.put(root.data, code);
        }
        
        generateCodes(root.left, code + "0", codes);
        generateCodes(root.right, code + "1", codes);
    }
}
```

## 回溯法示例

```java
/**
 * 回溯法示例类
 */
public class Backtracking {
    
    /**
     * N皇后问题 - 回溯法
     */
    public static List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        int[] queens = new int[n];
        Arrays.fill(queens, -1);
        
        backtrack(result, queens, 0, n);
        return result;
    }
    
    private static void backtrack(List<List<String>> result, int[] queens, int row, int n) {
        if (row == n) {
            result.add(generateBoard(queens, n));
            return;
        }
        
        for (int col = 0; col < n; col++) {
            if (isValid(queens, row, col)) {
                queens[row] = col;
                backtrack(result, queens, row + 1, n);
                queens[row] = -1;  // 回溯
            }
        }
    }
    
    private static boolean isValid(int[] queens, int row, int col) {
        for (int i = 0; i < row; i++) {
            if (queens[i] == col || Math.abs(queens[i] - col) == Math.abs(i - row)) {
                return false;
            }
        }
        return true;
    }
    
    private static List<String> generateBoard(int[] queens, int n) {
        List<String> board = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            char[] row = new char[n];
            Arrays.fill(row, '.');
            row[queens[i]] = 'Q';
            board.add(new String(row));
        }
        return board;
    }
    
    /**
     * 数独求解 - 回溯法
     */
    public static boolean solveSudoku(char[][] board) {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') {
                    for (char c = '1'; c <= '9'; c++) {
                        if (isValidSudoku(board, i, j, c)) {
                            board[i][j] = c;
                            if (solveSudoku(board)) {
                                return true;
                            }
                            board[i][j] = '.';  // 回溯
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
    
    private static boolean isValidSudoku(char[][] board, int row, int col, char c) {
        for (int i = 0; i < 9; i++) {
            if (board[i][col] == c || board[row][i] == c) {
                return false;
            }
        }
        
        int boxRow = 3 * (row / 3);
        int boxCol = 3 * (col / 3);
        
        for (int i = boxRow; i < boxRow + 3; i++) {
            for (int j = boxCol; j < boxCol + 3; j++) {
                if (board[i][j] == c) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    /**
     * 子集生成 - 回溯法
     */
    public static List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrackSubsets(nums, 0, new ArrayList<>(), result);
        return result;
    }
    
    private static void backtrackSubsets(int[] nums, int start, List<Integer> current, List<List<Integer>> result) {
        result.add(new ArrayList<>(current));
        
        for (int i = start; i < nums.length; i++) {
            current.add(nums[i]);
            backtrackSubsets(nums, i + 1, current, result);
            current.remove(current.size() - 1);  // 回溯
        }
    }
    
    /**
     * 全排列 - 回溯法
     */
    public static List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrackPermute(nums, new ArrayList<>(), result);
        return result;
    }
    
    private static void backtrackPermute(int[] nums, List<Integer> current, List<List<Integer>> result) {
        if (current.size() == nums.length) {
            result.add(new ArrayList<>(current));
            return;
        }
        
        for (int num : nums) {
            if (!current.contains(num)) {
                current.add(num);
                backtrackPermute(nums, current, result);
                current.remove(current.size() - 1);  // 回溯
            }
        }
    }
}
```

## 测试代码

```java
/**
 * 算法策略测试类
 */
public class AlgorithmStrategyTest {
    public static void main(String[] args) {
        System.out.println("=== 分治法测试 ===");
        testDivideAndConquer();
        
        System.out.println("\n=== 动态规划法测试 ===");
        testDynamicProgramming();
        
        System.out.println("\n=== 贪心法测试 ===");
        testGreedyAlgorithm();
        
        System.out.println("\n=== 回溯法测试 ===");
        testBacktracking();
    }
    
    /**
     * 测试分治法
     */
    public static void testDivideAndConquer() {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("原数组: " + Arrays.toString(arr));
        
        DivideAndConquer.mergeSort(arr, 0, arr.length - 1);
        System.out.println("归并排序后: " + Arrays.toString(arr));
        
        int[] searchArr = {1, 3, 5, 7, 9, 11, 13, 15};
        int index = DivideAndConquer.binarySearch(searchArr, 7, 0, searchArr.length - 1);
        System.out.println("二分查找7的位置: " + index);
        
        int[] subarray = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        int maxSum = DivideAndConquer.maxSubarraySum(subarray, 0, subarray.length - 1);
        System.out.println("最大子数组和: " + maxSum);
    }
    
    /**
     * 测试动态规划法
     */
    public static void testDynamicProgramming() {
        System.out.println("斐波那契第10项: " + DynamicProgramming.fibonacci(10));
        
        String text1 = "abcde";
        String text2 = "ace";
        int lcs = DynamicProgramming.longestCommonSubsequence(text1, text2);
        System.out.println("最长公共子序列长度: " + lcs);
        
        int[] nums = {10, 9, 2, 5, 3, 7, 101, 18};
        int lis = DynamicProgramming.longestIncreasingSubsequence(nums);
        System.out.println("最长递增子序列长度: " + lis);
        
        int[] weights = {2, 3, 4, 5};
        int[] values = {3, 4, 5, 6};
        int capacity = 8;
        int maxValue = DynamicProgramming.knapsack(weights, values, capacity);
        System.out.println("背包问题最大价值: " + maxValue);
    }
    
    /**
     * 测试贪心法
     */
    public static void testGreedyAlgorithm() {
        int[] start = {1, 3, 0, 5, 8, 5};
        int[] end = {2, 4, 6, 7, 9, 9};
        List<int[]> selected = GreedyAlgorithm.activitySelection(start, end);
        System.out.println("选择的活动数量: " + selected.size());
        
        int[] coins = {1, 5, 10, 25};
        int amount = 67;
        List<Integer> change = GreedyAlgorithm.coinChange(coins, amount);
        System.out.println("找零钱: " + change);
        
        String text = "hello world";
        Map<Character, String> codes = GreedyAlgorithm.huffmanEncoding(text);
        System.out.println("哈夫曼编码: " + codes);
    }
    
    /**
     * 测试回溯法
     */
    public static void testBacktracking() {
        List<List<String>> solutions = Backtracking.solveNQueens(4);
        System.out.println("4皇后问题的解数量: " + solutions.size());
        
        int[] nums = {1, 2, 3};
        List<List<Integer>> subsets = Backtracking.subsets(nums);
        System.out.println("子集数量: " + subsets.size());
        
        List<List<Integer>> permutations = Backtracking.permute(nums);
        System.out.println("全排列数量: " + permutations.size());
    }
}
```
