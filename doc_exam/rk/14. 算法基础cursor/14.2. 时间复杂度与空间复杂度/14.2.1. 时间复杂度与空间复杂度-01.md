<span  style="font-family: Simsun,serif; font-size: 17px; ">

# 14.2.1. 时间复杂度与空间复杂度-01

## 概述
算法复杂度分析是计算机科学中的重要概念，用于评估算法的效率。复杂度分析主要包括时间复杂度和空间复杂度两个方面，它们帮助我们理解算法在不同输入规模下的性能表现。

## 算法复杂度分析的意义

### 1. 性能评估
- 比较不同算法的效率
- 预测算法在大规模数据下的表现
- 为算法选择提供依据

### 2. 资源规划
- 估算程序运行时间
- 评估内存需求
- 制定系统性能指标

### 3. 算法优化
- 识别性能瓶颈
- 指导算法改进方向
- 验证优化效果

## 时间复杂度

### 定义
时间复杂度是算法执行时间随输入规模增长的变化趋势，通常用大O记号表示。

### 基本概念
- **输入规模**：算法处理的数据量，通常用n表示
- **基本操作**：算法中最频繁执行的操作
- **执行次数**：基本操作在算法中的执行次数
- **增长趋势**：当n趋向无穷大时，执行次数的变化趋势

### 大O记号
大O记号表示算法时间复杂度的上界，描述算法在最坏情况下的性能。

#### 定义
对于函数f(n)和g(n)，如果存在正常数c和n₀，使得当n≥n₀时，f(n)≤c·g(n)，则记作f(n)=O(g(n))。

#### 性质
1. **传递性**：如果f(n)=O(g(n))且g(n)=O(h(n))，则f(n)=O(h(n))
2. **加法规则**：如果f(n)=O(g(n))且h(n)=O(k(n))，则f(n)+h(n)=O(max(g(n),k(n)))
3. **乘法规则**：如果f(n)=O(g(n))且h(n)=O(k(n))，则f(n)·h(n)=O(g(n)·k(n))

## 常见时间复杂度

### 1. 常数时间 O(1)
算法的执行时间不随输入规模变化。

#### 特点
- 执行时间固定
- 效率最高
- 通常用于简单操作

#### 示例
```java
// 访问数组元素
int getElement(int[] arr, int index) {
    return arr[index];  // O(1)
}

// 交换两个变量
void swap(int a, int b) {
    int temp = a;  // O(1)
    a = b;         // O(1)
    b = temp;      // O(1)
}
```

### 2. 对数时间 O(log n)
算法的执行时间与输入规模的对数成正比。

#### 特点
- 效率很高
- 通常用于分治算法
- 增长缓慢

#### 示例
```java
// 二分查找
int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;  // O(log n)
}
```

### 3. 线性时间 O(n)
算法的执行时间与输入规模成正比。

#### 特点
- 效率较高
- 需要遍历所有元素
- 常见于搜索和遍历

#### 示例
```java
// 线性查找
int linearSearch(int[] arr, int target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) return i;
    }
    return -1;  // O(n)
}

// 计算数组和
int sumArray(int[] arr) {
    int sum = 0;
    for (int i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return sum;  // O(n)
}
```

### 4. 线性对数时间 O(n log n)
算法的执行时间与输入规模乘以对数成正比。

#### 特点
- 效率较高
- 常见于高效排序算法
- 分治算法的典型复杂度

#### 示例
```java
// 归并排序
void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);      // T(n/2)
        mergeSort(arr, mid + 1, right); // T(n/2)
        merge(arr, left, mid, right);   // O(n)
    }
    // T(n) = 2T(n/2) + O(n) = O(n log n)
}
```

### 5. 平方时间 O(n²)
算法的执行时间与输入规模的平方成正比。

#### 特点
- 效率较低
- 常见于嵌套循环
- 简单排序算法

#### 示例
```java
// 冒泡排序
void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, j, j + 1);
            }
        }
    }
    // O(n²)
}
```

### 6. 立方时间 O(n³)
算法的执行时间与输入规模的立方成正比。

#### 特点
- 效率很低
- 常见于三重嵌套循环
- 矩阵乘法等算法

#### 示例
```java
// 矩阵乘法
int[][] matrixMultiply(int[][] A, int[][] B) {
    int n = A.length;
    int[][] C = new int[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            for (int k = 0; k < n; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    return C;  // O(n³)
}
```

### 7. 指数时间 O(2ⁿ)
算法的执行时间与2的n次方成正比。

#### 特点
- 效率极低
- 通常用于小规模问题
- 递归算法的典型复杂度

#### 示例
```java
// 斐波那契数列（递归）
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
    // T(n) = T(n-1) + T(n-2) + O(1) ≈ O(2ⁿ)
}
```

## 时间复杂度分析步骤

### 1. 确定输入规模
- 识别影响算法执行时间的主要因素
- 通常用n表示输入规模

### 2. 识别基本操作
- 找出算法中最频繁执行的操作
- 通常是最内层循环中的操作

### 3. 计算执行次数
- 分析基本操作的执行次数
- 考虑最坏情况、平均情况、最好情况

### 4. 确定复杂度
- 忽略常数因子和低次项
- 使用大O记号表示

## 复杂度比较

### 增长趋势
```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ)
```

### 实际意义
- **O(1)**：几乎瞬间完成
- **O(log n)**：几秒钟内完成
- **O(n)**：几分钟内完成
- **O(n log n)**：几小时内完成
- **O(n²)**：可能需要几天
- **O(2ⁿ)**：可能需要几年或更长

## 平均情况、最坏情况、最好情况

### 1. 最好情况时间复杂度
算法在最理想输入下的时间复杂度。

### 2. 平均情况时间复杂度
算法在所有可能输入下的期望时间复杂度。

### 3. 最坏情况时间复杂度
算法在最不利输入下的时间复杂度。

### 示例：快速排序
- **最好情况**：O(n log n) - 每次划分都平衡
- **平均情况**：O(n log n) - 随机输入
- **最坏情况**：O(n²) - 每次划分都不平衡

## 总结
时间复杂度分析是算法设计的重要工具，它帮助我们理解算法的性能特征，为算法选择和优化提供依据。掌握常见的时间复杂度类型和分析方法，对于提高编程能力和算法设计水平具有重要意义。

</span>