<span  style="font-family: Simsun,serif; font-size: 17px; ">

# 14.2.2. 时间复杂度与空间复杂度-02 - Java代码示例

## 递归算法复杂度分析

```java
/**
 * 递归算法复杂度分析示例
 */
public class RecursiveComplexityAnalysis {
    
    /**
     * 二分查找 - O(log n)
     */
    public static int binarySearchRecursive(int[] arr, int target, int left, int right) {
        if (left > right) {
            return -1;
        }
        
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] > target) {
            return binarySearchRecursive(arr, target, left, mid - 1);
        } else {
            return binarySearchRecursive(arr, target, mid + 1, right);
        }
        // T(n) = T(n/2) + O(1) = O(log n)
    }
    
    /**
     * 归并排序 - O(n log n)
     */
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, left, mid);      // T(n/2)
            mergeSort(arr, mid + 1, right); // T(n/2)
            merge(arr, left, mid, right);   // O(n)
        }
        // T(n) = 2T(n/2) + O(n) = O(n log n)
    }
    
    private static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        int[] leftArr = new int[n1];
        int[] rightArr = new int[n2];
        
        System.arraycopy(arr, left, leftArr, 0, n1);
        System.arraycopy(arr, mid + 1, rightArr, 0, n2);
        
        int i = 0, j = 0, k = left;
        
        while (i < n1 && j < n2) {
            if (leftArr[i] <= rightArr[j]) {
                arr[k++] = leftArr[i++];
            } else {
                arr[k++] = rightArr[j++];
            }
        }
        
        while (i < n1) {
            arr[k++] = leftArr[i++];
        }
        
        while (j < n2) {
            arr[k++] = rightArr[j++];
        }
    }
    
    /**
     * 快速排序 - 平均O(n log n)，最坏O(n²)
     */
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            quickSort(arr, low, pivotIndex - 1);  // T(k)
            quickSort(arr, pivotIndex + 1, high); // T(n-k-1)
        }
        // 平均情况：T(n) = 2T(n/2) + O(n) = O(n log n)
        // 最坏情况：T(n) = T(n-1) + O(n) = O(n²)
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    /**
     * 斐波那契数列（递归）- O(2^n)
     */
    public static int fibonacciRecursive(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
        // T(n) = T(n-1) + T(n-2) + O(1) ≈ O(2^n)
    }
    
    /**
     * 斐波那契数列（动态规划）- O(n)
     */
    public static int fibonacciDP(int n) {
        if (n <= 1) {
            return n;
        }
        
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        return dp[n];
        // 时间复杂度：O(n)
        // 空间复杂度：O(n)
    }
    
    /**
     * 斐波那契数列（空间优化）- O(n)时间，O(1)空间
     */
    public static int fibonacciOptimized(int n) {
        if (n <= 1) {
            return n;
        }
        
        int prev2 = 0;
        int prev1 = 1;
        
        for (int i = 2; i <= n; i++) {
            int current = prev1 + prev2;
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1;
        // 时间复杂度：O(n)
        // 空间复杂度：O(1)
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 动态规划复杂度分析

```java
/**
 * 动态规划复杂度分析示例
 */
public class DynamicProgrammingComplexity {
    
    /**
     * 最长公共子序列 - O(mn)
     */
    public static int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
        // 时间复杂度：O(mn)
        // 空间复杂度：O(mn)
    }
    
    /**
     * 最长公共子序列（空间优化）- O(mn)时间，O(min(m,n))空间
     */
    public static int longestCommonSubsequenceOptimized(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        
        // 确保text1是较短的字符串
        if (m > n) {
            return longestCommonSubsequenceOptimized(text2, text1);
        }
        
        int[] prev = new int[m + 1];
        int[] curr = new int[m + 1];
        
        for (int j = 1; j <= n; j++) {
            for (int i = 1; i <= m; i++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    curr[i] = prev[i - 1] + 1;
                } else {
                    curr[i] = Math.max(prev[i], curr[i - 1]);
                }
            }
            int[] temp = prev;
            prev = curr;
            curr = temp;
        }
        
        return prev[m];
        // 时间复杂度：O(mn)
        // 空间复杂度：O(min(m,n))
    }
    
    /**
     * 0-1背包问题 - O(nW)
     */
    public static int knapsack(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[][] dp = new int[n + 1][capacity + 1];
        
        for (int i = 1; i <= n; i++) {
            for (int w = 1; w <= capacity; w++) {
                if (weights[i - 1] <= w) {
                    dp[i][w] = Math.max(
                        dp[i - 1][w],
                        dp[i - 1][w - weights[i - 1]] + values[i - 1]
                    );
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        
        return dp[n][capacity];
        // 时间复杂度：O(nW)
        // 空间复杂度：O(nW)
    }
    
    /**
     * 0-1背包问题（空间优化）- O(nW)时间，O(W)空间
     */
    public static int knapsackOptimized(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        int[] dp = new int[capacity + 1];
        
        for (int i = 1; i <= n; i++) {
            for (int w = capacity; w >= weights[i - 1]; w--) {
                dp[w] = Math.max(dp[w], dp[w - weights[i - 1]] + values[i - 1]);
            }
        }
        
        return dp[capacity];
        // 时间复杂度：O(nW)
        // 空间复杂度：O(W)
    }
    
    /**
     * 最长递增子序列 - O(n²)
     */
    public static int longestIncreasingSubsequence(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        
        int maxLength = 1;
        
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxLength = Math.max(maxLength, dp[i]);
        }
        
        return maxLength;
        // 时间复杂度：O(n²)
        // 空间复杂度：O(n)
    }
    
    /**
     * 最长递增子序列（优化）- O(n log n)
     */
    public static int longestIncreasingSubsequenceOptimized(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        
        List<Integer> tails = new ArrayList<>();
        
        for (int num : nums) {
            int pos = binarySearch(tails, num);
            if (pos == tails.size()) {
                tails.add(num);
            } else {
                tails.set(pos, num);
            }
        }
        
        return tails.size();
        // 时间复杂度：O(n log n)
        // 空间复杂度：O(n)
    }
    
    private static int binarySearch(List<Integer> list, int target) {
        int left = 0;
        int right = list.size();
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (list.get(mid) < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return left;
    }
}
```

## 图算法复杂度分析

```java
/**
 * 图算法复杂度分析示例
 */
public class GraphComplexityAnalysis {
    
    /**
     * 图的邻接表表示
     */
    public static class Graph {
        private int vertices;
        private List<List<Integer>> adjacencyList;
        
        public Graph(int vertices) {
            this.vertices = vertices;
            this.adjacencyList = new ArrayList<>();
            for (int i = 0; i < vertices; i++) {
                adjacencyList.add(new ArrayList<>());
            }
        }
        
        public void addEdge(int source, int destination) {
            adjacencyList.get(source).add(destination);
        }
        
        public List<Integer> getNeighbors(int vertex) {
            return adjacencyList.get(vertex);
        }
        
        public int getVertices() {
            return vertices;
        }
    }
    
    /**
     * 深度优先搜索 - O(V+E)
     */
    public static void dfs(Graph graph, int start, boolean[] visited) {
        visited[start] = true;
        System.out.print(start + " ");
        
        for (int neighbor : graph.getNeighbors(start)) {
            if (!visited[neighbor]) {
                dfs(graph, neighbor, visited);
            }
        }
        // 时间复杂度：O(V+E)
        // 空间复杂度：O(V)
    }
    
    /**
     * 广度优先搜索 - O(V+E)
     */
    public static void bfs(Graph graph, int start) {
        boolean[] visited = new boolean[graph.getVertices()];
        Queue<Integer> queue = new LinkedList<>();
        
        visited[start] = true;
        queue.offer(start);
        
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            System.out.print(vertex + " ");
            
            for (int neighbor : graph.getNeighbors(vertex)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.offer(neighbor);
                }
            }
        }
        // 时间复杂度：O(V+E)
        // 空间复杂度：O(V)
    }
    
    /**
     * Dijkstra算法 - O((V+E)log V)
     */
    public static int[] dijkstra(Graph graph, int start) {
        int vertices = graph.getVertices();
        int[] distances = new int[vertices];
        boolean[] visited = new boolean[vertices];
        
        Arrays.fill(distances, Integer.MAX_VALUE);
        distances[start] = 0;
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        pq.offer(new int[]{start, 0});
        
        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            int vertex = current[0];
            int distance = current[1];
            
            if (visited[vertex]) {
                continue;
            }
            
            visited[vertex] = true;
            
            for (int neighbor : graph.getNeighbors(vertex)) {
                int newDistance = distance + 1; // 假设边权重为1
                if (newDistance < distances[neighbor]) {
                    distances[neighbor] = newDistance;
                    pq.offer(new int[]{neighbor, newDistance});
                }
            }
        }
        
        return distances;
        // 时间复杂度：O((V+E)log V)
        // 空间复杂度：O(V)
    }
    
    /**
     * Floyd-Warshall算法 - O(V³)
     */
    public static int[][] floydWarshall(int[][] graph) {
        int vertices = graph.length;
        int[][] distances = new int[vertices][vertices];
        
        // 初始化距离矩阵
        for (int i = 0; i < vertices; i++) {
            for (int j = 0; j < vertices; j++) {
                distances[i][j] = graph[i][j];
            }
        }
        
        // 动态规划
        for (int k = 0; k < vertices; k++) {
            for (int i = 0; i < vertices; i++) {
                for (int j = 0; j < vertices; j++) {
                    if (distances[i][k] != Integer.MAX_VALUE && 
                        distances[k][j] != Integer.MAX_VALUE) {
                        distances[i][j] = Math.min(distances[i][j], 
                                                 distances[i][k] + distances[k][j]);
                    }
                }
            }
        }
        
        return distances;
        // 时间复杂度：O(V³)
        // 空间复杂度：O(V²)
    }
}
```

## 复杂度分析工具

```java
/**
 * 复杂度分析工具类
 */
public class ComplexityAnalyzer {
    
    /**
     * 性能测试工具
     */
    public static class PerformanceTest {
        
        /**
         * 测试算法执行时间
         */
        public static long measureTime(Runnable algorithm) {
            long startTime = System.nanoTime();
            algorithm.run();
            long endTime = System.nanoTime();
            return endTime - startTime;
        }
        
        /**
         * 测试算法执行时间（多次运行取平均值）
         */
        public static double measureAverageTime(Runnable algorithm, int runs) {
            long totalTime = 0;
            for (int i = 0; i < runs; i++) {
                totalTime += measureTime(algorithm);
            }
            return (double) totalTime / runs;
        }
        
        /**
         * 比较两个算法的性能
         */
        public static void compareAlgorithms(Runnable algorithm1, Runnable algorithm2, int runs) {
            double time1 = measureAverageTime(algorithm1, runs);
            double time2 = measureAverageTime(algorithm2, runs);
            
            System.out.printf("算法1平均执行时间: %.2f ns%n", time1);
            System.out.printf("算法2平均执行时间: %.2f ns%n", time2);
            System.out.printf("性能比较: 算法%d更快，快%.2f倍%n", 
                time1 < time2 ? 1 : 2, 
                Math.max(time1, time2) / Math.min(time1, time2));
        }
    }
    
    /**
     * 复杂度验证工具
     */
    public static class ComplexityValidator {
        
        /**
         * 验证线性时间复杂度
         */
        public static void validateLinearTime(int[] sizes, Function<Integer, Long> algorithm) {
            System.out.println("验证线性时间复杂度 O(n):");
            for (int size : sizes) {
                long time = algorithm.apply(size);
                System.out.printf("n=%d, 时间=%d ns, 时间/n=%.2f%n", 
                    size, time, (double) time / size);
            }
        }
        
        /**
         * 验证平方时间复杂度
         */
        public static void validateQuadraticTime(int[] sizes, Function<Integer, Long> algorithm) {
            System.out.println("验证平方时间复杂度 O(n²):");
            for (int size : sizes) {
                long time = algorithm.apply(size);
                System.out.printf("n=%d, 时间=%d ns, 时间/n²=%.2f%n", 
                    size, time, (double) time / (size * size));
            }
        }
        
        /**
         * 验证对数时间复杂度
         */
        public static void validateLogarithmicTime(int[] sizes, Function<Integer, Long> algorithm) {
            System.out.println("验证对数时间复杂度 O(log n):");
            for (int size : sizes) {
                long time = algorithm.apply(size);
                double logN = Math.log(size) / Math.log(2);
                System.out.printf("n=%d, 时间=%d ns, 时间/log n=%.2f%n", 
                    size, time, (double) time / logN);
            }
        }
    }
    
    /**
     * 内存使用分析工具
     */
    public static class MemoryAnalyzer {
        
        /**
         * 获取当前内存使用量
         */
        public static long getCurrentMemoryUsage() {
            Runtime runtime = Runtime.getRuntime();
            return runtime.totalMemory() - runtime.freeMemory();
        }
        
        /**
         * 测量算法内存使用量
         */
        public static long measureMemoryUsage(Runnable algorithm) {
            System.gc(); // 强制垃圾回收
            long beforeMemory = getCurrentMemoryUsage();
            algorithm.run();
            long afterMemory = getCurrentMemoryUsage();
            return afterMemory - beforeMemory;
        }
        
        /**
         * 分析内存使用模式
         */
        public static void analyzeMemoryPattern(int[] sizes, Function<Integer, Long> algorithm) {
            System.out.println("内存使用分析:");
            for (int size : sizes) {
                long memory = algorithm.apply(size);
                System.out.printf("n=%d, 内存使用=%d bytes, 内存/n=%.2f%n", 
                    size, memory, (double) memory / size);
            }
        }
    }
}
```

## 测试代码

```java
/**
 * 复杂度分析测试类
 */
public class ComplexityAnalysisTest {
    public static void main(String[] args) {
        System.out.println("=== 递归算法复杂度测试 ===");
        testRecursiveComplexity();
        
        System.out.println("\n=== 动态规划复杂度测试 ===");
        testDynamicProgrammingComplexity();
        
        System.out.println("\n=== 图算法复杂度测试 ===");
        testGraphComplexity();
        
        System.out.println("\n=== 复杂度验证测试 ===");
        testComplexityValidation();
    }
    
    /**
     * 测试递归算法复杂度
     */
    public static void testRecursiveComplexity() {
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
        int target = 11;
        
        // 测试二分查找
        long time1 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            RecursiveComplexityAnalysis.binarySearchRecursive(arr, target, 0, arr.length - 1);
        });
        System.out.println("二分查找时间: " + time1 + " ns");
        
        // 测试斐波那契数列
        long time2 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            RecursiveComplexityAnalysis.fibonacciRecursive(20);
        });
        System.out.println("斐波那契递归时间: " + time2 + " ns");
        
        long time3 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            RecursiveComplexityAnalysis.fibonacciDP(20);
        });
        System.out.println("斐波那契DP时间: " + time3 + " ns");
        
        long time4 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            RecursiveComplexityAnalysis.fibonacciOptimized(20);
        });
        System.out.println("斐波那契优化时间: " + time4 + " ns");
    }
    
    /**
     * 测试动态规划复杂度
     */
    public static void testDynamicProgrammingComplexity() {
        String text1 = "abcde";
        String text2 = "ace";
        
        long time1 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            DynamicProgrammingComplexity.longestCommonSubsequence(text1, text2);
        });
        System.out.println("LCS时间: " + time1 + " ns");
        
        long time2 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            DynamicProgrammingComplexity.longestCommonSubsequenceOptimized(text1, text2);
        });
        System.out.println("LCS优化时间: " + time2 + " ns");
        
        int[] weights = {2, 3, 4, 5};
        int[] values = {3, 4, 5, 6};
        int capacity = 8;
        
        long time3 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            DynamicProgrammingComplexity.knapsack(weights, values, capacity);
        });
        System.out.println("背包问题时间: " + time3 + " ns");
        
        long time4 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            DynamicProgrammingComplexity.knapsackOptimized(weights, values, capacity);
        });
        System.out.println("背包问题优化时间: " + time4 + " ns");
    }
    
    /**
     * 测试图算法复杂度
     */
    public static void testGraphComplexity() {
        GraphComplexityAnalysis.Graph graph = new GraphComplexityAnalysis.Graph(5);
        graph.addEdge(0, 1);
        graph.addEdge(0, 2);
        graph.addEdge(1, 3);
        graph.addEdge(2, 4);
        
        boolean[] visited = new boolean[5];
        
        long time1 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            GraphComplexityAnalysis.dfs(graph, 0, visited);
        });
        System.out.println("DFS时间: " + time1 + " ns");
        
        long time2 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            GraphComplexityAnalysis.bfs(graph, 0);
        });
        System.out.println("BFS时间: " + time2 + " ns");
        
        long time3 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            GraphComplexityAnalysis.dijkstra(graph, 0);
        });
        System.out.println("Dijkstra时间: " + time3 + " ns");
    }
    
    /**
     * 测试复杂度验证
     */
    public static void testComplexityValidation() {
        int[] sizes = {100, 200, 400, 800, 1600};
        
        // 验证线性时间复杂度
        ComplexityAnalyzer.ComplexityValidator.validateLinearTime(sizes, n -> {
            int[] arr = new int[n];
            Arrays.fill(arr, 1);
            return ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
                int sum = 0;
                for (int i = 0; i < n; i++) {
                    sum += arr[i];
                }
            });
        });
        
        // 验证平方时间复杂度
        ComplexityAnalyzer.ComplexityValidator.validateQuadraticTime(sizes, n -> {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = n - i;
            }
            return ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        if (arr[i] > arr[j]) {
                            int temp = arr[i];
                            arr[i] = arr[j];
                            arr[j] = temp;
                        }
                    }
                }
            });
        });
        
        // 验证对数时间复杂度
        ComplexityAnalyzer.ComplexityValidator.validateLogarithmicTime(sizes, n -> {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = i;
            }
            return ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
                RecursiveComplexityAnalysis.binarySearchRecursive(arr, n / 2, 0, n - 1);
            });
        });
    }
}
```

</span>