# 14.2.1. 时间复杂度与空间复杂度-01 - Java代码示例

## 时间复杂度示例

```java
/**
 * 时间复杂度示例类
 */
public class TimeComplexityExamples {
    
    /**
     * O(1) - 常数时间
     * 访问数组元素
     */
    public static int getElement(int[] arr, int index) {
        return arr[index];  // O(1)
    }
    
    /**
     * O(1) - 常数时间
     * 交换两个变量
     */
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];  // O(1)
        arr[i] = arr[j];    // O(1)
        arr[j] = temp;      // O(1)
    }
    
    /**
     * O(log n) - 对数时间
     * 二分查找
     */
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;  // O(1)
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;  // O(log n)
    }
    
    /**
     * O(n) - 线性时间
     * 线性查找
     */
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {  // 循环n次
            if (arr[i] == target) {
                return i;
            }
        }
        return -1;  // O(n)
    }
    
    /**
     * O(n) - 线性时间
     * 计算数组和
     */
    public static int sumArray(int[] arr) {
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {  // 循环n次
            sum += arr[i];  // O(1)
        }
        return sum;  // O(n)
    }
    
    /**
     * O(n log n) - 线性对数时间
     * 归并排序
     */
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, left, mid);      // T(n/2)
            mergeSort(arr, mid + 1, right); // T(n/2)
            merge(arr, left, mid, right);   // O(n)
        }
        // T(n) = 2T(n/2) + O(n) = O(n log n)
    }
    
    private static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        int[] leftArr = new int[n1];
        int[] rightArr = new int[n2];
        
        System.arraycopy(arr, left, leftArr, 0, n1);
        System.arraycopy(arr, mid + 1, rightArr, 0, n2);
        
        int i = 0, j = 0, k = left;
        
        while (i < n1 && j < n2) {
            if (leftArr[i] <= rightArr[j]) {
                arr[k++] = leftArr[i++];
            } else {
                arr[k++] = rightArr[j++];
            }
        }
        
        while (i < n1) {
            arr[k++] = leftArr[i++];
        }
        
        while (j < n2) {
            arr[k++] = rightArr[j++];
        }
    }
    
    /**
     * O(n²) - 平方时间
     * 冒泡排序
     */
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {        // 外层循环n次
            for (int j = 0; j < n - i - 1; j++) { // 内层循环最多n次
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                }
            }
        }
        // O(n²)
    }
    
    /**
     * O(n²) - 平方时间
     * 选择排序
     */
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {        // 外层循环n次
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {    // 内层循环最多n次
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            if (minIndex != i) {
                swap(arr, i, minIndex);
            }
        }
        // O(n²)
    }
    
    /**
     * O(n³) - 立方时间
     * 矩阵乘法
     */
    public static int[][] matrixMultiply(int[][] A, int[][] B) {
        int n = A.length;
        int[][] C = new int[n][n];
        
        for (int i = 0; i < n; i++) {           // 外层循环n次
            for (int j = 0; j < n; j++) {       // 中层循环n次
                for (int k = 0; k < n; k++) {   // 内层循环n次
                    C[i][j] += A[i][k] * B[k][j];
                }
            }
        }
        return C;  // O(n³)
    }
    
    /**
     * O(2ⁿ) - 指数时间
     * 斐波那契数列（递归）
     */
    public static int fibonacciRecursive(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
        // T(n) = T(n-1) + T(n-2) + O(1) ≈ O(2ⁿ)
    }
    
    /**
     * O(n) - 线性时间
     * 斐波那契数列（动态规划）
     */
    public static int fibonacciDP(int n) {
        if (n <= 1) {
            return n;
        }
        
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        
        for (int i = 2; i <= n; i++) {  // 循环n次
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        return dp[n];  // O(n)
    }
}
```

## 空间复杂度示例

```java
/**
 * 空间复杂度示例类
 */
public class SpaceComplexityExamples {
    
    /**
     * O(1) - 常数空间
     * 交换两个变量
     */
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];  // 只使用一个额外变量
        arr[i] = arr[j];
        arr[j] = temp;
        // 空间复杂度：O(1)
    }
    
    /**
     * O(1) - 常数空间
     * 计算数组和
     */
    public static int sumArray(int[] arr) {
        int sum = 0;  // 只使用一个额外变量
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        return sum;
        // 空间复杂度：O(1)
    }
    
    /**
     * O(n) - 线性空间
     * 复制数组
     */
    public static int[] copyArray(int[] arr) {
        int[] copy = new int[arr.length];  // 创建与原数组相同大小的数组
        for (int i = 0; i < arr.length; i++) {
            copy[i] = arr[i];
        }
        return copy;
        // 空间复杂度：O(n)
    }
    
    /**
     * O(n) - 线性空间
     * 斐波那契数列（动态规划）
     */
    public static int fibonacciDP(int n) {
        if (n <= 1) {
            return n;
        }
        
        int[] dp = new int[n + 1];  // 创建大小为n+1的数组
        dp[0] = 0;
        dp[1] = 1;
        
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        return dp[n];
        // 空间复杂度：O(n)
    }
    
    /**
     * O(1) - 常数空间
     * 斐波那契数列（空间优化）
     */
    public static int fibonacciOptimized(int n) {
        if (n <= 1) {
            return n;
        }
        
        int prev2 = 0;  // 只使用两个变量
        int prev1 = 1;
        
        for (int i = 2; i <= n; i++) {
            int current = prev1 + prev2;
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1;
        // 空间复杂度：O(1)
    }
    
    /**
     * O(n) - 线性空间
     * 归并排序
     */
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, left, mid);      // 递归调用，栈空间O(log n)
            mergeSort(arr, mid + 1, right); // 递归调用，栈空间O(log n)
            merge(arr, left, mid, right);   // 临时数组，空间O(n)
        }
        // 总空间复杂度：O(n)
    }
    
    private static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        int[] leftArr = new int[n1];   // 临时数组
        int[] rightArr = new int[n2];  // 临时数组
        
        System.arraycopy(arr, left, leftArr, 0, n1);
        System.arraycopy(arr, mid + 1, rightArr, 0, n2);
        
        int i = 0, j = 0, k = left;
        
        while (i < n1 && j < n2) {
            if (leftArr[i] <= rightArr[j]) {
                arr[k++] = leftArr[i++];
            } else {
                arr[k++] = rightArr[j++];
            }
        }
        
        while (i < n1) {
            arr[k++] = leftArr[i++];
        }
        
        while (j < n2) {
            arr[k++] = rightArr[j++];
        }
    }
    
    /**
     * O(log n) - 对数空间
     * 二分查找（递归）
     */
    public static int binarySearchRecursive(int[] arr, int target, int left, int right) {
        if (left > right) {
            return -1;
        }
        
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            return binarySearchRecursive(arr, target, mid + 1, right);
        } else {
            return binarySearchRecursive(arr, target, left, mid - 1);
        }
        // 递归深度：O(log n)，空间复杂度：O(log n)
    }
    
    /**
     * O(1) - 常数空间
     * 二分查找（迭代）
     */
    public static int binarySearchIterative(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
        // 只使用几个变量，空间复杂度：O(1)
    }
}
```

## 复杂度分析工具

```java
/**
 * 复杂度分析工具类
 */
public class ComplexityAnalyzer {
    
    /**
     * 性能测试工具
     */
    public static class PerformanceTest {
        
        /**
         * 测试算法执行时间
         */
        public static long measureTime(Runnable algorithm) {
            long startTime = System.nanoTime();
            algorithm.run();
            long endTime = System.nanoTime();
            return endTime - startTime;
        }
        
        /**
         * 测试算法执行时间（多次运行取平均值）
         */
        public static double measureAverageTime(Runnable algorithm, int runs) {
            long totalTime = 0;
            for (int i = 0; i < runs; i++) {
                totalTime += measureTime(algorithm);
            }
            return (double) totalTime / runs;
        }
        
        /**
         * 比较两个算法的性能
         */
        public static void compareAlgorithms(Runnable algorithm1, Runnable algorithm2, int runs) {
            double time1 = measureAverageTime(algorithm1, runs);
            double time2 = measureAverageTime(algorithm2, runs);
            
            System.out.printf("算法1平均执行时间: %.2f ns%n", time1);
            System.out.printf("算法2平均执行时间: %.2f ns%n", time2);
            System.out.printf("性能比较: 算法%d更快，快%.2f倍%n", 
                time1 < time2 ? 1 : 2, 
                Math.max(time1, time2) / Math.min(time1, time2));
        }
    }
    
    /**
     * 复杂度验证工具
     */
    public static class ComplexityValidator {
        
        /**
         * 验证线性时间复杂度
         */
        public static void validateLinearTime(int[] sizes, Function<Integer, Long> algorithm) {
            System.out.println("验证线性时间复杂度 O(n):");
            for (int size : sizes) {
                long time = algorithm.apply(size);
                System.out.printf("n=%d, 时间=%d ns, 时间/n=%.2f%n", 
                    size, time, (double) time / size);
            }
        }
        
        /**
         * 验证平方时间复杂度
         */
        public static void validateQuadraticTime(int[] sizes, Function<Integer, Long> algorithm) {
            System.out.println("验证平方时间复杂度 O(n²):");
            for (int size : sizes) {
                long time = algorithm.apply(size);
                System.out.printf("n=%d, 时间=%d ns, 时间/n²=%.2f%n", 
                    size, time, (double) time / (size * size));
            }
        }
        
        /**
         * 验证对数时间复杂度
         */
        public static void validateLogarithmicTime(int[] sizes, Function<Integer, Long> algorithm) {
            System.out.println("验证对数时间复杂度 O(log n):");
            for (int size : sizes) {
                long time = algorithm.apply(size);
                double logN = Math.log(size) / Math.log(2);
                System.out.printf("n=%d, 时间=%d ns, 时间/log n=%.2f%n", 
                    size, time, (double) time / logN);
            }
        }
    }
    
    /**
     * 复杂度可视化工具
     */
    public static class ComplexityVisualizer {
        
        /**
         * 绘制复杂度增长曲线
         */
        public static void plotComplexityGrowth(int[] sizes, String[] algorithms, 
                                              Function<Integer, Long>[] algorithmFunctions) {
            System.out.println("复杂度增长对比:");
            System.out.printf("%-10s", "n");
            for (String algorithm : algorithms) {
                System.out.printf("%-15s", algorithm);
            }
            System.out.println();
            
            for (int size : sizes) {
                System.out.printf("%-10d", size);
                for (Function<Integer, Long> algorithm : algorithmFunctions) {
                    long time = algorithm.apply(size);
                    System.out.printf("%-15d", time);
                }
                System.out.println();
            }
        }
    }
}
```

## 测试代码

```java
/**
 * 复杂度分析测试类
 */
public class ComplexityTest {
    public static void main(String[] args) {
        System.out.println("=== 时间复杂度测试 ===");
        testTimeComplexity();
        
        System.out.println("\n=== 空间复杂度测试 ===");
        testSpaceComplexity();
        
        System.out.println("\n=== 性能比较测试 ===");
        testPerformanceComparison();
        
        System.out.println("\n=== 复杂度验证测试 ===");
        testComplexityValidation();
    }
    
    /**
     * 测试时间复杂度
     */
    public static void testTimeComplexity() {
        int[] testArray = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
        
        // O(1) 测试
        long time1 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            TimeComplexityExamples.getElement(testArray, 5);
        });
        System.out.println("O(1) 访问元素时间: " + time1 + " ns");
        
        // O(log n) 测试
        long time2 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            TimeComplexityExamples.binarySearch(testArray, 11);
        });
        System.out.println("O(log n) 二分查找时间: " + time2 + " ns");
        
        // O(n) 测试
        long time3 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            TimeComplexityExamples.linearSearch(testArray, 11);
        });
        System.out.println("O(n) 线性查找时间: " + time3 + " ns");
        
        // O(n²) 测试
        int[] bubbleArray = {5, 2, 8, 1, 9, 3, 7, 4, 6};
        long time4 = ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
            TimeComplexityExamples.bubbleSort(bubbleArray.clone());
        });
        System.out.println("O(n²) 冒泡排序时间: " + time4 + " ns");
    }
    
    /**
     * 测试空间复杂度
     */
    public static void testSpaceComplexity() {
        int[] testArray = {1, 2, 3, 4, 5};
        
        // O(1) 空间测试
        System.out.println("O(1) 空间 - 交换操作");
        SpaceComplexityExamples.swap(testArray, 0, 4);
        System.out.println("交换后: " + Arrays.toString(testArray));
        
        // O(n) 空间测试
        System.out.println("O(n) 空间 - 复制数组");
        int[] copy = SpaceComplexityExamples.copyArray(testArray);
        System.out.println("复制结果: " + Arrays.toString(copy));
        
        // O(1) 空间优化测试
        System.out.println("O(1) 空间 - 优化斐波那契");
        int fib = SpaceComplexityExamples.fibonacciOptimized(10);
        System.out.println("斐波那契第10项: " + fib);
    }
    
    /**
     * 测试性能比较
     */
    public static void testPerformanceComparison() {
        int[] testArray = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
        
        // 比较二分查找和线性查找
        ComplexityAnalyzer.PerformanceTest.compareAlgorithms(
            () -> TimeComplexityExamples.binarySearch(testArray, 11),
            () -> TimeComplexityExamples.linearSearch(testArray, 11),
            1000
        );
        
        // 比较递归和动态规划斐波那契
        ComplexityAnalyzer.PerformanceTest.compareAlgorithms(
            () -> TimeComplexityExamples.fibonacciDP(20),
            () -> SpaceComplexityExamples.fibonacciOptimized(20),
            100
        );
    }
    
    /**
     * 测试复杂度验证
     */
    public static void testComplexityValidation() {
        int[] sizes = {100, 200, 400, 800, 1600};
        
        // 验证线性时间复杂度
        ComplexityAnalyzer.ComplexityValidator.validateLinearTime(sizes, n -> {
            int[] arr = new int[n];
            Arrays.fill(arr, 1);
            return ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
                TimeComplexityExamples.sumArray(arr);
            });
        });
        
        // 验证平方时间复杂度
        ComplexityAnalyzer.ComplexityValidator.validateQuadraticTime(sizes, n -> {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = n - i;
            }
            return ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
                TimeComplexityExamples.bubbleSort(arr.clone());
            });
        });
        
        // 验证对数时间复杂度
        ComplexityAnalyzer.ComplexityValidator.validateLogarithmicTime(sizes, n -> {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = i;
            }
            return ComplexityAnalyzer.PerformanceTest.measureTime(() -> {
                TimeComplexityExamples.binarySearch(arr, n / 2);
            });
        });
    }
}
```
