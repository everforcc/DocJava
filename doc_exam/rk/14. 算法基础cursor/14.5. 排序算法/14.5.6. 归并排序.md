# 14.5.6. 归并排序

## 一、归并排序的基本概念

### 1. 定义
归并排序（Merge Sort）是一种基于分治策略的稳定排序算法。它将数组分成两半，分别对两半进行排序，然后将排序后的两半合并成一个有序数组。

### 2. 基本思想
- **分解**：将数组分成两个子数组
- **解决**：递归地对两个子数组进行排序
- **合并**：将两个已排序的子数组合并成一个有序数组

### 3. 核心特征
- **稳定排序**：相等元素的相对顺序不会改变
- **外部排序**：适合处理大量数据的外部排序
- **分治算法**：典型的分治算法应用
- **时间复杂度稳定**：最好、最坏、平均情况都是O(n log n)

## 二、算法步骤

### 1. 分治过程
```
function mergeSort(arr, left, right):
    if left < right:
        mid = (left + right) / 2
        mergeSort(arr, left, mid)      // 排序左半部分
        mergeSort(arr, mid+1, right)   // 排序右半部分
        merge(arr, left, mid, right)   // 合并两部分
```

### 2. 合并过程
```
function merge(arr, left, mid, right):
    // 创建临时数组
    leftArr = arr[left...mid]
    rightArr = arr[mid+1...right]
    
    i = 0, j = 0, k = left
    
    // 合并两个有序数组
    while i < leftArr.length and j < rightArr.length:
        if leftArr[i] <= rightArr[j]:
            arr[k] = leftArr[i]
            i++
        else:
            arr[k] = rightArr[j]
            j++
        k++
    
    // 复制剩余元素
    while i < leftArr.length:
        arr[k] = leftArr[i]
        i++, k++
    
    while j < rightArr.length:
        arr[k] = rightArr[j]
        j++, k++
```

## 三、复杂度分析

### 1. 时间复杂度
- **最好情况**：O(n log n)
- **最坏情况**：O(n log n)
- **平均情况**：O(n log n)

**分析**：
- 分解：每次将数组分成两半，共需log n层
- 合并：每层需要O(n)时间来合并所有子数组
- 总时间：O(n log n)

### 2. 空间复杂度
- **辅助空间**：O(n) - 需要临时数组存储合并结果
- **递归栈空间**：O(log n) - 递归调用栈的深度

### 3. 递推关系
```
T(n) = 2T(n/2) + O(n)
```
根据主定理，T(n) = O(n log n)

## 四、归并排序的优点

### 1. 稳定性
归并排序是稳定的，相等元素的相对顺序保持不变。

### 2. 时间复杂度稳定
无论输入数据的初始状态如何，时间复杂度都是O(n log n)。

### 3. 适合外部排序
由于其访问数据的方式是顺序的，非常适合处理大文件的外部排序。

### 4. 并行性好
分治的特性使得归并排序很容易并行化。

## 五、归并排序的缺点

### 1. 空间复杂度高
需要O(n)的额外空间，对内存要求较高。

### 2. 常数因子较大
虽然时间复杂度是O(n log n)，但常数因子比快速排序大。

### 3. 不是原地排序
需要额外的存储空间来存储临时结果。

## 六、归并排序的优化

### 1. 原地归并排序
通过巧妙的技巧实现原地合并，减少空间使用。

### 2. 自底向上归并排序
避免递归调用，使用迭代方式实现。

### 3. 小数组优化
对于小规模数组，切换到插入排序等简单算法。

### 4. 三路归并
将数组分成三部分而不是两部分，可以减少递归深度。

## 七、归并排序的变种

### 1. 自底向上归并排序
```
function bottomUpMergeSort(arr):
    n = arr.length
    size = 1
    
    while size < n:
        left = 0
        while left < n - 1:
            mid = min(left + size - 1, n - 1)
            right = min(left + size * 2 - 1, n - 1)
            
            if mid < right:
                merge(arr, left, mid, right)
            
            left += size * 2
        size *= 2
```

### 2. 原地归并排序
通过旋转等操作实现原地合并，但时间复杂度会增加到O(n log² n)。

### 3. 多路归并
同时合并k个有序序列，常用于外部排序。

### 4. 并行归并排序
利用多核处理器并行处理不同的子数组。

## 八、外部排序应用

### 1. 基本思想
当数据量太大无法全部加载到内存时，使用外部排序：
1. 将大文件分成多个小文件
2. 分别对小文件进行内部排序
3. 使用多路归并将小文件合并成大文件

### 2. K路归并
```
function kWayMerge(files):
    heap = MinHeap()
    
    // 初始化堆
    for each file in files:
        if file is not empty:
            heap.insert((file.readNext(), file))
    
    result = []
    while heap is not empty:
        (value, file) = heap.extractMin()
        result.append(value)
        
        if file is not empty:
            heap.insert((file.readNext(), file))
    
    return result
```

## 九、与其他排序算法的比较

| 算法 | 时间复杂度(平均) | 时间复杂度(最坏) | 空间复杂度 | 稳定性 | 原地排序 |
|------|------------------|------------------|------------|---------|----------|
| 归并排序 | O(n log n) | O(n log n) | O(n) | 稳定 | 否 |
| 快速排序 | O(n log n) | O(n²) | O(log n) | 不稳定 | 是 |
| 堆排序 | O(n log n) | O(n log n) | O(1) | 不稳定 | 是 |
| 插入排序 | O(n²) | O(n²) | O(1) | 稳定 | 是 |

## 十、实际应用场景

### 1. 需要稳定排序的场景
当需要保持相等元素的相对顺序时，归并排序是理想选择。

### 2. 外部排序
处理大文件或数据库排序时，归并排序是首选算法。

### 3. 链表排序
归并排序非常适合对链表进行排序，可以达到O(1)的空间复杂度。

### 4. 并行计算
在多核系统中，归并排序可以很好地并行化。

## 十一、链表归并排序

### 1. 优势
- 不需要额外的数组空间
- 可以达到O(1)的空间复杂度
- 天然适合链表的操作方式

### 2. 实现要点
- 使用快慢指针找到链表中点
- 递归排序两个子链表
- 合并两个有序链表

## 十二、并行归并排序

### 1. 并行策略
- 将数组分成多个部分，并行排序
- 使用多线程处理不同的子数组
- 最后合并所有已排序的部分

### 2. 性能分析
- 理论上可以达到O(log² n)的时间复杂度
- 实际性能取决于处理器核心数和任务调度

## 十三、实现技巧

### 1. 边界条件处理
- 正确处理数组为空或只有一个元素的情况
- 注意数组索引的边界检查

### 2. 内存管理
- 合理分配和释放临时数组
- 考虑内存对齐和缓存友好性

### 3. 递归优化
- 避免不必要的递归调用
- 考虑尾递归优化

## 十四、常见错误

### 1. 边界错误
- 数组索引越界
- 合并时的边界条件处理错误

### 2. 内存泄漏
- 忘记释放临时分配的内存
- 重复分配内存导致内存浪费

### 3. 稳定性破坏
- 在合并过程中错误地改变相等元素的顺序

## 十五、总结

归并排序是一种优秀的排序算法，具有以下特点：

### 1. 核心优势
- 稳定的O(n log n)时间复杂度
- 算法稳定，适用性广
- 容易理解和实现
- 适合外部排序和并行处理

### 2. 主要局限
- 需要额外的O(n)空间
- 常数因子相对较大
- 不是原地排序算法

### 3. 学习要点
- 理解分治思想的应用
- 掌握合并操作的实现
- 了解各种优化技巧
- 学会分析递归算法的复杂度

### 4. 实践建议
- 实现基本的归并排序算法
- 尝试自底向上的迭代版本
- 练习链表的归并排序
- 了解外部排序的应用

归并排序是分治算法的经典应用，不仅在排序领域有重要地位，其思想还广泛应用于其他算法设计中。深入理解归并排序有助于培养分治思维和递归分析能力。
