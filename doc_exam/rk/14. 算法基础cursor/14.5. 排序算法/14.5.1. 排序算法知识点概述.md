# 14.5.1. 排序算法知识点概述

## 概述
排序算法是计算机科学中的基础算法之一，用于将数据集合按照特定顺序重新排列。排序算法的效率直接影响程序的性能，因此选择合适的排序算法对于提高程序效率具有重要意义。

## 排序算法的基本概念

### 定义
排序算法是将数据集合按照特定规则重新排列的算法。

### 基本术语
- **排序表**：被排序的数据集合
- **关键字**：用于排序的数据项
- **稳定排序**：相等元素的相对位置在排序前后保持不变
- **不稳定排序**：相等元素的相对位置在排序前后可能改变
- **原地排序**：排序过程中只需要常数个额外空间
- **非原地排序**：排序过程中需要额外的存储空间

### 排序算法的分类
根据不同的标准，排序算法可以分为：

#### 1. 按时间复杂度分类
- **O(n²)算法**：冒泡排序、选择排序、插入排序
- **O(n log n)算法**：快速排序、归并排序、堆排序
- **O(n)算法**：计数排序、基数排序、桶排序

#### 2. 按稳定性分类
- **稳定排序**：冒泡排序、插入排序、归并排序、计数排序、基数排序
- **不稳定排序**：选择排序、快速排序、堆排序

#### 3. 按存储方式分类
- **原地排序**：冒泡排序、选择排序、插入排序、快速排序、堆排序
- **非原地排序**：归并排序、计数排序、基数排序、桶排序

## 简单排序算法

### 1. 冒泡排序（Bubble Sort）

#### 基本思想
通过相邻元素的比较和交换，将较大的元素逐步"冒泡"到数组的末尾。

#### 算法步骤
1. 比较相邻的元素，如果第一个比第二个大，就交换它们
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对
3. 重复步骤1-2，直到没有需要交换的元素

#### 时间复杂度
- **最好情况**：O(n) - 数组已经有序
- **最坏情况**：O(n²) - 数组逆序
- **平均情况**：O(n²)

#### 空间复杂度
O(1) - 原地排序

#### 稳定性
稳定排序

#### 优化方法
- 设置标志位，如果一轮比较中没有发生交换，说明数组已经有序
- 记录最后一次交换的位置，下一轮只需要比较到这个位置

### 2. 选择排序（Selection Sort）

#### 基本思想
每次从未排序的部分中选择最小（或最大）的元素，放到已排序部分的末尾。

#### 算法步骤
1. 在未排序序列中找到最小（大）元素
2. 存放到排序序列的起始位置
3. 从剩余未排序元素中继续寻找最小（大）元素
4. 放到已排序序列的末尾
5. 重复步骤3-4，直到所有元素均排序完毕

#### 时间复杂度
- **最好情况**：O(n²)
- **最坏情况**：O(n²)
- **平均情况**：O(n²)

#### 空间复杂度
O(1) - 原地排序

#### 稳定性
不稳定排序

#### 特点
- 比较次数固定，与输入数据无关
- 交换次数最少，适合交换成本高的场景

### 3. 插入排序（Insertion Sort）

#### 基本思想
将数组分为已排序和未排序两部分，每次从未排序部分取出一个元素，插入到已排序部分的正确位置。

#### 算法步骤
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2-5

#### 时间复杂度
- **最好情况**：O(n) - 数组已经有序
- **最坏情况**：O(n²) - 数组逆序
- **平均情况**：O(n²)

#### 空间复杂度
O(1) - 原地排序

#### 稳定性
稳定排序

#### 特点
- 对于小规模数据效率很高
- 对于基本有序的数据效率很高
- 是其他高级排序算法的基础

## 高级排序算法

### 1. 快速排序（Quick Sort）

#### 基本思想
选择一个基准元素，通过一趟排序将数组分为两部分，一部分小于基准，一部分大于基准，然后递归地对两部分进行排序。

#### 算法步骤
1. 选择一个基准元素
2. 将数组分为两部分：小于基准的元素和大于基准的元素
3. 递归地对两部分进行快速排序
4. 合并结果

#### 时间复杂度
- **最好情况**：O(n log n) - 每次划分都平衡
- **最坏情况**：O(n²) - 每次划分都不平衡
- **平均情况**：O(n log n)

#### 空间复杂度
- **最好情况**：O(log n) - 递归栈空间
- **最坏情况**：O(n) - 递归栈空间

#### 稳定性
不稳定排序

#### 优化方法
- 三数取中法选择基准
- 小数组使用插入排序
- 三路快排处理重复元素

### 2. 归并排序（Merge Sort）

#### 基本思想
将数组递归地分成两半，分别排序，然后合并两个有序数组。

#### 算法步骤
1. 将数组分成两半
2. 递归地对两半进行归并排序
3. 合并两个有序数组

#### 时间复杂度
- **最好情况**：O(n log n)
- **最坏情况**：O(n log n)
- **平均情况**：O(n log n)

#### 空间复杂度
O(n) - 需要额外的存储空间

#### 稳定性
稳定排序

#### 特点
- 时间复杂度稳定
- 适合外部排序
- 可以并行化

### 3. 堆排序（Heap Sort）

#### 基本思想
利用堆的性质，每次取出堆顶元素（最大或最小），然后重新调整堆。

#### 算法步骤
1. 构建最大堆（或最小堆）
2. 将堆顶元素与最后一个元素交换
3. 减少堆的大小，重新调整堆
4. 重复步骤2-3，直到堆的大小为1

#### 时间复杂度
- **最好情况**：O(n log n)
- **最坏情况**：O(n log n)
- **平均情况**：O(n log n)

#### 空间复杂度
O(1) - 原地排序

#### 稳定性
不稳定排序

#### 特点
- 时间复杂度稳定
- 原地排序
- 适合优先级队列

## 线性时间排序算法

### 1. 计数排序（Counting Sort）

#### 基本思想
统计每个值的出现次数，然后根据统计结果重新排列数组。

#### 适用条件
- 数据范围较小
- 数据是整数
- 数据重复较多

#### 时间复杂度
O(n + k)，其中k是数据范围

#### 空间复杂度
O(k)

#### 稳定性
稳定排序

### 2. 基数排序（Radix Sort）

#### 基本思想
按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。

#### 适用条件
- 数据是整数
- 数据位数相对固定
- 数据范围较大

#### 时间复杂度
O(d(n + k))，其中d是位数，k是基数

#### 空间复杂度
O(n + k)

#### 稳定性
稳定排序

### 3. 桶排序（Bucket Sort）

#### 基本思想
将数据分到有限数量的桶里，每个桶再分别排序。

#### 适用条件
- 数据分布均匀
- 数据范围已知
- 数据是浮点数

#### 时间复杂度
- **最好情况**：O(n)
- **最坏情况**：O(n²)
- **平均情况**：O(n + k)

#### 空间复杂度
O(n + k)

#### 稳定性
稳定排序

## 排序算法的比较

### 时间复杂度比较
| 算法 | 最好情况 | 平均情况 | 最坏情况 |
|------|----------|----------|----------|
| 冒泡排序 | O(n) | O(n²) | O(n²) |
| 选择排序 | O(n²) | O(n²) | O(n²) |
| 插入排序 | O(n) | O(n²) | O(n²) |
| 快速排序 | O(n log n) | O(n log n) | O(n²) |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) |
| 堆排序 | O(n log n) | O(n log n) | O(n log n) |
| 计数排序 | O(n + k) | O(n + k) | O(n + k) |
| 基数排序 | O(d(n + k)) | O(d(n + k)) | O(d(n + k)) |

### 空间复杂度比较
| 算法 | 空间复杂度 | 特点 |
|------|------------|------|
| 冒泡排序 | O(1) | 原地排序 |
| 选择排序 | O(1) | 原地排序 |
| 插入排序 | O(1) | 原地排序 |
| 快速排序 | O(log n) | 递归栈空间 |
| 归并排序 | O(n) | 需要额外空间 |
| 堆排序 | O(1) | 原地排序 |
| 计数排序 | O(k) | 需要计数数组 |
| 基数排序 | O(n + k) | 需要临时数组 |

### 稳定性比较
| 算法 | 稳定性 | 说明 |
|------|--------|------|
| 冒泡排序 | 稳定 | 相等元素不会交换 |
| 选择排序 | 不稳定 | 可能改变相等元素的相对位置 |
| 插入排序 | 稳定 | 相等元素不会交换 |
| 快速排序 | 不稳定 | 分区过程可能改变相对位置 |
| 归并排序 | 稳定 | 合并过程保持相对位置 |
| 堆排序 | 不稳定 | 堆调整过程可能改变相对位置 |
| 计数排序 | 稳定 | 按顺序输出 |
| 基数排序 | 稳定 | 每轮排序都是稳定的 |

## 排序算法的选择原则

### 1. 根据数据规模选择
- **小规模数据（n < 50）**：插入排序
- **中等规模数据（50 ≤ n < 1000）**：快速排序、归并排序
- **大规模数据（n ≥ 1000）**：快速排序、归并排序、堆排序

### 2. 根据数据特征选择
- **基本有序**：插入排序、冒泡排序
- **完全逆序**：快速排序、归并排序
- **重复元素多**：计数排序、基数排序
- **数据范围小**：计数排序
- **数据范围大**：快速排序、归并排序

### 3. 根据稳定性要求选择
- **需要稳定排序**：归并排序、插入排序、冒泡排序
- **不需要稳定排序**：快速排序、堆排序、选择排序

### 4. 根据空间限制选择
- **空间受限**：堆排序、快速排序、插入排序
- **空间充足**：归并排序、计数排序、基数排序

## 排序算法的优化

### 1. 算法优化
- 混合排序：结合多种排序算法的优点
- 自适应排序：根据数据特征调整算法
- 并行排序：利用多核处理器

### 2. 实现优化
- 减少比较次数
- 减少交换次数
- 优化内存访问模式

### 3. 系统优化
- 缓存友好
- 分支预测优化
- 指令级并行

## 学习重点

### 1. 理论基础
- 理解各种排序算法的原理
- 掌握算法的时间复杂度分析
- 了解算法的适用场景

### 2. 实现技能
- 能够实现基本的排序算法
- 掌握算法的优化方法
- 理解算法的边界条件

### 3. 应用能力
- 能够根据问题选择合适的算法
- 掌握算法在实际中的应用
- 理解算法与其他技术的结合

## 总结
排序算法是计算机科学的基础，掌握各种排序算法的原理、实现和应用，对于提高编程能力和解决实际问题具有重要意义。不同的排序算法适用于不同的场景，在实际应用中需要根据具体需求选择合适的算法。理解算法的时间复杂度、空间复杂度和稳定性，有助于设计高效的解决方案。
