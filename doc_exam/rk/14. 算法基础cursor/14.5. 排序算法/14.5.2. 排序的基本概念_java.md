# 14.5.2. 排序的基本概念 - Java代码示例

## 一、排序接口和比较器

```java
import java.util.*;

/**
 * 排序的基本概念演示
 */
public class SortingBasics {
    
    /**
     * 通用排序接口
     */
    public interface Sorter<T extends Comparable<T>> {
        void sort(T[] array);
    }
    
    /**
     * 带比较器的排序接口
     */
    public interface ComparatorSorter<T> {
        void sort(T[] array, Comparator<T> comparator);
    }
    
    /**
     * 学生类 - 演示自定义对象排序
     */
    static class Student implements Comparable<Student> {
        private String name;
        private int age;
        private double score;
        
        public Student(String name, int age, double score) {
            this.name = name;
            this.age = age;
            this.score = score;
        }
        
        @Override
        public int compareTo(Student other) {
            // 按分数降序排序
            return Double.compare(other.score, this.score);
        }
        
        @Override
        public String toString() {
            return String.format("%s(age=%d, score=%.1f)", name, age, score);
        }
        
        // Getter方法
        public String getName() { return name; }
        public int getAge() { return age; }
        public double getScore() { return score; }
    }
    
    /**
     * 排序稳定性测试
     */
    public static void testStability() {
        System.out.println("排序稳定性测试:");
        System.out.println("================");
        
        Student[] students = {
            new Student("Alice", 20, 85.0),
            new Student("Bob", 22, 90.0),
            new Student("Charlie", 21, 85.0),
            new Student("David", 23, 90.0),
            new Student("Eve", 20, 85.0)
        };
        
        System.out.println("原始顺序:");
        printArray(students);
        
        // 测试稳定排序（按分数排序）
        Student[] stableSort = students.clone();
        Arrays.sort(stableSort, Comparator.comparingDouble(Student::getScore).reversed());
        
        System.out.println("\n稳定排序后（按分数降序）:");
        printArray(stableSort);
        
        // 验证稳定性：相同分数的学生保持原有顺序
        System.out.println("\n稳定性验证：相同分数的学生保持原有顺序");
    }
    
    /**
     * 多关键字排序演示
     */
    public static void testMultiKeySort() {
        System.out.println("\n多关键字排序测试:");
        System.out.println("==================");
        
        Student[] students = {
            new Student("Alice", 20, 85.0),
            new Student("Bob", 22, 90.0),
            new Student("Charlie", 20, 85.0),
            new Student("David", 22, 85.0)
        };
        
        System.out.println("原始数据:");
        printArray(students);
        
        // 先按年龄升序，再按分数降序
        Arrays.sort(students, 
            Comparator.comparingInt(Student::getAge)
                     .thenComparing(Student::getScore, Comparator.reverseOrder()));
        
        System.out.println("\n多关键字排序后（年龄升序，分数降序）:");
        printArray(students);
    }
    
    private static <T> void printArray(T[] array) {
        for (T item : array) {
            System.out.println(item);
        }
    }
}
```

## 二、排序算法性能测试框架

```java
/**
 * 排序算法性能测试框架
 */
public class SortingPerformanceTest {
    
    /**
     * 排序算法测试接口
     */
    @FunctionalInterface
    public interface SortingAlgorithm {
        void sort(int[] array);
    }
    
    /**
     * 测试数据生成器
     */
    public static class TestDataGenerator {
        private static final Random random = new Random();
        
        /**
         * 生成随机数组
         */
        public static int[] generateRandomArray(int size) {
            int[] arr = new int[size];
            for (int i = 0; i < size; i++) {
                arr[i] = random.nextInt(size * 10);
            }
            return arr;
        }
        
        /**
         * 生成有序数组
         */
        public static int[] generateSortedArray(int size) {
            int[] arr = new int[size];
            for (int i = 0; i < size; i++) {
                arr[i] = i;
            }
            return arr;
        }
        
        /**
         * 生成逆序数组
         */
        public static int[] generateReverseSortedArray(int size) {
            int[] arr = new int[size];
            for (int i = 0; i < size; i++) {
                arr[i] = size - i;
            }
            return arr;
        }
        
        /**
         * 生成基本有序数组
         */
        public static int[] generateNearlySortedArray(int size, double disorder) {
            int[] arr = generateSortedArray(size);
            
            int swapCount = (int) (size * disorder);
            for (int i = 0; i < swapCount; i++) {
                int index1 = random.nextInt(size);
                int index2 = random.nextInt(size);
                
                int temp = arr[index1];
                arr[index1] = arr[index2];
                arr[index2] = temp;
            }
            
            return arr;
        }
        
        /**
         * 生成重复元素较多的数组
         */
        public static int[] generateArrayWithDuplicates(int size, int uniqueCount) {
            int[] arr = new int[size];
            for (int i = 0; i < size; i++) {
                arr[i] = random.nextInt(uniqueCount);
            }
            return arr;
        }
    }
    
    /**
     * 性能测试方法
     */
    public static void testAlgorithmPerformance(String algorithmName, 
                                               SortingAlgorithm algorithm,
                                               int[] testData) {
        int[] data = testData.clone();
        
        long startTime = System.nanoTime();
        algorithm.sort(data);
        long endTime = System.nanoTime();
        
        long duration = endTime - startTime;
        
        // 验证排序结果
        boolean isCorrect = isSorted(data);
        
        System.out.printf("%-20s: %10d ns (%6.2f ms) - %s\n", 
                         algorithmName, duration, duration / 1_000_000.0,
                         isCorrect ? "正确" : "错误");
    }
    
    /**
     * 检查数组是否已排序
     */
    public static boolean isSorted(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] < arr[i-1]) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * 比较两个数组是否相等（用于验证稳定性）
     */
    public static boolean arraysEqual(Object[] arr1, Object[] arr2) {
        if (arr1.length != arr2.length) {
            return false;
        }
        
        for (int i = 0; i < arr1.length; i++) {
            if (!arr1[i].equals(arr2[i])) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * 综合性能测试
     */
    public static void comprehensiveTest() {
        int[] sizes = {1000, 5000, 10000};
        String[] dataTypes = {"随机数据", "有序数据", "逆序数据", "基本有序", "重复较多"};
        
        for (int size : sizes) {
            System.out.println("\n数据规模: " + size);
            System.out.println("===================");
            
            for (String dataType : dataTypes) {
                System.out.println("\n" + dataType + ":");
                System.out.println("-------------------");
                
                int[] testData = generateTestData(size, dataType);
                
                // 测试Java内置排序
                testAlgorithmPerformance("Java Arrays.sort", 
                    arr -> Arrays.sort(arr), testData);
                
                // 可以添加其他排序算法的测试
                testAlgorithmPerformance("插入排序", 
                    SortingBasics::insertionSort, testData);
            }
        }
    }
    
    /**
     * 根据类型生成测试数据
     */
    private static int[] generateTestData(int size, String type) {
        switch (type) {
            case "随机数据":
                return TestDataGenerator.generateRandomArray(size);
            case "有序数据":
                return TestDataGenerator.generateSortedArray(size);
            case "逆序数据":
                return TestDataGenerator.generateReverseSortedArray(size);
            case "基本有序":
                return TestDataGenerator.generateNearlySortedArray(size, 0.1);
            case "重复较多":
                return TestDataGenerator.generateArrayWithDuplicates(size, size / 10);
            default:
                return TestDataGenerator.generateRandomArray(size);
        }
    }
    
    /**
     * 简单插入排序实现（用于性能对比）
     */
    private static void insertionSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int key = arr[i];
            int j = i - 1;
            
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
}
```

## 三、排序算法分析工具

```java
/**
 * 排序算法分析工具
 */
public class SortingAnalysisTools {
    
    /**
     * 比较次数统计器
     */
    public static class ComparisonCounter {
        private long comparisons = 0;
        
        public int compare(int a, int b) {
            comparisons++;
            return Integer.compare(a, b);
        }
        
        public long getComparisons() {
            return comparisons;
        }
        
        public void reset() {
            comparisons = 0;
        }
    }
    
    /**
     * 交换次数统计器
     */
    public static class SwapCounter {
        private long swaps = 0;
        
        public void swap(int[] arr, int i, int j) {
            if (i != j) {
                swaps++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        
        public long getSwaps() {
            return swaps;
        }
        
        public void reset() {
            swaps = 0;
        }
    }
    
    /**
     * 带统计功能的冒泡排序
     */
    public static void bubbleSortWithStats(int[] arr, ComparisonCounter cc, SwapCounter sc) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            
            for (int j = 0; j < n - i - 1; j++) {
                if (cc.compare(arr[j], arr[j + 1]) > 0) {
                    sc.swap(arr, j, j + 1);
                    swapped = true;
                }
            }
            
            if (!swapped) {
                break; // 数组已经有序
            }
        }
    }
    
    /**
     * 算法复杂度分析
     */
    public static void analyzeComplexity() {
        System.out.println("算法复杂度分析:");
        System.out.println("================");
        
        int[] sizes = {100, 200, 400, 800};
        
        for (int size : sizes) {
            int[] randomData = SortingPerformanceTest.TestDataGenerator.generateRandomArray(size);
            int[] sortedData = SortingPerformanceTest.TestDataGenerator.generateSortedArray(size);
            int[] reverseData = SortingPerformanceTest.TestDataGenerator.generateReverseSortedArray(size);
            
            System.out.println("\n数组大小: " + size);
            System.out.println("-------------------");
            
            // 测试随机数据
            testWithStats("随机数据", randomData.clone());
            
            // 测试有序数据
            testWithStats("有序数据", sortedData.clone());
            
            // 测试逆序数据
            testWithStats("逆序数据", reverseData.clone());
        }
    }
    
    private static void testWithStats(String dataType, int[] data) {
        ComparisonCounter cc = new ComparisonCounter();
        SwapCounter sc = new SwapCounter();
        
        long startTime = System.nanoTime();
        bubbleSortWithStats(data, cc, sc);
        long endTime = System.nanoTime();
        
        System.out.printf("%-10s - 比较: %6d, 交换: %6d, 时间: %8d ns\n",
                         dataType, cc.getComparisons(), sc.getSwaps(), endTime - startTime);
    }
}
```

## 四、排序算法验证工具

```java
/**
 * 排序算法正确性验证工具
 */
public class SortingVerificationTools {
    
    /**
     * 验证排序结果的正确性
     */
    public static boolean verifySortedArray(int[] original, int[] sorted) {
        // 检查长度
        if (original.length != sorted.length) {
            return false;
        }
        
        // 检查是否有序
        for (int i = 1; i < sorted.length; i++) {
            if (sorted[i] < sorted[i-1]) {
                return false;
            }
        }
        
        // 检查元素是否完整（排序后的数组应该包含原数组的所有元素）
        int[] originalCopy = original.clone();
        int[] sortedCopy = sorted.clone();
        
        Arrays.sort(originalCopy);
        Arrays.sort(sortedCopy);
        
        return Arrays.equals(originalCopy, sortedCopy);
    }
    
    /**
     * 验证稳定排序的稳定性
     */
    public static boolean verifyStability(SortingBasics.Student[] original, 
                                         SortingBasics.Student[] sorted) {
        // 找到所有相等分数的学生组
        Map<Double, List<SortingBasics.Student>> originalGroups = new HashMap<>();
        Map<Double, List<SortingBasics.Student>> sortedGroups = new HashMap<>();
        
        // 按分数分组
        for (SortingBasics.Student student : original) {
            originalGroups.computeIfAbsent(student.getScore(), k -> new ArrayList<>()).add(student);
        }
        
        for (SortingBasics.Student student : sorted) {
            sortedGroups.computeIfAbsent(student.getScore(), k -> new ArrayList<>()).add(student);
        }
        
        // 检查每组内的顺序是否保持
        for (Double score : originalGroups.keySet()) {
            List<SortingBasics.Student> originalGroup = originalGroups.get(score);
            List<SortingBasics.Student> sortedGroup = sortedGroups.get(score);
            
            if (originalGroup.size() != sortedGroup.size()) {
                return false;
            }
            
            // 检查相对顺序
            for (int i = 0; i < originalGroup.size(); i++) {
                if (!originalGroup.get(i).getName().equals(sortedGroup.get(i).getName())) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    /**
     * 随机测试生成器
     */
    public static void randomTest(SortingPerformanceTest.SortingAlgorithm algorithm, 
                                 int testCount, int arraySize) {
        System.out.println("随机测试 - " + testCount + " 次测试，数组大小: " + arraySize);
        
        int passCount = 0;
        
        for (int i = 0; i < testCount; i++) {
            int[] original = SortingPerformanceTest.TestDataGenerator.generateRandomArray(arraySize);
            int[] toSort = original.clone();
            
            try {
                algorithm.sort(toSort);
                
                if (verifySortedArray(original, toSort)) {
                    passCount++;
                } else {
                    System.out.println("测试 " + (i+1) + " 失败：排序结果不正确");
                }
            } catch (Exception e) {
                System.out.println("测试 " + (i+1) + " 失败：" + e.getMessage());
            }
        }
        
        System.out.println("通过率: " + passCount + "/" + testCount + 
                          " (" + (100.0 * passCount / testCount) + "%)");
    }
}
```

## 五、综合测试类

```java
/**
 * 排序基本概念综合测试
 */
public class SortingConceptsTest {
    
    public static void main(String[] args) {
        System.out.println("排序的基本概念 - Java代码演示");
        System.out.println("============================");
        
        // 测试基本排序功能
        testBasicSorting();
        
        // 测试稳定性
        SortingBasics.testStability();
        
        // 测试多关键字排序
        SortingBasics.testMultiKeySort();
        
        // 性能分析
        SortingAnalysisTools.analyzeComplexity();
        
        // 随机测试
        testRandomVerification();
    }
    
    public static void testBasicSorting() {
        System.out.println("1. 基本排序测试:");
        System.out.println("------------------");
        
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("原始数组: " + Arrays.toString(arr));
        
        // 使用Java内置排序
        int[] sorted = arr.clone();
        Arrays.sort(sorted);
        System.out.println("排序后: " + Arrays.toString(sorted));
        
        // 验证排序结果
        boolean isCorrect = SortingVerificationTools.verifySortedArray(arr, sorted);
        System.out.println("排序正确性: " + (isCorrect ? "正确" : "错误"));
    }
    
    public static void testRandomVerification() {
        System.out.println("\n随机验证测试:");
        System.out.println("================");
        
        // 测试Java内置排序的正确性
        SortingVerificationTools.randomTest(
            arr -> Arrays.sort(arr), 
            1000, 100
        );
    }
}
```

## 六、学习要点

1. **理解排序概念**：掌握排序的定义、分类和基本性质
2. **掌握性能指标**：时间复杂度、空间复杂度、稳定性等
3. **学会算法比较**：不同算法的优缺点和适用场景
4. **实现验证工具**：正确性验证、性能测试、稳定性检查
5. **实际应用考虑**：数据特征、系统要求、实现复杂度
6. **发展趋势了解**：现代排序算法的发展和优化方向
