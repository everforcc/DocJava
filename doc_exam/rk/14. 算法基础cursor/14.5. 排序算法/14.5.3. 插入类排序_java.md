# 14.5.3. 插入类排序 - Java代码示例

## 一、直接插入排序

```java
/**
 * 直接插入排序实现
 */
public class InsertionSort {
    
    /**
     * 基本插入排序
     * @param arr 待排序数组
     */
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];  // 待插入的元素
            int j = i - 1;
            
            // 将大于key的元素向后移动
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;  // 插入元素到正确位置
        }
    }
    
    /**
     * 插入排序 - 优化版本（减少交换次数）
     */
    public static void insertionSortOptimized(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            
            // 寻找插入位置
            while (j >= 0 && arr[j] > key) {
                j--;
            }
            
            // 批量移动元素
            if (j + 1 != i) {
                System.arraycopy(arr, j + 1, arr, j + 2, i - j - 1);
                arr[j + 1] = key;
            }
        }
    }
    
    /**
     * 带哨兵的插入排序
     */
    public static void insertionSortWithSentinel(int[] arr) {
        int n = arr.length;
        if (n <= 1) return;
        
        // 找到最小值作为哨兵
        int minIndex = 0;
        for (int i = 1; i < n; i++) {
            if (arr[i] < arr[minIndex]) {
                minIndex = i;
            }
        }
        
        // 将最小值交换到第一位作为哨兵
        if (minIndex != 0) {
            int temp = arr[0];
            arr[0] = arr[minIndex];
            arr[minIndex] = temp;
        }
        
        // 插入排序（无需边界检查）
        for (int i = 2; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            
            while (arr[j] > key) {  // 无需检查 j >= 0
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    /**
     * 递归版本的插入排序
     */
    public static void insertionSortRecursive(int[] arr, int n) {
        if (n <= 1) return;
        
        // 递归排序前n-1个元素
        insertionSortRecursive(arr, n - 1);
        
        // 将第n个元素插入到正确位置
        int key = arr[n - 1];
        int j = n - 2;
        
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = key;
    }
}
```

## 二、二分插入排序

```java
/**
 * 二分插入排序实现
 */
public class BinaryInsertionSort {
    
    /**
     * 二分插入排序
     * 使用二分查找确定插入位置，减少比较次数
     */
    public static void binaryInsertionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            
            // 使用二分查找找到插入位置
            int insertPos = binarySearch(arr, 0, i - 1, key);
            
            // 移动元素
            for (int j = i - 1; j >= insertPos; j--) {
                arr[j + 1] = arr[j];
            }
            
            // 插入元素
            arr[insertPos] = key;
        }
    }
    
    /**
     * 二分查找插入位置
     * @param arr 数组
     * @param left 左边界
     * @param right 右边界
     * @param key 待插入元素
     * @return 插入位置
     */
    private static int binarySearch(int[] arr, int left, int right, int key) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] <= key) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return left;
    }
    
    /**
     * 使用Java内置的二分查找
     */
    public static void binaryInsertionSortBuiltIn(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            
            // 使用Arrays.binarySearch找到插入位置
            int insertPos = java.util.Arrays.binarySearch(arr, 0, i, key);
            if (insertPos < 0) {
                insertPos = -(insertPos + 1);
            }
            
            // 移动元素并插入
            System.arraycopy(arr, insertPos, arr, insertPos + 1, i - insertPos);
            arr[insertPos] = key;
        }
    }
}
```

## 三、希尔排序

```java
/**
 * 希尔排序实现
 */
public class ShellSort {
    
    /**
     * 希尔排序 - 使用Shell增量序列
     */
    public static void shellSort(int[] arr) {
        int n = arr.length;
        
        // Shell增量序列：n/2, n/4, ..., 1
        for (int gap = n / 2; gap > 0; gap /= 2) {
            // 对每个子序列进行插入排序
            for (int i = gap; i < n; i++) {
                int key = arr[i];
                int j = i - gap;
                
                while (j >= 0 && arr[j] > key) {
                    arr[j + gap] = arr[j];
                    j -= gap;
                }
                
                arr[j + gap] = key;
            }
        }
    }
    
    /**
     * 希尔排序 - 使用Knuth增量序列
     * 增量序列：1, 4, 13, 40, 121, ...
     * 公式：h = 3*h + 1
     */
    public static void shellSortKnuth(int[] arr) {
        int n = arr.length;
        
        // 计算最大的Knuth增量
        int h = 1;
        while (h < n / 3) {
            h = 3 * h + 1;
        }
        
        while (h >= 1) {
            // 对每个子序列进行插入排序
            for (int i = h; i < n; i++) {
                int key = arr[i];
                int j = i - h;
                
                while (j >= 0 && arr[j] > key) {
                    arr[j + h] = arr[j];
                    j -= h;
                }
                
                arr[j + h] = key;
            }
            
            h /= 3;  // 下一个增量
        }
    }
    
    /**
     * 希尔排序 - 使用Hibbard增量序列
     * 增量序列：1, 3, 7, 15, 31, ...
     * 公式：h = 2^k - 1
     */
    public static void shellSortHibbard(int[] arr) {
        int n = arr.length;
        
        // 计算最大的Hibbard增量
        int h = 1;
        while (h < n) {
            h = h * 2 + 1;
        }
        h /= 2;
        
        while (h >= 1) {
            // 对每个子序列进行插入排序
            for (int i = h; i < n; i++) {
                int key = arr[i];
                int j = i - h;
                
                while (j >= 0 && arr[j] > key) {
                    arr[j + h] = arr[j];
                    j -= h;
                }
                
                arr[j + h] = key;
            }
            
            h = (h - 1) / 2;  // 下一个增量
        }
    }
    
    /**
     * 希尔排序 - 使用Sedgewick增量序列
     * 增量序列：1, 5, 19, 41, 109, ...
     */
    public static void shellSortSedgewick(int[] arr) {
        int n = arr.length;
        
        // Sedgewick增量序列
        int[] gaps = generateSedgewickGaps(n);
        
        for (int gap : gaps) {
            // 对每个子序列进行插入排序
            for (int i = gap; i < n; i++) {
                int key = arr[i];
                int j = i - gap;
                
                while (j >= 0 && arr[j] > key) {
                    arr[j + gap] = arr[j];
                    j -= gap;
                }
                
                arr[j + gap] = key;
            }
        }
    }
    
    /**
     * 生成Sedgewick增量序列
     */
    private static int[] generateSedgewickGaps(int n) {
        java.util.List<Integer> gaps = new java.util.ArrayList<>();
        
        int k = 0;
        while (true) {
            int gap;
            if (k % 2 == 0) {
                gap = 9 * (1 << k) - 9 * (1 << (k / 2)) + 1;
            } else {
                gap = 8 * (1 << k) - 6 * (1 << ((k + 1) / 2)) + 1;
            }
            
            if (gap >= n) break;
            gaps.add(gap);
            k++;
        }
        
        // 反序返回（从大到小）
        java.util.Collections.reverse(gaps);
        return gaps.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

## 四、插入排序性能比较

```java
/**
 * 插入排序性能测试和比较
 */
public class InsertionSortComparison {
    
    /**
     * 性能测试
     */
    public static void performanceTest() {
        int[] sizes = {1000, 5000, 10000};
        
        for (int size : sizes) {
            System.out.println("\n数组大小: " + size);
            System.out.println("==================");
            
            // 测试随机数组
            testRandomArray(size);
            
            // 测试基本有序数组
            testNearlySortedArray(size);
            
            // 测试逆序数组
            testReverseSortedArray(size);
        }
    }
    
    /**
     * 测试随机数组
     */
    private static void testRandomArray(int size) {
        System.out.println("随机数组测试:");
        
        int[] original = generateRandomArray(size);
        
        testAlgorithm("直接插入排序", original.clone(), InsertionSort::insertionSort);
        testAlgorithm("二分插入排序", original.clone(), BinaryInsertionSort::binaryInsertionSort);
        testAlgorithm("希尔排序(Shell)", original.clone(), ShellSort::shellSort);
        testAlgorithm("希尔排序(Knuth)", original.clone(), ShellSort::shellSortKnuth);
        testAlgorithm("希尔排序(Hibbard)", original.clone(), ShellSort::shellSortHibbard);
    }
    
    /**
     * 测试基本有序数组
     */
    private static void testNearlySortedArray(int size) {
        System.out.println("\n基本有序数组测试:");
        
        int[] original = generateNearlySortedArray(size, 0.1); // 10%的元素乱序
        
        testAlgorithm("直接插入排序", original.clone(), InsertionSort::insertionSort);
        testAlgorithm("二分插入排序", original.clone(), BinaryInsertionSort::binaryInsertionSort);
        testAlgorithm("希尔排序(Shell)", original.clone(), ShellSort::shellSort);
    }
    
    /**
     * 测试逆序数组
     */
    private static void testReverseSortedArray(int size) {
        System.out.println("\n逆序数组测试:");
        
        int[] original = generateReverseSortedArray(size);
        
        testAlgorithm("直接插入排序", original.clone(), InsertionSort::insertionSort);
        testAlgorithm("希尔排序(Shell)", original.clone(), ShellSort::shellSort);
        testAlgorithm("希尔排序(Knuth)", original.clone(), ShellSort::shellSortKnuth);
    }
    
    /**
     * 测试单个算法
     */
    private static void testAlgorithm(String name, int[] arr, java.util.function.Consumer<int[]> sortMethod) {
        long startTime = System.nanoTime();
        sortMethod.accept(arr);
        long endTime = System.nanoTime();
        
        long duration = endTime - startTime;
        System.out.printf("%-20s: %10d ns (%6.2f ms)\n", name, duration, duration / 1_000_000.0);
        
        // 验证排序结果
        if (!isSorted(arr)) {
            System.out.println("错误：排序失败！");
        }
    }
    
    /**
     * 生成随机数组
     */
    private static int[] generateRandomArray(int size) {
        int[] arr = new int[size];
        java.util.Random random = new java.util.Random();
        
        for (int i = 0; i < size; i++) {
            arr[i] = random.nextInt(size * 10);
        }
        
        return arr;
    }
    
    /**
     * 生成基本有序数组
     */
    private static int[] generateNearlySortedArray(int size, double disorder) {
        int[] arr = new int[size];
        
        // 生成有序数组
        for (int i = 0; i < size; i++) {
            arr[i] = i;
        }
        
        // 随机打乱一部分元素
        java.util.Random random = new java.util.Random();
        int swapCount = (int) (size * disorder);
        
        for (int i = 0; i < swapCount; i++) {
            int index1 = random.nextInt(size);
            int index2 = random.nextInt(size);
            
            int temp = arr[index1];
            arr[index1] = arr[index2];
            arr[index2] = temp;
        }
        
        return arr;
    }
    
    /**
     * 生成逆序数组
     */
    private static int[] generateReverseSortedArray(int size) {
        int[] arr = new int[size];
        
        for (int i = 0; i < size; i++) {
            arr[i] = size - i;
        }
        
        return arr;
    }
    
    /**
     * 检查数组是否已排序
     */
    private static boolean isSorted(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] < arr[i - 1]) {
                return false;
            }
        }
        return true;
    }
}
```

## 五、插入排序的实际应用

```java
/**
 * 插入排序的实际应用示例
 */
public class InsertionSortApplications {
    
    /**
     * 混合排序策略 - 快速排序与插入排序结合
     */
    public static void hybridQuickSort(int[] arr, int low, int high) {
        final int INSERTION_SORT_THRESHOLD = 10;
        
        if (low < high) {
            if (high - low <= INSERTION_SORT_THRESHOLD) {
                // 小数组使用插入排序
                insertionSortRange(arr, low, high);
            } else {
                // 大数组使用快速排序
                int pivot = partition(arr, low, high);
                hybridQuickSort(arr, low, pivot - 1);
                hybridQuickSort(arr, pivot + 1, high);
            }
        }
    }
    
    /**
     * 对数组指定范围进行插入排序
     */
    private static void insertionSortRange(int[] arr, int low, int high) {
        for (int i = low + 1; i <= high; i++) {
            int key = arr[i];
            int j = i - 1;
            
            while (j >= low && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    /**
     * 快速排序的分区操作
     */
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        
        return i + 1;
    }
    
    /**
     * 在线排序 - 数据流排序
     */
    public static class OnlineSort {
        private java.util.List<Integer> sortedList;
        
        public OnlineSort() {
            this.sortedList = new java.util.ArrayList<>();
        }
        
        /**
         * 插入新元素并保持有序
         */
        public void insert(int value) {
            int insertPos = binarySearchInsertPosition(sortedList, value);
            sortedList.add(insertPos, value);
        }
        
        /**
         * 获取当前有序列表
         */
        public java.util.List<Integer> getSortedList() {
            return new java.util.ArrayList<>(sortedList);
        }
        
        /**
         * 二分查找插入位置
         */
        private int binarySearchInsertPosition(java.util.List<Integer> list, int value) {
            int left = 0, right = list.size();
            
            while (left < right) {
                int mid = left + (right - left) / 2;
                if (list.get(mid) <= value) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            
            return left;
        }
    }
    
    /**
     * 部分排序 - 只排序前k个最小元素
     */
    public static void partialSort(int[] arr, int k) {
        // 使用插入排序只排序前k个元素
        for (int i = 1; i < Math.min(k, arr.length); i++) {
            int key = arr[i];
            int j = i - 1;
            
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
        
        // 对剩余元素，只需要维护前k个最小值
        for (int i = k; i < arr.length; i++) {
            if (arr[i] < arr[k - 1]) {
                int key = arr[i];
                int j = k - 2;
                
                while (j >= 0 && arr[j] > key) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                
                arr[j + 1] = key;
            }
        }
    }
}
```

## 六、综合测试类

```java
/**
 * 插入类排序综合测试
 */
public class InsertionSortTest {
    
    public static void main(String[] args) {
        System.out.println("插入类排序 - Java代码演示");
        System.out.println("========================");
        
        // 基本功能测试
        testBasicFunctionality();
        
        // 性能比较测试
        InsertionSortComparison.performanceTest();
        
        // 实际应用测试
        testApplications();
    }
    
    /**
     * 基本功能测试
     */
    public static void testBasicFunctionality() {
        System.out.println("1. 基本功能测试:");
        System.out.println("------------------");
        
        int[] testArray = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("原始数组: " + java.util.Arrays.toString(testArray));
        
        // 测试直接插入排序
        int[] arr1 = testArray.clone();
        InsertionSort.insertionSort(arr1);
        System.out.println("直接插入排序: " + java.util.Arrays.toString(arr1));
        
        // 测试二分插入排序
        int[] arr2 = testArray.clone();
        BinaryInsertionSort.binaryInsertionSort(arr2);
        System.out.println("二分插入排序: " + java.util.Arrays.toString(arr2));
        
        // 测试希尔排序
        int[] arr3 = testArray.clone();
        ShellSort.shellSort(arr3);
        System.out.println("希尔排序(Shell): " + java.util.Arrays.toString(arr3));
        
        int[] arr4 = testArray.clone();
        ShellSort.shellSortKnuth(arr4);
        System.out.println("希尔排序(Knuth): " + java.util.Arrays.toString(arr4));
    }
    
    /**
     * 应用测试
     */
    public static void testApplications() {
        System.out.println("\n2. 实际应用测试:");
        System.out.println("------------------");
        
        // 测试在线排序
        System.out.println("在线排序测试:");
        InsertionSortApplications.OnlineSort onlineSort = new InsertionSortApplications.OnlineSort();
        int[] stream = {3, 1, 4, 1, 5, 9, 2, 6};
        
        for (int value : stream) {
            onlineSort.insert(value);
            System.out.println("插入 " + value + ": " + onlineSort.getSortedList());
        }
        
        // 测试部分排序
        System.out.println("\n部分排序测试:");
        int[] arr = {9, 3, 7, 1, 5, 2, 8, 4, 6};
        System.out.println("原始数组: " + java.util.Arrays.toString(arr));
        
        InsertionSortApplications.partialSort(arr, 5);
        System.out.println("前5个最小元素排序: " + java.util.Arrays.toString(arr));
        
        // 测试混合排序
        System.out.println("\n混合排序测试:");
        int[] arr2 = {64, 34, 25, 12, 22, 11, 90, 88, 76, 50, 42};
        System.out.println("原始数组: " + java.util.Arrays.toString(arr2));
        
        InsertionSortApplications.hybridQuickSort(arr2, 0, arr2.length - 1);
        System.out.println("混合排序结果: " + java.util.Arrays.toString(arr2));
    }
}
```

## 七、编译和运行

### 1. 编译命令
```bash
javac InsertionSort.java
javac BinaryInsertionSort.java
javac ShellSort.java
javac InsertionSortComparison.java
javac InsertionSortApplications.java
javac InsertionSortTest.java
```

### 2. 运行命令
```bash
java InsertionSortTest
```

## 八、学习要点

1. **理解插入思想**：将元素插入到已排序序列的正确位置
2. **掌握各种变种**：直接插入、二分插入、希尔排序
3. **分析复杂度**：时间复杂度和空间复杂度的分析
4. **优化策略**：哨兵、二分查找、增量序列选择
5. **实际应用**：混合排序、在线排序、部分排序
6. **性能特点**：在小数据集和基本有序数据上的优势
