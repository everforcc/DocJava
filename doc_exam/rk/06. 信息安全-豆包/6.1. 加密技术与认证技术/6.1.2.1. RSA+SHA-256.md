<span  style="font-family: Simsun,serif; font-size: 17px; ">

~~~text
# 加密+解密+签名+验签完整流程（RSA+SHA-256）
## 一、前置条件
- 发送方A：A私钥（保密）、A公钥（公开）
- 接收方B：B私钥（保密）、B公钥（公开）
- 约定算法：哈希算法SHA-256、非对称加密算法RSA
## 二、发送方A：生成签名+加密数据
1.  准备原始消息
    - 示例："转账1000元给B"
2.  生成消息摘要
    - 公式：消息摘要M = SHA-256(原始消息)
3.  生成数字签名
    - 公式：数字签名S = RSA_Encrypt(消息摘要M, A私钥)
4.  加密原始消息
    - 公式：密文C = RSA_Encrypt(原始消息, B公钥)
5.  发送数据
    - 发送内容：密文C + 数字签名S
## 三、接收方B：解密数据+验证签名
1.  接收数据
    - 接收内容：密文C + 数字签名S
2.  解密原始消息
    - 公式：原始消息 = RSA_Decrypt(密文C, B私钥)
3.  解密签名获取摘要
    - 公式：消息摘要M1 = RSA_Decrypt(数字签名S, A公钥)
4.  重新计算消息摘要
    - 公式：消息摘要M2 = SHA-256(原始消息)
5.  对比摘要完成验签
    - 验签通过：M1 = M2（身份真实+内容未篡改）
    - 验签失败：M1 ≠ M2（数据篡改+身份伪造）
## 四、核心逻辑与考点
1.  双重保障
    - 加密解密：保障数据保密性（仅接收方可读）
    - 签名验签：保障身份真实性+不可否认性
2.  性能优化
    - RSA仅加密短数据（摘要/对称密钥），避免直接加密大文件
3.  密钥使用规则
    - 加密用接收方公钥，解密用接收方私钥
    - 签名用发送方私钥，验签用发送方公钥
~~~

### 为什么RSA和SHA-256结合使用

#### 侧重签名

~~~mermaid
graph TD
    A[原始文本] --> B[SHA-256生成哈希摘要]
    B --> C[用RSA私钥加密摘要（生成签名）]
    C --> D[传输：原始文本 + 签名]
    D --> E[接收方用SHA-256重新生成文本摘要]
    D --> F[接收方用RSA公钥解密签名，得到原始摘要]
    E --> G[对比两个摘要是否一致]
    F --> G
    G --> H{结果}
    H -->|一致| I[文本未篡改+签名者身份可信]
    H -->|不一致| J[文本篡改/签名伪造]
~~~

#### 完整流程-流程图

~~~mermaid
graph TD
    A[发送方] --> A1[原始明文]
    A1 --> A2[生成随机AES密钥（对称密钥）]
    A1 --> A3[SHA-256生成明文的哈希摘要]
    
    A2 --> A4[AES加密明文 → 密文（保证机密性）]
    A2 --> A5[用接收方的RSA公钥加密AES密钥 → 加密后的AES密钥]
    A3 --> A6[用发送方的RSA私钥加密哈希摘要 → 数字签名（保证身份/完整性）]
    
    A4 --> B[传输内容：密文 + 加密后的AES密钥 + 数字签名]
    A5 --> B
    A6 --> B
    
    B --> C[接收方]
    C --> C1[用自己的RSA私钥解密AES密钥]
    C --> C2[用发送方的RSA公钥解密数字签名 → 原始哈希摘要]
    C --> C3[AES解密密文 → 还原明文]
    
    C3 --> C4[SHA-256重新生成明文的哈希摘要]
    C2 --> C5[对比两个哈希摘要是否一致]
    C4 --> C5
    
    C5 --> D{验证结果}
    D -->|一致| E[1. 密文解密成功（机密性）；2. 签名验证通过（身份合法、数据未篡改）]
    D -->|不一致| F[1. 数据被篡改；2. 签名伪造（发送方身份不可信）]
~~~

#### 完整流程-说明

##### 1. 发送方操作（核心：加密数据 + 生成签名）

1. 生成临时 AES 密钥（比如 128 位），用 AES 加密原始明文，得到密文（这是最终传输的核心数据，替代了上一轮的 “原文”）；
2. 用 SHA-256 对原始明文生成哈希摘要（注意：是对明文摘要，不是密文 —— 因为接收方解密后也要对明文摘要，才能对比）；
3. 用发送方自己的 RSA 私钥加密这个哈希摘要，生成数字签名（你的代码中sign()方法就是这个逻辑）；
4. 用接收方的 RSA 公钥加密 AES 密钥（避免 AES 密钥传输被截获）；
5. 传输 3 样东西：AES加密后的密文 + RSA加密后的AES密钥 + RSA私钥签名的哈希摘要（签名）。

##### 2. 接收方操作（核心：解密数据 + 验证签名）

1. 用自己的 RSA 私钥解密 AES 密钥（对应你代码中decryptByPrivateKey()逻辑，只是解密的是 AES 密钥而非原文）；
2. 用解密后的 AES 密钥解密密文，还原出原始明文；
3. 用发送方的 RSA 公钥解密数字签名，得到发送方生成的哈希摘要（对应你代码中verify()方法的解密逻辑）；
4. 对还原出的明文重新用 SHA-256 生成哈希摘要；
5. 对比两个摘要：一致则说明数据未篡改、发送方身份合法；不一致则拒绝接收。

##### 3. 为什么不能直接传原文？为什么 RSA 不直接加密原文？

1. 直接传原文的风险：原文可能包含敏感信息（如密码、交易数据），传输过程中被截获就会泄露，违背 “机密性” 要求；
2. RSA 不直接加密原文的原因：
    - 效率：RSA 加密 1KB 数据的时间≈AES 加密 1GB 数据的时间，处理大数据完全不现实；
    - 长度限制：RSA 加密的明文长度受密钥长度限制（比如 2048 位 RSA 最多加密 245 字节），无法加密长文本；
    - 设计初衷：RSA 的核心价值是 “密钥分发” 和 “数字签名”，而非 “数据加密”。

</span>