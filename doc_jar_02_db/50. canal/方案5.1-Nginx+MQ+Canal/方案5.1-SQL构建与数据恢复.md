<span  style="font-family: Simsun,serif; font-size: 17px; ">

# 方案5.1-SQL构建与数据恢复

## 1. 概述

本文档详细说明如何从 Binlog 事件中构建完整的 SQL 语句（INSERT、UPDATE、DELETE、DDL），以及如何基于这些 SQL 进行数据恢复。

## 2. 从 Binlog 构建完整 SQL

### 2.1 Canal 事件类型

Canal 可以捕获以下事件类型：
- **DML 操作**：INSERT、UPDATE、DELETE
- **DDL 操作**：CREATE、ALTER、DROP、TRUNCATE 等
- **事务控制**：BEGIN、COMMIT、ROLLBACK

### 2.2 DML SQL 构建（INSERT/UPDATE/DELETE）

#### 2.2.1 核心实现类

```java
@Service
public class SQLBuilderService {
    
    /**
     * 从 RowChange 构建 SQL 语句
     */
    public List<String> buildSQL(EntryHeader header, RowChange rowChange) {
        List<String> sqlList = new ArrayList<>();
        String database = header.getSchemaName();
        String table = header.getTableName();
        
        EventType eventType = rowChange.getEventType();
        
        switch (eventType) {
            case INSERT:
                sqlList.addAll(buildInsertSQL(database, table, rowChange));
                break;
            case UPDATE:
                sqlList.addAll(buildUpdateSQL(database, table, rowChange));
                break;
            case DELETE:
                sqlList.addAll(buildDeleteSQL(database, table, rowChange));
                break;
            default:
                log.warn("Unsupported event type: {}", eventType);
        }
        
        return sqlList;
    }
    
    /**
     * 构建 INSERT SQL
     */
    private List<String> buildInsertSQL(String database, String table, RowChange rowChange) {
        List<String> sqlList = new ArrayList<>();
        
        for (RowData rowData : rowChange.getRowDatasList()) {
            List<String> columns = new ArrayList<>();
            List<String> values = new ArrayList<>();
            
            // 获取所有列的值（INSERT 只有 afterColumns）
            for (Column column : rowData.getAfterColumnsList()) {
                columns.add(escapeColumn(column.getName()));
                values.add(formatValue(column.getValue(), column.getMysqlType()));
            }
            
            String sql = String.format(
                "INSERT INTO `%s`.`%s` (%s) VALUES (%s);",
                database,
                table,
                String.join(", ", columns),
                String.join(", ", values)
            );
            
            sqlList.add(sql);
        }
        
        return sqlList;
    }
    
    /**
     * 构建 UPDATE SQL
     */
    private List<String> buildUpdateSQL(String database, String table, RowChange rowChange) {
        List<String> sqlList = new ArrayList<>();
        
        for (RowData rowData : rowChange.getRowDatasList()) {
            List<String> setClauses = new ArrayList<>();
            List<String> whereClauses = new ArrayList<>();
            
            // 构建 SET 子句（使用 afterColumns）
            for (Column column : rowData.getAfterColumnsList()) {
                if (column.getUpdated()) {
                    setClauses.add(String.format(
                        "%s = %s",
                        escapeColumn(column.getName()),
                        formatValue(column.getValue(), column.getMysqlType())
                    ));
                }
            }
            
            // 构建 WHERE 子句（使用 beforeColumns，优先使用主键）
            List<String> primaryKeys = getPrimaryKeys(database, table);
            boolean hasPrimaryKey = false;
            
            for (Column column : rowData.getBeforeColumnsList()) {
                if (primaryKeys.contains(column.getName())) {
                    whereClauses.add(String.format(
                        "%s = %s",
                        escapeColumn(column.getName()),
                        formatValue(column.getValue(), column.getMysqlType())
                    ));
                    hasPrimaryKey = true;
                }
            }
            
            // 如果没有主键，使用所有列作为 WHERE 条件
            if (!hasPrimaryKey) {
                for (Column column : rowData.getBeforeColumnsList()) {
                    whereClauses.add(String.format(
                        "%s = %s",
                        escapeColumn(column.getName()),
                        formatValue(column.getValue(), column.getMysqlType())
                    ));
                }
            }
            
            String sql = String.format(
                "UPDATE `%s`.`%s` SET %s WHERE %s;",
                database,
                table,
                String.join(", ", setClauses),
                String.join(" AND ", whereClauses)
            );
            
            sqlList.add(sql);
        }
        
        return sqlList;
    }
    
    /**
     * 构建 DELETE SQL
     */
    private List<String> buildDeleteSQL(String database, String table, RowChange rowChange) {
        List<String> sqlList = new ArrayList<>();
        
        for (RowData rowData : rowChange.getRowDatasList()) {
            List<String> whereClauses = new ArrayList<>();
            
            // DELETE 使用 beforeColumns
            List<String> primaryKeys = getPrimaryKeys(database, table);
            boolean hasPrimaryKey = false;
            
            for (Column column : rowData.getBeforeColumnsList()) {
                if (primaryKeys.contains(column.getName())) {
                    whereClauses.add(String.format(
                        "%s = %s",
                        escapeColumn(column.getName()),
                        formatValue(column.getValue(), column.getMysqlType())
                    ));
                    hasPrimaryKey = true;
                }
            }
            
            // 如果没有主键，使用所有列作为 WHERE 条件
            if (!hasPrimaryKey) {
                for (Column column : rowData.getBeforeColumnsList()) {
                    whereClauses.add(String.format(
                        "%s = %s",
                        escapeColumn(column.getName()),
                        formatValue(column.getValue(), column.getMysqlType())
                    ));
                }
            }
            
            String sql = String.format(
                "DELETE FROM `%s`.`%s` WHERE %s;",
                database,
                table,
                String.join(" AND ", whereClauses)
            );
            
            sqlList.add(sql);
        }
        
        return sqlList;
    }
    
    /**
     * 格式化值（处理 NULL、字符串转义等）
     */
    private String formatValue(String value, String mysqlType) {
        if (value == null || "NULL".equalsIgnoreCase(value)) {
            return "NULL";
        }
        
        // 字符串类型需要转义和加引号
        if (isStringType(mysqlType)) {
            return "'" + escapeString(value) + "'";
        }
        
        // 数值类型直接返回
        if (isNumericType(mysqlType)) {
            return value;
        }
        
        // 日期时间类型
        if (isDateTimeType(mysqlType)) {
            return "'" + value + "'";
        }
        
        // 二进制类型（BLOB、BINARY等）
        if (isBinaryType(mysqlType)) {
            return "0x" + bytesToHex(value.getBytes());
        }
        
        // 默认按字符串处理
        return "'" + escapeString(value) + "'";
    }
    
    /**
     * 转义字符串（防止 SQL 注入）
     */
    private String escapeString(String value) {
        return value.replace("\\", "\\\\")
                   .replace("'", "\\'")
                   .replace("\"", "\\\"")
                   .replace("\n", "\\n")
                   .replace("\r", "\\r")
                   .replace("\t", "\\t");
    }
    
    /**
     * 转义列名
     */
    private String escapeColumn(String columnName) {
        return "`" + columnName + "`";
    }
    
    /**
     * 获取表的主键列表（需要缓存或查询元数据）
     */
    private List<String> getPrimaryKeys(RowData rowData) {
        List<String> primaryKeys = new ArrayList<>();
        // Canal 的 Column 提供 isKey() 标记，可在无需访问数据库的情况下识别主键
        for (Column column : rowData.getBeforeColumnsList()) {
            if (column.getIsKey()) {
                primaryKeys.add(column.getName());
            }
        }
        return primaryKeys;
    }
    
    // 类型判断辅助方法
    private boolean isStringType(String mysqlType) {
        return mysqlType.contains("CHAR") || mysqlType.contains("TEXT") || 
               mysqlType.contains("ENUM") || mysqlType.contains("SET");
    }
    
    private boolean isNumericType(String mysqlType) {
        return mysqlType.contains("INT") || mysqlType.contains("DECIMAL") || 
               mysqlType.contains("FLOAT") || mysqlType.contains("DOUBLE") ||
               mysqlType.contains("NUMERIC");
    }
    
    private boolean isDateTimeType(String mysqlType) {
        return mysqlType.contains("DATE") || mysqlType.contains("TIME") || 
               mysqlType.contains("YEAR");
    }
    
    private boolean isBinaryType(String mysqlType) {
        return mysqlType.contains("BLOB") || mysqlType.contains("BINARY") ||
               mysqlType.contains("VARBINARY");
    }
}
```

### 2.3 DDL SQL 构建

#### 2.3.1 DDL 事件处理

```java
@Service
public class DDLHandlerService {
    
    /**
     * 处理 DDL 事件
     */
    public String handleDDL(EntryHeader header, RowChange rowChange) {
        String database = header.getSchemaName();
        String table = header.getTableName();
        String ddl = rowChange.getSql();
        
        // DDL SQL 已经在 RowChange 中
        if (ddl != null && !ddl.isEmpty()) {
            // 确保包含数据库名
            if (!ddl.contains(database)) {
                ddl = ddl.replaceFirst("(?i)(ALTER|CREATE|DROP|TRUNCATE)\\s+TABLE\\s+", 
                    "$1 TABLE `" + database + "`.");
            }
            return ddl;
        }
        
        // 如果没有 SQL，根据事件类型构建
        EventType eventType = rowChange.getEventType();
        switch (eventType) {
            case CREATE:
                return buildCreateTableSQL(database, table, rowChange);
            case ALTER:
                return buildAlterTableSQL(database, table, rowChange);
            case ERASE:
            case TRUNCATE:
                return String.format("TRUNCATE TABLE `%s`.`%s`;", database, table);
            case RENAME:
                return buildRenameTableSQL(database, table, rowChange);
            default:
                log.warn("Unsupported DDL event type: {}", eventType);
                return null;
        }
    }
    
    /**
     * 从 RowChange 中提取完整 DDL SQL
     */
    public String extractDDLSQL(EntryHeader header, RowChange rowChange) {
        // Canal 的 DDL 事件中，SQL 通常存储在 RowChange.getSql() 中
        String sql = rowChange.getSql();
        
        if (sql != null && !sql.isEmpty()) {
            // 确保 SQL 以分号结尾
            if (!sql.trim().endsWith(";")) {
                sql = sql + ";";
            }
            return sql;
        }
        
        // 如果 RowChange 中没有 SQL，尝试从其他字段构建
        // 注意：某些 DDL 操作可能无法完全重建，需要记录原始 SQL
        log.warn("DDL SQL not found in RowChange, header: {}", header);
        return null;
    }
}
```

### 2.4 完整的事件处理流程

```java
@Service
public class BinlogEventProcessor {
    
    @Autowired
    private SQLBuilderService sqlBuilderService;
    
    @Autowired
    private DDLHandlerService ddlHandlerService;
    
    /**
     * 处理 Canal 事件，构建完整 SQL
     */
    public BinlogSQLResult processEvent(EntryHeader header, RowChange rowChange) {
        BinlogSQLResult result = new BinlogSQLResult();
        result.setDeviceId(extractDeviceId(header));
        result.setDatabase(header.getSchemaName());
        result.setTable(header.getTableName());
        result.setBinlogFile(header.getLogfileName());
        result.setBinlogPos(header.getLogfileOffset());
        result.setExecuteTime(header.getExecuteTime());
        result.setEventType(rowChange.getEventType().name());
        
        // 判断是 DML 还是 DDL
        if (isDDLEvent(rowChange.getEventType())) {
            // DDL 处理
            String ddlSQL = ddlHandlerService.extractDDLSQL(header, rowChange);
            result.setSqlList(Collections.singletonList(ddlSQL));
            result.setSqlType("DDL");
        } else {
            // DML 处理
            List<String> sqlList = sqlBuilderService.buildSQL(header, rowChange);
            result.setSqlList(sqlList);
            result.setSqlType("DML");
        }
        
        return result;
    }
    
    private boolean isDDLEvent(EventType eventType) {
        return eventType == EventType.CREATE ||
               eventType == EventType.ALTER ||
               eventType == EventType.ERASE ||
               eventType == EventType.TRUNCATE ||
               eventType == EventType.RENAME ||
               eventType == EventType.CINDEX ||
               eventType == EventType.DINDEX;
    }
    
    private String extractDeviceId(EntryHeader header) {
        // 从 header 中提取设备 ID
        // 可以通过 serverName 或其他元数据字段
        return header.getServerName();
    }
}

/**
 * Binlog SQL 结果对象
 */
@Data
public class BinlogSQLResult {
    private String deviceId;
    private String database;
    private String table;
    private String binlogFile;
    private Long binlogPos;
    private Long executeTime;
    private String eventType;
    private String sqlType; // DML 或 DDL
    private List<String> sqlList;
}
```

### 2.5 发送到消息队列

```java
@Service
public class BinlogToMQService {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @Autowired
    private BinlogEventProcessor eventProcessor;
    
    /**
     * 处理 Canal 消息并发送到 MQ
     */
    public void processAndSend(Message message) {
        List<Entry> entries = message.getEntries();
        
        for (Entry entry : entries) {
            if (entry.getEntryType() != EntryType.ROWDATA) {
                continue;
            }
            
            try {
                EntryHeader header = entry.getHeader();
                RowChange rowChange = RowChange.parseFrom(entry.getStoreValue());
                
                // 构建完整 SQL
                BinlogSQLResult result = eventProcessor.processEvent(header, rowChange);
                
                // 发送到消息队列
                sendToMQ(result);
                
            } catch (Exception e) {
                log.error("Failed to process entry", e);
                // 发送到死信队列
                sendToDLQ(entry, e);
            }
        }
    }
    
    private void sendToMQ(BinlogSQLResult result) {
        // 构建消息体
        BinlogMessage message = new BinlogMessage();
        message.setDeviceId(result.getDeviceId());
        message.setDatabase(result.getDatabase());
        message.setTable(result.getTable());
        message.setBinlogFile(result.getBinlogFile());
        message.setBinlogPos(result.getBinlogPos());
        message.setExecuteTime(result.getExecuteTime());
        message.setEventType(result.getEventType());
        message.setSqlType(result.getSqlType());
        message.setSqlList(result.getSqlList());
        message.setTimestamp(System.currentTimeMillis());
        
        // 发送到对应的设备队列
        rabbitTemplate.convertAndSend(
            "device.data.changes",
            "device." + result.getDeviceId(),
            message
        );
    }
}
```

## 3. 数据恢复方案

### 3.1 恢复策略

#### 3.1.1 恢复类型

1. **点对点恢复**：恢复到指定时间点
2. **事务恢复**：恢复到指定事务
3. **Binlog 位置恢复**：恢复到指定 Binlog 位置
4. **全量 + 增量恢复**：先恢复全量备份，再应用增量 Binlog

### 3.2 从消息队列恢复数据

#### 3.2.1 消息队列数据存储

```java
@Service
public class MQDataRecoveryService {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @Autowired
    private MySQLRecoveryService mysqlRecoveryService;
    
    /**
     * 从消息队列恢复数据到指定时间点
     */
    public void recoverToTimestamp(String deviceId, long targetTimestamp) {
        // 1. 获取全量备份
        String backupFile = getLatestBackup(deviceId, targetTimestamp);
        mysqlRecoveryService.restoreFullBackup(deviceId, backupFile);
        
        // 2. 从 MQ 中获取指定时间范围内的消息
        List<BinlogMessage> messages = getMessagesFromMQ(deviceId, 
            getBackupTimestamp(backupFile), targetTimestamp);
        
        // 3. 按时间顺序应用 SQL
        applyMessages(messages);
    }
    
    /**
     * 从消息队列恢复数据到指定 Binlog 位置
     */
    public void recoverToBinlogPosition(String deviceId, String binlogFile, long binlogPos) {
        // 1. 获取全量备份
        String backupFile = getLatestBackup(deviceId);
        mysqlRecoveryService.restoreFullBackup(deviceId, backupFile);
        
        // 2. 从 MQ 中获取指定 Binlog 位置之前的消息
        List<BinlogMessage> messages = getMessagesFromMQ(deviceId, 
            getBackupBinlogPosition(backupFile), binlogFile, binlogPos);
        
        // 3. 按 Binlog 位置顺序应用 SQL
        applyMessages(messages);
    }
    
    /**
     * 从 MQ 获取消息（需要持久化存储）
     */
    private List<BinlogMessage> getMessagesFromMQ(String deviceId, 
                                                   long startTime, 
                                                   long endTime) {
        // 注意：RabbitMQ 默认不持久化历史消息
        // 需要将消息持久化到数据库或文件系统
        return messageStorageService.getMessages(deviceId, startTime, endTime);
    }
    
    /**
     * 应用消息到数据库
     */
    private void applyMessages(List<BinlogMessage> messages) {
        for (BinlogMessage message : messages) {
            try {
                // 按顺序执行 SQL
                for (String sql : message.getSqlList()) {
                    mysqlRecoveryService.executeSQL(message.getDeviceId(), sql);
                }
            } catch (Exception e) {
                log.error("Failed to apply message: {}", message, e);
                // 记录失败，继续处理
            }
        }
    }
}
```

### 3.3 MySQL 恢复服务

```java
@Service
public class MySQLRecoveryService {
    
    /**
     * 恢复全量备份
     */
    public void restoreFullBackup(String deviceId, String backupFile) {
        String instanceId = getInstanceId(deviceId);
        MySQLInstance instance = getInstance(instanceId);
        
        try {
            // 解压备份文件
            String sqlFile = decompressBackup(backupFile);
            
            // 执行恢复
            instance.executeScript(sqlFile);
            
            log.info("Full backup restored for device: {}", deviceId);
        } catch (Exception e) {
            log.error("Failed to restore full backup for device: " + deviceId, e);
            throw new RecoveryException("Restore failed", e);
        }
    }
    
    /**
     * 执行单条 SQL
     */
    public void executeSQL(String deviceId, String sql) {
        String instanceId = getInstanceId(deviceId);
        MySQLInstance instance = getInstance(instanceId);
        
        try {
            instance.execute(sql);
        } catch (Exception e) {
            log.error("Failed to execute SQL for device: {}, SQL: {}", deviceId, sql, e);
            throw new RecoveryException("SQL execution failed", e);
        }
    }
    
    /**
     * 批量执行 SQL（事务控制）
     */
    public void executeBatchSQL(String deviceId, List<String> sqlList) {
        String instanceId = getInstanceId(deviceId);
        MySQLInstance instance = getInstance(instanceId);
        
        try {
            instance.executeBatch(sqlList);
        } catch (Exception e) {
            log.error("Failed to execute batch SQL for device: {}", deviceId, e);
            throw new RecoveryException("Batch SQL execution failed", e);
        }
    }
}
```

### 3.4 消息持久化存储

#### 3.4.1 消息存储服务

```java
@Service
public class MessageStorageService {
    
    @Autowired
    private MessageRepository messageRepository;
    
    /**
     * 存储消息到数据库（用于恢复）
     */
    public void storeMessage(BinlogMessage message) {
        BinlogMessageEntity entity = new BinlogMessageEntity();
        entity.setDeviceId(message.getDeviceId());
        entity.setDatabase(message.getDatabase());
        entity.setTable(message.getTable());
        entity.setBinlogFile(message.getBinlogFile());
        entity.setBinlogPos(message.getBinlogPos());
        entity.setExecuteTime(message.getExecuteTime());
        entity.setEventType(message.getEventType());
        entity.setSqlType(message.getSqlType());
        entity.setSqlList(JSON.toJSONString(message.getSqlList()));
        entity.setTimestamp(message.getTimestamp());
        entity.setCreatedAt(System.currentTimeMillis());
        
        messageRepository.save(entity);
    }
    
    /**
     * 查询指定时间范围内的消息
     */
    public List<BinlogMessage> getMessages(String deviceId, long startTime, long endTime) {
        List<BinlogMessageEntity> entities = messageRepository.findByDeviceIdAndTimestampBetween(
            deviceId, startTime, endTime);
        
        return entities.stream()
            .map(this::toMessage)
            .sorted(Comparator.comparing(BinlogMessage::getExecuteTime))
            .collect(Collectors.toList());
    }
    
    /**
     * 查询指定 Binlog 位置之前的消息
     */
    public List<BinlogMessage> getMessagesBeforePosition(String deviceId, 
                                                        String binlogFile, 
                                                        long binlogPos) {
        // 先找到 binlogFile 和 binlogPos 对应的消息
        BinlogMessageEntity target = messageRepository.findByDeviceIdAndBinlogFileAndBinlogPos(
            deviceId, binlogFile, binlogPos);
        
        if (target == null) {
            return Collections.emptyList();
        }
        
        // 查询该消息之前的所有消息
        return messageRepository.findByDeviceIdAndExecuteTimeLessThan(
            deviceId, target.getExecuteTime())
            .stream()
            .map(this::toMessage)
            .sorted(Comparator.comparing(BinlogMessage::getExecuteTime))
            .collect(Collectors.toList());
    }
}
```

### 3.5 恢复流程示例

#### 3.5.1 完整恢复脚本

```java
@RestController
@RequestMapping("/api/recovery")
public class RecoveryController {
    
    @Autowired
    private MQDataRecoveryService recoveryService;
    
    /**
     * 恢复到指定时间点
     */
    @PostMapping("/to-timestamp")
    public ResponseEntity<String> recoverToTimestamp(
            @RequestParam String deviceId,
            @RequestParam long timestamp) {
        try {
            recoveryService.recoverToTimestamp(deviceId, timestamp);
            return ResponseEntity.ok("Recovery started");
        } catch (Exception e) {
            return ResponseEntity.status(500)
                .body("Recovery failed: " + e.getMessage());
        }
    }
    
    /**
     * 恢复到指定 Binlog 位置
     */
    @PostMapping("/to-position")
    public ResponseEntity<String> recoverToPosition(
            @RequestParam String deviceId,
            @RequestParam String binlogFile,
            @RequestParam long binlogPos) {
        try {
            recoveryService.recoverToBinlogPosition(deviceId, binlogFile, binlogPos);
            return ResponseEntity.ok("Recovery started");
        } catch (Exception e) {
            return ResponseEntity.status(500)
                .body("Recovery failed: " + e.getMessage());
        }
    }
}
```

## 4. 数据一致性校验

### 4.1 校验服务

```java
@Service
public class DataConsistencyService {
    
    /**
     * 校验主库和从库数据一致性
     */
    public ConsistencyReport checkConsistency(String deviceId) {
        // 1. 获取主库数据（通过 SSH 隧道或代理）
        Map<String, Object> masterData = getMasterData(deviceId);
        
        // 2. 获取从库数据
        Map<String, Object> slaveData = getSlaveData(deviceId);
        
        // 3. 比较数据
        return compareData(masterData, slaveData);
    }
    
    /**
     * 修复不一致数据
     */
    public void repairData(String deviceId, ConsistencyReport report) {
        for (Inconsistency inconsistency : report.getInconsistencies()) {
            // 使用主库数据修复从库
            String repairSQL = buildRepairSQL(inconsistency);
            executeRepairSQL(deviceId, repairSQL);
        }
    }
}
```

## 5. 最佳实践

1. **SQL 构建**：
   - 始终使用参数化查询或转义，防止 SQL 注入
   - 处理 NULL 值和特殊字符
   - 优先使用主键构建 WHERE 条件

2. **数据恢复**：
   - 恢复前先备份当前数据
   - 在测试环境先验证恢复流程
   - 记录恢复过程中的所有操作

3. **消息存储**：
   - 重要消息持久化到数据库
   - 定期清理过期消息
   - 建立消息索引提高查询效率

4. **错误处理**：
   - 记录所有失败的 SQL
   - 提供重试机制
   - 建立告警机制

</span>

